<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Sudan Situation" />





<meta name="date" content="2025-02-10" />

<meta name="description" content="Sudan Situation">

<script id="pandoc-meta" type="application/json">
{"author":[{"affiliation":"Information Management Officer","email":"<a href=\"mailto:vidonne@unhcr.org\" class=\"email\">vidonne@unhcr.org</a>","name":"Cédric Vidonne"}],"date":"10 February 2025","links-to-footnotes":true,"newpage_html_class":"page-break-after","output":{"unhcrdown::paged_simple":{"back_html":true,"extra_css":"path_to_css.css"}},"paged-footnotes":true,"subtitle":"R Workflow Demo","title":"Sudan Situation"}
</script>

<title>Sudan Situation</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@import url(data:text/css,%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Lato%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20400%3B%0Afont%2Ddisplay%3A%20swap%3B%0Asrc%3A%20url%28data%3Afont%2Fttf%3Bbase64%2CAAEAAAAQAQAABAAAR1BPU3F0lNEAABSoAAASekdTVUKOPI56AAACcAAAAHBPUy8yeSRheQAAAhAAAABgY21hcK2ZsYwAAALgAAAAxGN2dCAG9xijAAABXAAAAC5mcGdtclpyQAAADcAAAAblZ2FzcAASABgAAAEMAAAADGdseWabM8FPAAAnJAAAxVhoZWFk%2FJzyIwAAAYwAAAA2aGhlYQ%2B2B3cAAAE4AAAAJGhtdHh9g083AAAKSAAAA3Zsb2Nh%2B%2FjNOQAAA6QAAAHCbWF4cAHZB%2FkAAAEYAAAAIG5hbWU26FMEAAAHsAAAAphwb3N0V9sNeAAABWgAAAJFcHJlcKYHlRcAAAHEAAAASwABAAIAEgAH%2F%2F8ADwABAAAA4ACCAAcAYgAEAAIAIgAtADkAAACQBuUAAgABAAEAAAe2%2FlYAAAkC%2F0T%2FQwi5AAEAAAAAAAAAAAAAAAAAAADbAAAAAAAAAAAAAAC4AIsAuAC4AIsAjAWZAAAFugP1AAD%2BqQWp%2F%2FAFugQF%2F%2FL%2BlAAAAAEAAAABGqCGPsgSXw889QAZB9AAAAAAypNecAAAAADK3y6F%2F0T%2Bkwi5By0AAAAJAAIAAAAAAAC5CAAIAGMgsAEjRCCwAyNwsBRFICCwKGBmIIpVWLACJWGwAUVjI2KwAiNEswkKAwIrswsQAwIrsxEWAwIrWbIEKAZFUkSzCxAEAisAAAMEEgGQAAUAAAV4BRQAAAEYBXgFFAAAA7oAeAH0CAMCDwUCAgIEAwIDgAAAJwAAAEoAAAAAAAAAAHR5UEwAQAAAIhIGSv56AZAHtgGqIAAAkwAAAAAD9QWZAAAAIAACAAEAAAAKADAARAACREZMVAAabGF0bgAOAAQAAAAA%2F%2F8AAQABAAQAAAAA%2F%2F8AAQAAAAJsaWdhAA5saWdhAA4AAAABAAAAAQAEAAQAAAABAAgAAQAaAAEACAACAAwABgDZAAIATwDYAAIATAABAAEASQAAAAIAAAADAAAAFAADAAEAAAAUAAQAsAAAACgAIAAEAAgAAAANAH4A%2FwExAVMCxgLaAtwgFCAaIB4gIiAmIDogRCCsISIiEv%2F%2FAAAAAAANACAAoAExAVICxgLaAtwgEyAYIBwgIiAmIDkgRCCsISIiEv%2F%2FAAH%2F9f%2Fj%2F8L%2Fkf9x%2Ff%2F97P3r4LXgsuCx4K7gq%2BCZ4JDgKd%2B03sUAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADZANkA2QDZAUwBwgLDA%2BQFEAYhBmEGlAbHB0gHmwf5CBkIYgiOCQgJkQo5Cx8LrQxiDPkNUQ4XDrQPOQ%2FVD%2F4QKxBSEQgSKxK1E1MT%2FxRpFNIVLRXsFlwWkRcOF60X7xiMGP4ZehnpGrMbXBwSHHMc6h1KHdseYR7JHyQfWR%2BFH7cgByApIFghQyIsIusjwiSNJU0mficcJ6UoYykiKWcqMirRK1wsUS1HLd0uki9tMBAwcDEXMZ8yCDJjMtszBjN%2FM80zzTRANWE2TzbtN7E37ji1OSc6WDsgO2s7pDvEPQE9IT2EPeo%2BbT8cP0xAKECaQM1BXEHKQitCb0OXRPNGq0djR29He0eHR5NHn0erSGpKE0ofSitKN0pDSk9KW0pnSnNLHEsoSzRLQEtMS1hLZEuJTG9Me0yHTJNMn0yrTSRN%2FU4JThVOIU4tTjlORVCXUa9Ru1HHUdNR31HrUfdSA1IPUrZSwlLOUtpS5lLyUv5TYFRKVFZUYlRuVHpUhlV9VYlVw1clWMNZC1lkWfdaF1o3WmNaj1q7WwlbWFunW%2BVch1yxXNhdDl42XuhfCF%2FxYPFhFWF6YaFh4GIpYqwAAAACAAAAAAAA%2F3QAeAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAECAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAQMAowCEAIUAvQCWAOgAhgCOAIsAnQCpAKQBBACKANoAgwCTAPIA8wCNAJcAiADDAN4A8QCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB%2FAH4AgACBAOwA7gC6ANcAsACxANgA3QDZALIAswC2ALcAxAC0ALUAxQCHAKsAvgC%2FALwBBQCMAO8AwADBAQYBBwEIAQkBCgELBE5VTEwHdW5pMDBBMAd1bmkwMEFEBEV1cm8KZ3JhdmUuY2FzZQ1kaWVyZXNpcy5jYXNlCmFjdXRlLmNhc2UPY2lyY3VtZmxleC5jYXNlCXJpbmcuY2FzZQp0aWxkZS5jYXNlAAAAAAAACABmAAMAAQQJAAABFAEeAAMAAQQJAAEACAEWAAMAAQQJAAIADgEIAAMAAQQJAAMAVAC0AAMAAQQJAAQAGACcAAMAAQQJAAUAUABMAAMAAQQJAAYAGAA0AAMAAQQJAA4ANAAAAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATABMAGEAdABvAC0AUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMAA0ADsAIABXAGUAcwB0AGUAcgBuACsAUABvAGwAaQBzAGgAIABvAHAAZQBuAHMAbwB1AHIAYwBlAEwAYQB0AG8AIABSAGUAZwB1AGwAYQByAHQAeQBQAG8AbABhAG4AZABMAHUAawBhAHMAegBEAHoAaQBlAGQAegBpAGMAOgAgAEwAYQB0AG8AIABSAGUAZwB1AGwAYQByADoAIAAyADAAMQAxAFIAZQBnAHUAbABhAHIATABhAHQAbwBDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADEAMAAtADIAMAAxADEAIABiAHkAIAB0AHkAUABvAGwAYQBuAGQAIABMAHUAawBhAHMAegAgAEQAegBpAGUAZAB6AGkAYwAgAHcAaQB0AGgAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAgACIATABhAHQAbwAiAC4AIABMAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgQnAC0AAAAAAAAAAAGCAAACrgDaAxoAmASIADYEiABqBiQASAV%2BAFIBzACYAlgAhgJYAEoDIABgBIgAZAGoAF4CtgBkAagAWALq%2F%2FQEiAA8BIgAygSIAGgEiABsBIgAKASIAGwEiABsBIgAbgSIAGAEiACUAfgAgAH4AIAEiACUBIgAlgSIAO4DHAAiBmwAVgVQAAoFDgCuBVoAWgXiAK4EigCuBGwArgW8AFoF6ACuAmYA0gN4ADwFUgDCBAQArgcwAK4F6ACuBjwAXATGAMIGPABcBQgAwgQkADoEnAAcBbQAoAVQAAgH9gAOBQYADgTqAAgE4ABWAlgAjgLu%2F%2BwCWABaBIgAngMUAAACZgAmA%2FYAXAReAJgDpgBKBF4ASAQYAEoCogAaA%2F4AMgRYAJICAACCAfz%2FyAQYAJgCAACmBmoAkgRYAJIEWABIBFAAkgReAEgDJgCSA2QAPgLqACwEWAB6BAAAEgX8AA4D8AAcBAAADgOcAEYCWAAsAlgA5gJYAFgEiAB0AYIAAAKuANoEiACKBIgANASIAIQEiAAsAlgA5gPuAHICZgAOBjwARAKsAFwDngCKBIgAlAK2AGQGPABEAmYAFAMaAEYEiABkApgAUgKYAFQCZgDEBFgAegU6ACoCIgB8AmYAhAKYAHgC%2BgBIA54AlgWQAGYFkABmBZIARAMcACwFUAAKBVAACgVQAAoFUAAKBVAACgVQAAoHQv%2FoBVoAWgSKAK4EigCuBIoArgSKAK4CZv%2FMAmYAmgJm%2F%2B8CZv%2FyBioAMgXoAK4GPABcBjwAXAY8AFwGPABcBjwAXASIAH4GPABcBbQAoAW0AKAFtACgBbQAoATqAAgExgDCBMIAugP2AFwD9gBcA%2FYAXAP2AFwD9gBcA%2FYAXAZgAFwDpgBKBBgASgQYAEoEGABKBBgASgIA%2F%2FkCAACXAgD%2F0gIA%2F%2BEEUgBMBFgAkgRYAEgEWABIBFgASARYAEgEWABIBIgAZARYAEAEWAB6BFgAegRYAHoEWAB6BAAADgRQAJIEAAAOAgAApgiQAFwGxgBIAmYAAAJmAGoCZgASBFgAnAZqAJwBqAA6AagAWgGoAFoC2AA6AtgAWgLYAFoEiADQBa4AWAJ4AIoCeACWAmb%2FRASIACIFoABABIgAlAR0ABoEpAAaAmb%2F1P%2FwAKL%2F7AB2ABoAALAALCBksCBgZiOwAFBYZVktsAEsIGQgsMBQsAQmWrAERVtYISMhG4pYILBQUFghsEBZGyCwOFBYIbA4WVkgsAlFYWSwKFBYIbAJRSCwMFBYIbAwWRsgsMBQWCBmIIqKYSCwClBYYBsgsCBQWCGwCmAbILA2UFghsDZgG2BZWVkbsAArWVkjsABQWGVZWS2wAiywByNCsAYjQrAAI0KwAEOwBkNRWLAHQyuyAAEAQ2BCsBZlHFktsAMssABDIEUgsAJFY7ABRWJgRC2wBCywAEMgRSCwACsjsQYEJWAgRYojYSBkILAgUFghsAAbsDBQWLAgG7BAWVkjsABQWGVZsAMlI2FERC2wBSywAWAgILAJQ0qwAFBYILAJI0JZsApDSrAAUlggsAojQlktsAYssABDsAIlQrIAAQBDYEKxCQIlQrEKAiVCsAEWIyCwAyVQWLAAQ7AEJUKKiiCKI2GwBSohI7ABYSCKI2GwBSohG7AAQ7ACJUKwAiVhsAUqIVmwCUNHsApDR2CwgGIgsAJFY7ABRWJgsQAAEyNEsAFDsAA%2BsgEBAUNgQi2wBywAIGCwAWGzCwsBAEKKYLEGAistsAgsIGCwC2AgQyOwAWBDsAIlsAIlUVgjIDywAWAjsBJlHBshIVktsAkssAgrsAgqLbAKLCAgRyAgsAJFY7ABRWJgI2E4IyCKVVggRyAgsAJFY7ABRWJgI2E4GyFZLbALLACwARawCiqwARUwLbAMLCA1sAFgLbANLACwA0VjsAFFYrAAK7ACRWOwAUVisAArsAAWtAAAAAAARD4jOLEMARUqLbAOLCA8IEcgsAJFY7ABRWJgsABDYTgtsA8sLhc8LbAQLCA8IEcgsAJFY7ABRWJgsABDYbABQ2M4LbARLLECABYlIC4gR7AAI0KwAiVJiopHI0cjYWKwASNCshABARUUKi2wEiywABawBCWwBCVHI0cjYbABK2WKLiMgIDyKOC2wEyywABawBCWwBCUgLkcjRyNhILAFI0KwASsgsGBQWCCwQFFYswMgBCAbswMmBBpZQkIjILAIQyCKI0cjRyNhI0ZgsAVDsIBiYCCwACsgiophILADQ2BkI7AEQ2FkUFiwA0NhG7AEQ2BZsAMlsIBiYSMgILAEJiNGYTgbI7AIQ0awAiWwCENHI0cjYWAgsAVDsIBiYCMgsAArI7AFQ2CwACuwBSVhsAUlsIBisAQmYSCwBCVgZCOwAyVgZFBYIRsjIVkjICCwBCYjRmE4WS2wFCywABYgICCwBSYgLkcjRyNhIzw4LbAVLLAAFiCwCCNCICAgRiNHsAArI2E4LbAWLLAAFrADJbACJUcjRyNhsABUWC4gPCMhG7ACJbACJUcjRyNhILAFJbAEJUcjRyNhsAYlsAUlSbACJWGwAUVjI2JjsAFFYmAjLiMgIDyKOCMhWS2wFyywABYgsAhDIC5HI0cjYSBgsCBgZrCAYiMgIDyKOC2wGCwjIC5GsAIlRlJYIDxZLrEJARQrLbAZLCMgLkawAiVGUFggPFkusQkBFCstsBosIyAuRrACJUZSWCA8WSMgLkawAiVGUFggPFkusQkBFCstsBsssAAVIEewACNCsgABARUUEy6wDiotsBwssAAVIEewACNCsgABARUUEy6wDiotsB0ssQABFBOwDyotsB4ssBEqLbAjLLASKyMgLkawAiVGUlggPFkusQkBFCstsCYssBMriiAgPLAFI0KKOCMgLkawAiVGUlggPFkusQkBFCuwBUMusAkrLbAkLLAAFrAEJbAEJiAuRyNHI2GwASsjIDwgLiM4sQkBFCstsCEssQgEJUKwABawBCWwBCUgLkcjRyNhILAFI0KwASsgsGBQWCCwQFFYswMgBCAbswMmBBpZQkIjIEewBUOwgGJgILAAKyCKimEgsANDYGQjsARDYWRQWLADQ2EbsARDYFmwAyWwgGJhsAIlRmE4IyA8IzgbISAgRiNHsAArI2E4IVmxCQEUKy2wICywCCNCsB8rLbAiLLASKy6xCQEUKy2wJSywEyshIyAgPLAFI0IjOLEJARQrsAVDLrAJKy2wHyywABZFIyAuIEaKI2E4sQkBFCstsCcssBQrLrEJARQrLbAoLLAUK7AYKy2wKSywFCuwGSstsCossAAWsBQrsBorLbArLLAVKy6xCQEUKy2wLCywFSuwGCstsC0ssBUrsBkrLbAuLLAVK7AaKy2wLyywFisusQkBFCstsDAssBYrsBgrLbAxLLAWK7AZKy2wMiywFiuwGistsDMssBcrLrEJARQrLbA0LLAXK7AYKy2wNSywFyuwGSstsDYssBcrsBorLbA3LCstsDgssDcqsAEVMC0AAAAAAQAAAAoAMABEAAJERkxUABpsYXRuAA4ABAAAAAD%2F%2FwABAAEABAAAAAD%2F%2FwABAAAAAmtlcm4ADmtlcm4ADgAAAAEAAAABAAQAAgAAAAEACAABAOAABAAAAGsRGBEYEJoRGA%2FsD2YP7A3UDUYMdAxKDUYLjAtSCpgJgg1GCNwNRgiOBzwLUg3UBioKmASgA%2BoQmgx0A6QDUgNSAwgDpAK%2BA6QDpANSA1ICjAIKAfgCvgIKEJoRGA9mD2YNRhEYAboBug9mAboRGA9mDHQMdAx0DHQMdAx0DEoNRg1GDUYNRg1GDUYLUgtSC1ILUgSgDUYDpAOkA6QDpAOkA6QDUgNSA1IDUgNSA6QDUgNSA1IDUgNSA1IDUgNSD2YPZhEYERgP7BEYERgP7A9mD2YPZhEYAAEAawAFAAoACwANAA8AEAARABIAIwAkACYAJwApAC0ALgAvADIAMwA0ADUANwA4ADkAOgA7ADwAPQA%2BAD8ARABFAEgASQBLAE4AUABRAFIAUwBVAFkAWgBbAFwAXgBsAG0AbwBwAHIAdAB1AHkAewB8AH0AggCDAIQAhQCGAIcAiQCSAJQAlQCWAJcAmACbAJwAnQCeAJ8AoACiAKMApAClAKYApwCoAKoAqwCsAK0AswC0ALUAtgC3ALgAugDAAMQAyADJAMoAywDMAM0AzgDPANAA0gDTANYADwAJ%2F0gAEv9IACT%2FSAA5ADoAOgA6ADwAKAA%2FADoAgv9IAIP%2FSACE%2F0gAhf9IAIb%2FSACH%2F0gAiP9IAJ8AKAAEAA%2F%2FwgAR%2F8IAzP%2FCAM%2F%2FwgAgAAn%2FrgAP%2F3wAEf98ABL%2FrgAk%2F64ARv%2FmAEf%2F5gBI%2F%2BYAUv%2FmAFT%2F5gCC%2F64Ag%2F%2BuAIT%2FrgCF%2F64Ahv%2BuAIf%2FrgCI%2F64Aqf%2FmAKr%2F5gCr%2F%2BYArP%2FmAK3%2F5gCy%2F%2BYAtP%2FmALX%2F5gC2%2F%2BYAt%2F%2FmALj%2F5gC6%2F%2BYAxP%2FmAMz%2FfADP%2F3wADAAP%2F3wAEf98AET%2F2gCi%2F9oAo%2F%2FaAKT%2F2gCl%2F9oApv%2FaAKf%2F2gCo%2F9oAzP98AM%2F%2FfAASAEb%2FxABH%2F8QASP%2FEAFL%2FxABU%2F8QAqf%2FEAKr%2FxACr%2F8QArP%2FEAK3%2FxACy%2F8QAtP%2FEALX%2FxAC2%2F8QAt%2F%2FEALj%2FxAC6%2F8QAxP%2FEABIABQBEAAoARAANAEQAD%2F9%2BABH%2FfgBsAEQAcgBEAHQAZAB1AGQAewBkAHwARADKAEQAywBEAMz%2FfgDNAEQAzgBEAM%2F%2FfgDWAEQAFAAF%2F6QACv%2BkAAz%2F4AAN%2F6QAOf%2BMADr%2F4AA%2F%2F4wAQP%2FgAFn%2F5gBb%2F8QAXP%2FmAGD%2F4ABs%2F6QAcv%2BkAHz%2FpADK%2F6QAy%2F%2BkAM3%2FpADO%2F6QA1v%2BkABEABf%2B4AAr%2FuAAN%2F7gAWf%2FgAFr%2F8ABc%2F%2BAAbP%2B4AHL%2FuAB0%2F7gAdf%2B4AHv%2FuAB8%2F7gAyv%2B4AMv%2FuADN%2F7gAzv%2B4ANb%2FuAAtABD%2FugAiACIAI%2F%2FGACb%2FxgAq%2F8YAMv%2FGADT%2FxgBG%2F9oAR%2F%2FaAEj%2F2gBS%2F9oAVP%2FaAFb%2F5ABZ%2F9gAXP%2FYAG3%2FugBv%2F7oAef%2B6AH3%2FugCJ%2F8YAlP%2FGAJX%2FxgCW%2F8YAl%2F%2FGAJj%2FxgCa%2F8YAqf%2FaAKr%2F2gCr%2F9oArP%2FaAK3%2F2gCy%2F9oAtP%2FaALX%2F2gC2%2F9oAt%2F%2FaALj%2F2gC6%2F9oAw%2F%2FGAMT%2F2gDI%2F7oAyf%2B6AND%2FugDS%2F7oA0%2F%2B6AGIABQAeAAn%2FXAAKAB4ADQAeAA%2F%2FaAAQ%2F2AAEf9oABL%2FXAAd%2F4YAHv%2BGACIAIgAj%2F7AAJP9cACb%2FsAAq%2F7AALf84ADL%2FsAA0%2F7AARP%2BAAEb%2FYABH%2F2AASP9gAEr%2FVABQ%2F4YAUf%2BGAFL%2FYABT%2F4YAVP9gAFX%2FhgBW%2F4AAWP%2BGAFn%2FnABa%2F6QAW%2F98AFz%2FnABsAB4Abf9gAG%2F%2FYAByAB4AdAAyAHUAMgB3%2F4YAef9gAHsAMgB8AB4Aff9gAIL%2FXACD%2F1wAhP9cAIX%2FXACG%2F1wAh%2F9cAIj%2FXACJ%2F7AAlP%2BwAJX%2FsACW%2F7AAl%2F%2BwAJj%2FsACa%2F7AAov%2BAAKP%2FgACk%2F4AApf%2BAAKb%2FgACn%2F4AAqP%2BAAKn%2FYACq%2F2AAq%2F9gAKz%2FYACt%2F2AAsv9gALP%2FhgC0%2F2AAtf9gALb%2FYAC3%2F2AAuP9gALr%2FYAC7%2F4YAvP%2BGAL3%2FhgC%2B%2F4YAw%2F%2BwAMT%2FYADI%2F2AAyf9gAMoAHgDLAB4AzP9oAM0AHgDOAB4Az%2F9oAND%2FYADS%2F2AA0%2F9gANYAHgBEAAUAMAAJ%2F6IACgAwAA0AMAAP%2F4YAEP%2FgABH%2FhgAS%2F6IAIgAiACT%2FogAt%2F5oARP%2BoAEb%2F4ABH%2F%2BAASP%2FgAEr%2FngBS%2F%2BAAVP%2FgAFb%2F0gBsADAAbf%2FgAG%2F%2F4AByADAAdAAwAHUAMAB5%2F%2BAAewAwAHwAMAB9%2F%2BAAgv%2BiAIP%2FogCE%2F6IAhf%2BiAIb%2FogCH%2F6IAiP%2BiAKL%2FqACj%2F6gApP%2BoAKX%2FqACm%2F6gAp%2F%2BoAKj%2FqACp%2F%2BAAqv%2FgAKv%2F4ACs%2F%2BAArf%2FgALL%2F4AC0%2F%2BAAtf%2FgALb%2F4AC3%2F%2BAAuP%2FgALr%2F4ADE%2F%2BAAyP%2FgAMn%2F4ADKADAAywAwAMz%2FhgDNADAAzgAwAM%2F%2FhgDQ%2F%2BAA0v%2FgANP%2F4ADWADAAVAAJ%2F3wAD%2F9MABD%2FTAAR%2F0wAEv98AB3%2FYAAe%2F2AAI%2F%2BeACT%2FfAAm%2F54AKv%2BeAC3%2FOAAy%2F54ANP%2BeAET%2FBgBG%2Fy4AR%2F8uAEj%2FLgBK%2F0QAUP9gAFH%2FYABS%2Fy4AU%2F9gAFT%2FLgBV%2F2AAVv9eAFj%2FYABZ%2F0wAWv90AFv%2FcABc%2F0wAXf%2BIAG3%2FTABv%2F0wAd%2F9gAHn%2FTAB9%2F0wAgv98AIP%2FfACE%2F3wAhf98AIb%2FfACH%2F3wAiP98AIn%2FngCU%2F54Alf%2BeAJb%2FngCX%2F54AmP%2BeAJr%2FngCi%2FwYAo%2F8GAKT%2FBgCl%2FwYApv8GAKf%2FBgCo%2FwYAqf8uAKr%2FLgCr%2Fy4ArP8uAK3%2FLgCy%2Fy4As%2F9gALT%2FLgC1%2Fy4Atv8uALf%2FLgC4%2Fy4Auv8uALv%2FYAC8%2F2AAvf9gAL7%2FYADD%2F54AxP8uAMj%2FTADJ%2F0wAzP9MAM%2F%2FTADQ%2F0wA0v9MANP%2FTAATACP%2F0gAm%2F9IAKv%2FSADL%2F0gA0%2F9IAN%2F%2FMADj%2F1gCJ%2F9IAlP%2FSAJX%2F0gCW%2F9IAl%2F%2FSAJj%2F0gCa%2F9IAm%2F%2FWAJz%2F1gCd%2F9YAnv%2FWAMP%2F0gApAAn%2FdgAP%2FwgAEf8IABL%2FdgAk%2F3YALf9KAET%2FzgBG%2F%2BIAR%2F%2FiAEj%2F4gBS%2F%2BIAVP%2FiAIL%2FdgCD%2F3YAhP92AIX%2FdgCG%2F3YAh%2F92AIj%2FdgCi%2F84Ao%2F%2FOAKT%2FzgCl%2F84Apv%2FOAKf%2FzgCo%2F84Aqf%2FiAKr%2F4gCr%2F%2BIArP%2FiAK3%2F4gCy%2F%2BIAtP%2FiALX%2F4gC2%2F%2BIAt%2F%2FiALj%2F4gC6%2F%2BIAxP%2FiAMz%2FCADP%2FwgARQAF%2Ft4ACv7eAA3%2B3gAPADYAEP86ABEANgAi%2F84AI%2F%2BwACb%2FsAAq%2F7AAMv%2BwADT%2FsAA3%2F1QAOf9KADr%2FaAA8%2FywAP%2F9KAEb%2F3ABH%2F9wASP%2FcAFL%2F3ABU%2F9wAWf%2BUAFr%2FsABc%2F5QAbP7eAG3%2FOgBv%2FzoAcv7eAHT%2FNgB1%2FzYAef86AHv%2FNgB8%2Ft4Aff86AIn%2FsACU%2F7AAlf%2BwAJb%2FsACX%2F7AAmP%2BwAJr%2FsACf%2FywAqf%2FcAKr%2F3ACr%2F9wArP%2FcAK3%2F3ACy%2F9wAtP%2FcALX%2F3AC2%2F9wAt%2F%2FcALj%2F3AC6%2F9wAw%2F%2BwAMT%2F3ADI%2FzoAyf86AMr%2B3gDL%2Ft4AzAA2AM3%2B3gDO%2Ft4AzwA2AND%2FOgDS%2FzoA0%2F86ANb%2B3gAuABD%2FwgAj%2F%2BIAJv%2FiACr%2F4gAy%2F%2BIANP%2FiAEb%2F3ABH%2F9wASP%2FcAEn%2FzABS%2F9wAVP%2FcAFf%2FrgBZ%2F74AWv%2FIAFz%2FvgBt%2F8IAb%2F%2FCAHn%2FwgB9%2F8IAif%2FiAJT%2F4gCV%2F%2BIAlv%2FiAJf%2F4gCY%2F%2BIAmv%2FiAKn%2F3ACq%2F9wAq%2F%2FcAKz%2F3ACt%2F9wAsv%2FcALT%2F3AC1%2F9wAtv%2FcALf%2F3AC4%2F9wAuv%2FcAMP%2F4gDE%2F9wAyP%2FCAMn%2FwgDQ%2F8IA0v%2FCANP%2FwgAOAAn%2FyAAP%2F84AEf%2FOABL%2FyAAk%2F8gAgv%2FIAIP%2FyACE%2F8gAhf%2FIAIb%2FyACH%2F8gAiP%2FIAMz%2FzgDP%2F84ALwAJ%2F3wAD%2F9MABH%2FTAAS%2F3wAHf%2FEAB7%2FxAAiAB4AJP98AC3%2FOgBG%2F7oAR%2F%2B6AEj%2FugBQ%2F8QAUf%2FEAFL%2FugBT%2F8QAVP%2B6AFX%2FxABY%2F8QAd%2F%2FEAIL%2FfACD%2F3wAhP98AIX%2FfACG%2F3wAh%2F98AIj%2FfACp%2F7oAqv%2B6AKv%2FugCs%2F7oArf%2B6ALL%2FugCz%2F8QAtP%2B6ALX%2FugC2%2F7oAt%2F%2B6ALj%2FugC6%2F7oAu%2F%2FEALz%2FxAC9%2F8QAvv%2FEAMT%2FugDM%2F0wAz%2F9MAAoAEP9qAG3%2FagBv%2F2oAef9qAH3%2FagDI%2F2oAyf9qAND%2FagDS%2F2oA0%2F9qADQABf9KAAr%2FSgAN%2F0oAEP%2FMACL%2FyAAj%2F9YAJv%2FWACr%2F1gAtADIAMv%2FWADT%2F1gA3%2F3wAOP%2FIADn%2FeAA6%2F6wAPP9cAD%2F%2FeABZ%2F64AXP%2BuAGz%2FSgBt%2F8wAb%2F%2FMAHL%2FSgB0%2F0gAdf9IAHn%2FzAB7%2F0gAfP9KAH3%2FzACJ%2F9YAlP%2FWAJX%2F1gCW%2F9YAl%2F%2FWAJj%2F1gCa%2F9YAm%2F%2FIAJz%2FyACd%2F8gAnv%2FIAJ%2F%2FXADD%2F9YAyP%2FMAMn%2FzADK%2F0oAy%2F9KAM3%2FSgDO%2F0oA0P%2FMANL%2FzADT%2F8wA1v9KACMABf%2FSAAn%2F1gAK%2F9IADP%2FYAA3%2F0gAP%2F8gAEf%2FIABL%2F1gAk%2F9YAN%2F%2BeADn%2FzAA7%2F%2BIAPP%2BwAD3%2FugA%2F%2F8wAQP%2FYAGD%2F2ABs%2F9IAcv%2FSAHz%2F0gCC%2F9YAg%2F%2FWAIT%2F1gCF%2F9YAhv%2FWAIf%2F1gCI%2F9YAn%2F%2BwAMr%2F0gDL%2F9IAzP%2FIAM3%2F0gDO%2F9IAz%2F%2FIANb%2F0gBkAAUAMAAJ%2F3gACgAwAA0AMAAP%2F0AAEP%2BQABH%2FQAAS%2F3gAHf%2BoAB7%2FqAAiADAAI%2F%2FMACT%2FeAAm%2F8wAKv%2FMAC3%2FaAAy%2F8wANP%2FMAET%2FjABG%2F4wAR%2F%2BMAEj%2FjABJ%2F%2BIASv94AFD%2FqABR%2F6gAUv%2BMAFP%2FqABU%2F4wAVf%2BoAFb%2FlgBX%2F9YAWP%2BoAFn%2F0ABb%2F8wAXP%2FQAF3%2FrgBsADAAbf%2BQAG%2F%2FkAByADAAdAA6AHUAOgB3%2F6gAef%2BQAHsAOgB8ADAAff%2BQAIL%2FeACD%2F3gAhP94AIX%2FeACG%2F3gAh%2F94AIj%2FeACJ%2F8wAlP%2FMAJX%2FzACW%2F8wAl%2F%2FMAJj%2FzACa%2F8wAov%2BMAKP%2FjACk%2F4wApf%2BMAKb%2FjACn%2F4wAqP%2BMAKn%2FjACq%2F4wAq%2F%2BMAKz%2FjACt%2F4wAsv%2BMALP%2FqAC0%2F4wAtf%2BMALb%2FjAC3%2F4wAuP%2BMALr%2FjAC7%2F6gAvP%2BoAL3%2FqAC%2B%2F6gAw%2F%2FMAMT%2FjADI%2F5AAyf%2BQAMoAMADLADAAzP9AAM0AMADOADAAz%2F9AAND%2FkADS%2F5AA0%2F%2BQANYAMAAhAAX%2FTgAJ%2F8wACv9OAA3%2FTgAP%2F3gAEf94ABL%2FzAAk%2F8wAN%2F9MADn%2FkAA6%2F%2BAAO%2F%2FCADz%2FYAA9%2F9IAP%2F%2BQAGz%2FTgBy%2F04AfP9OAIL%2FzACD%2F8wAhP%2FMAIX%2FzACG%2F8wAh%2F%2FMAIj%2FzACf%2F2AAyv9OAMv%2FTgDM%2F3gAzf9OAM7%2FTgDP%2F3gA1v9OACsABf8cAAr%2FHAAN%2FxwAEP94ACP%2FyAAm%2F8gAKv%2FIADL%2FyAA0%2F8gAN%2F9MADn%2FTAA6%2F4YAPP9oAD%2F%2FTABZ%2F3wAWv%2FCAFz%2FfABs%2FxwAbf94AG%2F%2FeABy%2FxwAef94AHz%2FHAB9%2F3gAif%2FIAJT%2FyACV%2F8gAlv%2FIAJf%2FyACY%2F8gAmv%2FIAJ%2F%2FaADD%2F8gAyP94AMn%2FeADK%2FxwAy%2F8cAM3%2FHADO%2FxwA0P94ANL%2FeADT%2F3gA1v8cAB8AI%2F%2FYACb%2F2AAq%2F9gAMv%2FYADT%2F2ABG%2F%2BAAR%2F%2FgAEj%2F4ABS%2F%2BAAVP%2FgAIn%2F2ACU%2F9gAlf%2FYAJb%2F2ACX%2F9gAmP%2FYAJr%2F2ACp%2F%2BAAqv%2FgAKv%2F4ACs%2F%2BAArf%2FgALL%2F4AC0%2F%2BAAtf%2FgALb%2F4AC3%2F%2BAAuP%2FgALr%2F4ADD%2F9gAxP%2FgAEQACf9KAA%2F%2FHAAQ%2F04AEf8cABL%2FSgAj%2F9IAJP9KACb%2F0gAq%2F9IAMv%2FSADT%2F0gA5ADAAOgAwADwAHgA%2FADAARP%2FAAEb%2FpABH%2F6QASP%2BkAFL%2FpABU%2F6QAbf9OAG%2F%2FTgB5%2F04Aff9OAIL%2FSgCD%2F0oAhP9KAIX%2FSgCG%2F0oAh%2F9KAIj%2FSgCJ%2F9IAlP%2FSAJX%2F0gCW%2F9IAl%2F%2FSAJj%2F0gCa%2F9IAnwAeAKL%2FwACj%2F8AApP%2FAAKX%2FwACm%2F8AAp%2F%2FAAKj%2FwACp%2F6QAqv%2BkAKv%2FpACs%2F6QArf%2BkALL%2FpAC0%2F6QAtf%2BkALb%2FpAC3%2F6QAuP%2BkALr%2FpADD%2F9IAxP%2BkAMj%2FTgDJ%2F04AzP8cAM%2F%2FHADQ%2F04A0v9OANP%2FTgAAAAQALQAAA%2FsFmQAlADUAOQA9AP5AFj08Ozo5ODc2NDIqKCQiHx0TEgYECgcrS7BfUFhAQwABAgABHgADAgECAwEyAAEEAgEEMAAAAAIDAAIBACYABAAFCAQFAQAmAAkJBgAAJAAGBgsfAAgIBwAAJAAHBwwHIAkbS7BsUFhAQQABAgABHgADAgECAwEyAAEEAgEEMAAGAAkABgkAACYAAAACAwACAQAmAAQABQgEBQEAJgAICAcAACQABwcPByAIG0BKAAECAAEeAAMCAQIDATIAAQQCAQQwAAYACQAGCQAAJgAAAAIDAAIBACYABAAFCAQFAQAmAAgHBwgAACMACAgHAAAkAAcIBwAAIQlZWbA4KxM%2BAzMyHgIVFA4EDwEjJyY%2BBDU0JiMiDgIjIicTNDYzMh4CFRQOAiMiJgEhESE3IREh%2Bhk5RE8uP2dJKR4tNjAjBBF6DAQaLTcwIEk5KTgoHAsZDGM%2BMBYoHRERHSgWMD7%2BoQPO%2FDIyA2P8nQR1FiYdESNAWzg3UDsrJiUXaXUiMysoLjooMzwSFhIW%2FPsvQBEeKRcXKB4RPwSk%2Bmc2BSwAAgDa%2F%2FEB0wWZAA0AIQB%2BQA4AAB4cFBIADQANBwYFBytLsF9QWEAbAAAAAQAAJAQBAQELHwACAgMBACQAAwMSAyAEG0uwbFBYQBkEAQEAAAIBAAAAJgACAgMBACQAAwMVAyADG0AiBAEBAAACAQAAACYAAgMDAgEAIwACAgMBACQAAwIDAQAhBFlZsDgrAREUDgIHIy4DNREDND4CMzIeAhUUDgIjIi4CAa4DBgkGeQYJBgMrEyEuGhouIhMTIi4aGi4hEwWZ%2FcQtVldbNDRbV1YtAjz61RouIhQUIi4aGy0iExMiLQACAJgDmQKABZkACgAVAJtAEgsLAAALFQsVEQ8ACgAKBgQGBytLsF9QWEAbFAwJAQQAAQEeAgEAAAEAACQFAwQDAQELACADG0uw6FBYQCcUDAkBBAABAR4FAwQDAQAAAQAAIwUDBAMBAQABACQCAQABAAEAIQQbQC0UDAkBBAIDAR4EAQEDAAEAACMFAQMAAgADAgEAJgQBAQEAAQAkAAABAAEAIQVZWbA4KwERBw4BIyImLwERIREHDgEjIiYvAREBMxADHB8aHQYQAegQAxwfGh0GEAWZ%2Ft6bICMjIJsBIv7emyAjIyCbASIAAAIANgAABFEFmQA%2BAEIBOUAmAABCQUA%2FAD4APjg2NTMwLyooJyYlIyAeGxoZGBIQDw0KCQMBEQcrS7BfUFhALQ4MAgQQDQMDAQAEAQAAJgkBBwcLHw8LAgUFBgAAJAoIAgYGDh8CAQAADAAgBRtLsGxQWEArCQEHBgc0CggCBg8LAgUEBgUAAiYODAIEEA0DAwEABAEAACYCAQAADwAgBBtLsOhQWEA4CQEHBgc0AgEAAQA1CggCBg8LAgUEBgUAAiYODAIEAQEEAAAjDgwCBAQBAAAkEA0DAwEEAQAAIQYbQGAABwkHNAAJBgk0AAIBAAECADIAAAAzAAgADwsIDwACJgAKAAsFCgsBAiYABgAFBAYFAAAmAA4NAQ4AACMADBABDQMMDQAAJgAEAAMBBAMBACYADg4BAAAkAAEOAQAAIQxZWVmwOCsBAyMiJjU0NjcTIwMOASsBEyMiJjU0Nj8BMxMjNz4BOwETPgE7AQMzEzMyFhUUBwMzBw4BKwEDMzIWFRQGDwElMxMjAxZUURcgAQFH90cILR1PVZIXGgEBCMxB6A0FJCeeSAYrHlBU91RPGSEBSdQNBSUmikGzGBoBAQn9nPdB9wGn%2FlkiGwQHBQFa%2Fp0lHwGnFxwFDAY5AUZKHRwBZh4i%2FloBph4YCAX%2BnUsdG%2F66Fx0FCwY5gwFGAAADAGr%2FEgQkBmcAOABDAE4BVUAOODYzMiQiHBoXFggGBgcrS7AJUFhASBgBAQJKKCAdBAMBST4pDQQAAz8MAwMEADQAAgUEBR4AAwEAAQMAMgAABAEABDAAAgIEAQAkAAQEEh8ABQUBAQAkAAEBEQUgBxtLsF9QWEBIGAEBAkooIB0EAwFJPikNBAADPwwDAwQANAACBQQFHgADAQABAwAyAAAEAQAEMAACAgQBACQABAQVHwAFBQEBACQAAQERBSAHG0uwbFBYQEUYAQECSiggHQQDAUk%2BKQ0EAAM%2FDAMDBAA0AAIFBAUeAAMBAAEDADIAAAQBAAQwAAEABQEFAQAlAAICBAEAJAAEBBUEIAYbQE8YAQECSiggHQQDAUk%2BKQ0EAAM%2FDAMDBAA0AAIFBAUeAAMBAAEDADIAAAQBAAQwAAEDBQEBACMAAgAEBQIEAQAmAAEBBQEAJAAFAQUBACEHWVlZsDgrBS4BJzc%2BATMyHgIXEy4DNTQ%2BAj8BPgE7AQceARcHBiMiLgInAx4DFRQOAg8BDgErAQE0LgInAz4DARQeAhcTDgMB8nnHSDUHGg4TMEZhRCVGh2tBOW2gaAoCGhZCDmmYPCsUGg4pOkwxIUiMcEU8c6drDAIbFUIBmCVAVjEiQWVFI%2F3VIjxQLx5BXz0eDAthS1ILDiYxLggCExU1VYFhSYtsRQSQEx7GDVI6Qh4ZISEH%2FhwWNFJ7XFqeeEsGsBMdAoUySDQmEP4OBi1GXQLQMEc2KBABwwYoPEsAAAUASP%2FvBdsFpwATACcAMQBFAFkBXEAWVlRMSkJAODYxLywqJCIaGBAOBgQKBytLsBxQWEAwAAMAAAcDAAEAJgAHAAgJBwgBACYAAgIBAQAkBAEBAREfAAkJBQEAJAYBBQUMBSAGG0uwIlBYQDQAAwAABwMAAQAmAAcACAkHCAEAJgACAgEBACQEAQEBER8ABQUMHwAJCQYBACQABgYSBiAHG0uwX1BYQDgAAwAABwMAAQAmAAcACAkHCAEAJgAEBAsfAAICAQEAJAABAREfAAUFDB8ACQkGAQAkAAYGEgYgCBtLsGxQWEA5AAQBAgEEAjIAAQACAwECAQAmAAMAAAcDAAEAJgAHAAgJBwgBACYABQUPHwAJCQYBACQABgYVBiAHG0BFAAQBAgEEAjIABQkGCQUGMgABAAIDAQIBACYAAwAABwMAAQAmAAcACAkHCAEAJgAJBQYJAQAjAAkJBgEAJAAGCQYBACEIWVlZWbA4KwEUDgIjIi4CNTQ%2BAjMyHgIHNC4CIyIOAhUUHgIzMj4CAT4BOwEBDgErAQEUDgIjIi4CNTQ%2BAjMyHgIHNC4CIyIOAhUUHgIzMj4CAsM0V3Q%2FRHNWMDBWc0RDdVUxixwxQSUlQTAbGzBBJSVBMRwCgA0dGID76QocE4QFNTRXcz9Ec1YwMFZzREN0VjCKHDFBJSVBMBsbMEElJUExHAQ%2FVIVbMDBbhVRWhlwwMFyGVkJcOxoaO1xCQVs5GRk5WwF3ERP6hA0QAVJUhFswMFuEVFaHXDAwXIdWQl06Gho6XUJBWjkZGTlaAAIAUv%2FwBXgFqQA%2FAEsBQEAUAQBGRC8tKCYiIBEPCQcAPwE%2FCAcrS7AeUFhAQwUBAQI4AQMBSUgrJRsFBgMDHgABAgMCAQMyAAICAAEAJAcBAAARHwADAwQBACQFAQQEDB8ABgYEAQAkBQEEBAwEIAgbS7BfUFhAQQUBAQI4AQMBSUgrJRsFBgMDHgABAgMCAQMyAAICAAEAJAcBAAARHwADAwQBACQABAQMHwAGBgUBACQABQUSBSAIG0uwbFBYQD8FAQECOAEDAUlIKyUbBQYDAx4AAQIDAgEDMgcBAAACAQACAQAmAAMDBAEAJAAEBA8fAAYGBQEAJAAFBRUFIAcbQEYFAQECOAEDAUlIKyUbBQYDAx4AAQIDAgEDMgcBAAACAQACAQAmAAYEBQYBACMAAwAEBQMEAQAmAAYGBQEAJAAFBgUBACEHWVlZsDgrATIeAhcHBiMiJicuAyMiDgIVFB4CFwE%2BATc%2BATsBDgEHASMiJi8BDgEjIi4CNTQ%2BAjcuATU0PgIBFB4CMzI2NwEOAQKUT4JfNwRvBQQNFwUHHzFFLjJQOR8RIjYmAZwmLQgCFBJuAkZCASysHSQWkF71k1CaeUovU3JEPTo1ZI%2F%2BzDBOZDRwskT%2BWWprBakzVG88FgEOEho4Lh4gOU0tI0BBRSb%2BXUOTShMWc95h%2FtAOFpFbajZnlF1GfWpUHk2STkmAXzf740FjRCNSRAGrOZ8AAAEAmAOZATMFmQAKAFFACgAAAAoACgYEAwcrS7BfUFhAFgkBAgABAR4AAAABAAAkAgEBAQsAIAMbQCAJAQIAAQEeAgEBAAABAAAjAgEBAQABACQAAAEAAQAhBFmwOCsBEQcOASMiJi8BEQEzEAMcHxodBhAFmf7emyAjIyCbASIAAQCG%2FtsCAQYPABwAB0AEFAoBCysBFBIXHgEVFAYPAS4DNTQ%2BAjcXHgEVFAcGAgEhbmgGBA4LT0tpQR4eQWlLTwsOCmltAnXW%2Fm23CxAIDhIHMHPi5Od6eejj4nQxBxIODxO2%2FmwAAQBK%2FtsBxQYPABwAB0AECRMBCysBNAInJjU0Nj8BHgMVFA4CBycuATU0Njc2EgEqbWkKDgtPS2lBHh5BaUtPCw4EBmhuAnXWAZS2Ew8OEgcxdOLj6Hl65%2BTiczAHEg4IEAu3AZMAAQBgA18CvAXiADAAaEAKAAAAMAAwGBcDBytLsBlQWEAiLSkoJCAfGxMQDwsIBwQOAQABHgIBAQEAAAAkAAAADQEgAxtAKy0pKCQgHxsTEA8LCAcEDgEAAR4AAAEBAAAAIwAAAAEAACQCAQEAAQAAIQRZsDgrATU0NjcGDwEnNzY3LgEvATcXFhcuAT0BMxUUBz4BPwEXBw4BBx4BHwEHJy4BJxYdAQFiBQcUIawsrCQlFCMSrSytIxYJB1gOCxsRrCysESESEiERrSytEhwLEANfxRMiEBkUY0tkFQMCCwxlS2QUIBIlFMbFKR8PFgtjS2QLDAICCwtlS2QLFhAhJ8YAAQBkAK4EIgSOAAsAdUASAAAACwALCgkIBwYFBAMCAQcHK0uw6FBYQCUGAQUAAgUAACMEAQADAQECAAEAACYGAQUFAgAAJAACBQIAACEEG0AtBgEFAAIFAAAjAAQAAwEEAwAAJgAAAAECAAEAACYGAQUFAgAAJAACBQIAACEFWbA4KwERIRUhESMRITUhEQKLAZf%2BaZL%2BawGVBI7%2BVYf%2BUgGuhwGrAAEAXv7xAVAA7AAeAF9ABhsZBgQCBytLsF9QWEASDwEBGwAAAAEBACQAAQEMASADG0uwbFBYQBIPAQEbAAAAAQEAJAABAQ8BIAMbQBsPAQEbAAABAQABACMAAAABAQAkAAEAAQEAIQRZWbA4Kzc0PgIzMh4CFRQOAgcnJjU0Nz4DNyMiLgJeER8sGh4vHxAaMEctHg0OCh8gGwYNGiofEXsXKR8SFiczHi1hX1omHQwQDQ4LJTA6IRIhLQAAAQBkAgwCUgKjAAMAJUAGAwIBAAIHK0AXAAABAQAAACMAAAABAAAkAAEAAQAAIQOwOCsTIRUhZAHu%2FhICo5cAAAEAWP%2FxAVEA7AATAFNABhAOBgQCBytLsF9QWEAOAAAAAQEAJAABARIBIAIbS7BsUFhADgAAAAEBACQAAQEVASACG0AXAAABAQABACMAAAABAQAkAAEAAQEAIQNZWbA4Kzc0PgIzMh4CFRQOAiMiLgJYEyEuGhouIhMTIi4aGi4hE24aLiIUFCIuGhstIhMTIi0AAf%2F0%2F6YC9gXBAAkALUAGCQcEAgIHK0uwjVBYQAwAAAEANQABAQ0BIAIbQAoAAQABNAAAACsCWbA4KxcOASsBAT4BOwGhDjcdSwJZDTAhSxUjIgXZICIAAAIAPP%2FxBEwFqQATACcAd0AKJCIaGBAOBgQEBytLsF9QWEAaAAICAQEAJAABAREfAAMDAAEAJAAAABIAIAQbS7BsUFhAGAABAAIDAQIBACYAAwMAAQAkAAAAFQAgAxtAIQABAAIDAQIBACYAAwAAAwEAIwADAwABACQAAAMAAQAhBFlZsDgrARQCDgEjIi4BAjU0Ej4BMzIeARIHNC4CIyIOAhUUHgIzMj4CBExRjL9tbr2MUFCMvW5tv4xRuTddekJCelw3N1x6QkJ6XTcCzLz%2B7bRYWLQBE7y8ARS1WFi1%2Fuy8pN%2BIOzuI36Sk3og7O4jeAAABAMoAAAQfBZwAEgDLQAwSERAPDg0JBwEABQcrS7BfUFhAIwwEAgECAR4AAQIAAgEAMgACAgsfAwEAAAQAAiQABAQMBCAFG0uwbFBYQCAMBAIBAgEeAAIBAjQAAQABNAMBAAAEAAIkAAQEDwQgBRtLsOhQWEAqDAQCAQIBHgACAQI0AAEAATQDAQAEBAAAACMDAQAABAACJAAEAAQAAiEGG0AvDAQCAQIBHgACAQI0AAEAATQAAwAEAAMqAAADBAAAACMAAAAEAAIkAAQABAACIQdZWVmwOCslIRE0NwUOASMiJi8BATMRIRUhAR8BNAP%2FAAoUCQ8YBjgBqpEBGv0AiAPRLC3bCAcNCU0BcfrsiAAAAQBoAAAEJAWpADMAtkAQAQAsKiQiFBMQDQAzATMGBytLsF9QWEAtLwEEAwsBAgECHgAEAwEDBAEyAAMDAAEAJAUBAAARHwABAQIAACQAAgIMAiAGG0uwbFBYQCsvAQQDCwECAQIeAAQDAQMEATIFAQAAAwQAAwEAJgABAQIAACQAAgIPAiAFG0A0LwEEAwsBAgECHgAEAwEDBAEyBQEAAAMEAAMBACYAAQICAQEAIwABAQIAACQAAgECAAAhBllZsDgrATIeAhUUDgIHAT4BMyEyFh0BITU0NjcBPgM1NC4CIyIOAgcOASMiJi8BPgMCWVuec0IwUms8%2FocoUiYB4B0i%2FEQPEQHLOV5DJChGXjY2XEcxCgggGgULB10OUHufBak2Z5ReUIh9dT3%2BfgsNIhtsPRMoEQHNOmtsbz8%2FXz4fIDlOLx0aAQEQYpdmNQAAAQBs%2F%2FAELgWpAEoA%2FkAWAQBDQTs5MTAvLiYkGxkTEQBKAUoJBytLsF9QWEBDRgEHBgoBBAUXAQMCAx4ABwYFBgcFMgACBAMEAgMyAAUABAIFBAEAJgAGBgABACQIAQAAER8AAwMBAQAkAAEBEgEgCBtLsGxQWEBBRgEHBgoBBAUXAQMCAx4ABwYFBgcFMgACBAMEAgMyCAEAAAYHAAYBACYABQAEAgUEAQAmAAMDAQEAJAABARUBIAcbQEpGAQcGCgEEBRcBAwIDHgAHBgUGBwUyAAIEAwQCAzIIAQAABgcABgEAJgAFAAQCBQQBACYAAwEBAwEAIwADAwEBACQAAQMBAQAhCFlZsDgrATIeAhUUDgIHHgEVFA4CIyIuAic3NjMyFhceARceAzMyPgI1NC4CIzU%2BAzU0LgIjIg4CBw4BIyImLwE%2BAwJsW5pvPiNBXDmMjUuCrWNyonBIGUwVFRQfCAIEAg4oRGVLS3FLJh9Rj3BbgVIlJ0RdNjZcRzAMCCAZBQsHXQ5Qe58FqTRgiFNEa1E4ESWug2Oebzs5ZIlQIAkREgQJBR1JQCwxTmAvOmBGKIEBJkJcOD5cPB4gOU8uHRoBARBil2Y1AAIAKAAABGAFmQAQABYAyUAOFhUQDwsJCAcGBAEABgcrS7BfUFhAHhQBAAQBHgUBAAMBAQIAAQEAJgAEBAsfAAICDAIgBBtLsGxQWEAgFAEABAEeBQEAAwEBAgABAQAmAAQEAgAAJAACAg8CIAQbS7DoUFhAKRQBAAQBHgAEAAIEAAAjBQEAAwEBAgABAQAmAAQEAgAAJAACBAIAACEFG0AxFAEABAEeAAQAAgQAACMABQADAQUDAQAmAAAAAQIAAQEAJgAEBAIAACQAAgQCAAAhBllZWbA4KwEzFRQGKwERIxEhIiYvAQEzAzQ2NwEhA4fZExSynf2FFB0EEgK5pp0DBf33AgECBWYQFv6HAXkXEVsDnf67Gjwg%2FTsAAQBs%2F%2FAD%2FgWZAC4A4EAQLi0pJx8dGhgSEAgGBAIHBytLsF9QWEA7BQEFASwrAgMFFgECBAMeAAMFBAUDBDIAAQAFAwEFAQAmAAAABgAAJAAGBgsfAAQEAgEAJAACAhICIAcbS7BsUFhAOQUBBQEsKwIDBRYBAgQDHgADBQQFAwQyAAYAAAEGAAEAJgABAAUDAQUBACYABAQCAQAkAAICFQIgBhtAQgUBBQEsKwIDBRYBAgQDHgADBQQFAwQyAAYAAAEGAAEAJgABAAUDAQUBACYABAICBAEAIwAEBAIBACQAAgQCAQAhB1lZsDgrARQGIyEDNjMyHgIVFA4CIyIuAic3NjMyHgIzMj4CNTQuAiMiBgcnEyED0jA5%2Fj5CcF9wq3Q7UIu8bT90ZFYhNhIeEzNIYUNLeFUuJ092TzZ0PnB0AqcFSyYx%2FogYQnSeXXK4g0YZKjYeTBofJh8wWXxNQ2xMKhIUIQKeAAACAGz%2F8AQyBZkAGgAuAJ9AEAEAKykhHxcVCwkAGgEaBgcrS7BfUFhAJBgBBAABHgUBAAAEAwAEAQAmAAICCx8AAwMBAQAkAAEBEgEgBRtLsGxQWEAkGAEEAAEeAAIAAjQFAQAABAMABAEAJgADAwEBACQAAQEVASAFG0AtGAEEAAEeAAIAAjQFAQAABAMABAEAJgADAQEDAQAjAAMDAQEAJAABAwEBACEGWVmwOCsBMh4CFRQOAiMiLgI1NDY3AT4BOwEBPgEBFB4CMzI%2BAjU0LgIjIg4CAopWmnRESIG2bWyvfENUWwFrDjIgnv4PM3z%2B1ihNb0dIdFMtLFBwQ0h0USsDbjltn2Zjqn5IRX%2B1cF7UegHpEhn9iyMn%2FkxFclItLlJwQkZxTyoxU20AAAEAbgAABDwFmQASAGpADAAAABIAEg8NCQcEBytLsF9QWEAUAAEBAgAAJAMBAgILHwAAAAwAIAMbS7BsUFhAEgMBAgABAAIBAQAmAAAADwAgAhtAHgAAAQA1AwECAQECAAAjAwECAgEBACQAAQIBAQAhBFlZsDgrARUUBgcBDgErAQE%2BATchIiY9AQQ8Dwj9rw0uJ38CWg0bEf0UERsFmVAiLA%2F7UxolBJ4ZKhMbEXkAAwBg%2F%2FAEJgWpAB8AMwBHAMRAGjU0ISABAD89NEc1RyspIDMhMxEPAB8BHwkHK0uwX1BYQC4YCAIDBAEeCAEEAAMCBAMBACYABQUBAQAkAAEBER8HAQICAAEAJAYBAAASACAGG0uwbFBYQCwYCAIDBAEeAAEABQQBBQEAJggBBAADAgQDAQAmBwECAgABACQGAQAAFQAgBRtANhgIAgMEAR4AAQAFBAEFAQAmCAEEAAMCBAMBACYHAQIAAAIBACMHAQICAAEAJAYBAAIAAQAhBllZsDgrBSIuAjU0NjcuATU0PgIzMh4CFRQGBx4BFRQOAicyPgI1NC4CIyIOAhUUHgITMj4CNTQuAiMiDgIVFB4CAkNrsoBGkIZxcz5yn2JhoHI%2BdHCGkEd%2FsmtGb00pMVNsOztsUzEpTW9GRmM%2BHCFBYUBAYUEhHD5jEDlql16KsyYqp3RPimY6OmaKT3SnKiazil6XajmOJ0djPEppQh8fQmlKPGNHJwKwK0dcMTJYQiYmQlgyMVxHKwAAAgCUAAAENgWpAB8AMwCdQBABADAuJiQZFwsJAB8BHwYHK0uwX1BYQCQdAQAEAR4ABAUBAAIEAAEAJgADAwEBACQAAQERHwACAgwCIAUbS7BsUFhAIh0BAAQBHgABAAMEAQMBACYABAUBAAIEAAEAJgACAg8CIAQbQC0dAQAEAR4AAgACNQABAAMEAQMBACYABAAABAEAIwAEBAABACQFAQAEAAEAIQZZWbA4KwEiLgI1ND4CMzIeAhUUDgIHAQ4BKwEBPgE3DgEBNC4CIyIOAhUUHgIzMj4CAiVRkW5BRn6uaGeoeEEXLD0n%2FqMNMB%2BkAbQWJhE3igEZK0xpP0JtTSonSWlBSG9MKAJMNmmZY16kekZEeqpnPm9qaTj%2BCBMXAjsdNBosLgGjQ21MKStMaj9Ea0omL05mAAACAID%2F8QF5A9oAEwAnAJhACiQiGhgQDgYEBAcrS7AkUFhAGgADAwIBACQAAgIOHwAAAAEBACQAAQESASAEG0uwX1BYQBgAAgADAAIDAQAmAAAAAQEAJAABARIBIAMbS7BsUFhAGAACAAMAAgMBACYAAAABAQAkAAEBFQEgAxtAIQACAAMAAgMBACYAAAEBAAEAIwAAAAEBACQAAQABAQAhBFlZWbA4Kzc0PgIzMh4CFRQOAiMiLgIRND4CMzIeAhUUDgIjIi4CgBMhLhoaLiITEyIuGhouIRMTIS4aGi4iExMiLhoaLiETbhouIhQUIi4aGy0iExMiLQMJGi4iFBQiLhobLSITEyItAAIAgP7xAXkD2gAeADIAqEAKLy0lIxsZBgQEBytLsCRQWEAeDwEBGwADAwIBACQAAgIOHwAAAAEBACQAAQEMASAFG0uwX1BYQBwPAQEbAAIAAwACAwEAJgAAAAEBACQAAQEMASAEG0uwbFBYQBwPAQEbAAIAAwACAwEAJgAAAAEBACQAAQEPASAEG0AlDwEBGwACAAMAAgMBACYAAAEBAAEAIwAAAAEBACQAAQABAQAhBVlZWbA4Kzc0PgIzMh4CFRQOAgcnJjU0Nz4DNyMiLgIDND4CMzIeAhUUDgIjIi4ChhEfLBoeLx8QGjBHLR4NDgofIBsGDRoqHxEGEyEuGhouIhMTIi4aGi4hE3sXKR8SFiczHi1hX1omHQwQDQ4LJTA6IRIhLQL8Gi4iFBQiLhobLSITEyItAAEAlADqA5oEVwASAAdABAERAQsrEwEVFAYHBQ4BBx4BFwUeAR0BAZQDBhAU%2Fj8ULRkZLRQBwRQQ%2FPoCxgGRfxEZCuQLDwYFEArjChoQgAGSAAACAJYBtwPxA40AAwAHADNACgcGBQQDAgEABAcrQCEAAgADAAIDAAAmAAABAQAAACMAAAABAAAkAAEAAQAAIQSwOCsTIRUhESEVIZYDW%2FylA1v8pQI%2BhwHWhwABAO4A6gPzBFcAEgAHQAQQAAELKzc1NDY3JT4BNy4BJyUuAT0BARXuEBQBwRQrGRkrFP4%2FFBADBeqAEBoK4woQBQYPC%2BQKGRF%2F%2Fm9KAAACACL%2F8QL4BakAKAA8AMZADjk3Ly0nJSIgExIGBAYHK0uwX1BYQDMAAQIAFAEBAwIeAAMCAQIDATIAAQQCAQQwAAICAAEAJAAAABEfAAQEBQEAJAAFBRIFIAcbS7BsUFhAMQABAgAUAQEDAh4AAwIBAgMBMgABBAIBBDAAAAACAwACAQAmAAQEBQEAJAAFBRUFIAYbQDoAAQIAFAEBAwIeAAMCAQIDATIAAQQCAQQwAAAAAgMAAgEAJgAEBQUEAQAjAAQEBQEAJAAFBAUBACEHWVmwOCsTPgMzMh4CFRQOBA8BIyc1ND4ENTQuAiMiDgIjIicTND4CMzIeAhUUDgIjIi4CIh9LWWc8T4diOC1FUkczBBJ6DC1FT0UtIjpPLT1XPCUMGQ6VEyEuGhouIhMTIi4aGi4hEwUZHTQoFy5UeEtMblM9NjYhmaYLKkE5OUVYPCtGMRoeJB4X%2B6AaLiIUFCIuGhstIhMTIi0AAgBW%2FxEGHAVPAFEAYQE5QCBTUgEAW1lSYVNhR0U7OTUzMC4mJBwaEQ8HBQBRAVENBytLsENQWEBQEwEKAlgDAgMKNwEFBgMeAAYABQAGBTIACAAEAggEAQAmAAIACgMCCgEAJgwJAgMBCwIABgMAAQAmAAUHBwUBACMABQUHAQAkAAcFBwEAIQgbS7DHUFhAVxMBCgJYAwIJCjcBBQYDHgAGAAUABgUyAAgABAIIBAEAJgACAAoJAgoBACYMAQkDAAkBACMAAwELAgAGAwABACYABQcHBQEAIwAFBQcBACQABwUHAQAhCRtAWBMBCgJYAwIJCjcBBQYDHgAGAAUABgUyAAgABAIIBAEAJgACAAoJAgoBACYMAQkAAQAJAQEAJgADCwEABgMAAQAmAAUHBwUBACMABQUHAQAkAAcFBwEAIQlZWbA4KyUiJicOASMiLgI1ND4CMzIWFwMGFRQeAjMyPgI1NC4CIyIOAhUUEh4BMzI2NzYzMh8BBgQjIiQmAjU0PgQzMh4EFRQOAiUyPgI3EyYjIg4CFRQWBI9OYg06iE48WDsdQYC%2FfUNlLV0TEh8pFzFYQydZm9N6huquZGu5%2BY%2BY6VUPDBUKGWv%2B762t%2FtbbfTdkjKzGbFywnYRfNT1rkf4CHz87MRFMJy5LfVozQrpLTlFGKUlkOlWti1gVFP6XSzEkLxsKOGaPV4rQi0VmtPaRqv7%2FrlhCMwkYQkhSbs8BLL5tyq%2BRZzkoTnOVt2tst4ZMeBQyVkEBJwk%2FZoRFSFcAAgAKAAAFSQWZAA0AFQC%2FQAwPDg0MCwkGBQIABQcrS7BfUFhAHRIBBAMBHgAEAAEABAEAAiYAAwMLHwIBAAAMACAEG0uwbFBYQB0SAQQDAR4AAwQDNAAEAAEABAEAAiYCAQAADwAgBBtLsOhQWEAoEgEEAwEeAAMEAzQCAQABADUABAEBBAAAIwAEBAEAAiQAAQQBAAIhBhtALhIBBAMBHgADBAM0AAIBAAECADIAAAAzAAQBAQQAACMABAQBAAIkAAEEAQACIQdZWVmwOCshIyImJwMhAw4BKwEBMwEhAyYnDgEHBUmWGiAIhv19hgciGZYCPcX%2BkgIX4RYVCxUKGhQBWv6mEhwFmfx7Akc2USlFGgAAAwCuAAAEoAWZABQAHwAqALlAFhUVAAAqKCIgFR8VHhgWABQAEwMBCAcrS7BfUFhALAwBAwQBHgAEBwEDAgQDAQAmAAUFAAEAJAAAAAsfAAICAQEAJAYBAQEMASAGG0uwbFBYQCoMAQMEAR4AAAAFBAAFAQAmAAQHAQMCBAMBACYAAgIBAQAkBgEBAQ8BIAUbQDMMAQMEAR4AAAAFBAAFAQAmAAQHAQMCBAMBACYAAgEBAgEAIwACAgEBACQGAQECAQEAIQZZWbA4KzMRITIeAhUUDgIHHgEVFA4CIwERITI%2BAjU0JiMlITI%2BAjU0JiMhrgHJhL97OyFDZUSdoEOBu3j%2BxwE2U3dNJJ2f%2FssBAFJ4TyaYoP75BZk0YItXNWJUQhUfpIZblmw7Ao3%2BDSZFXzlvgYokQFs2fnYAAAEAWv%2FwBQkFqQAuAM1AEgEAKScfHRgWEQ8HBQAuAS4HBytLsF9QWEA0EwEDBAMBBQACHgADBAAEAwAyBgEABQQABTAABAQCAQAkAAICER8ABQUBAQAkAAEBEgEgBxtLsGxQWEAyEwEDBAMBBQACHgADBAAEAwAyBgEABQQABTAAAgAEAwIEAQAmAAUFAQEAJAABARUBIAYbQDsTAQMEAwEFAAIeAAMEAAQDADIGAQAFBAAFMAACAAQDAgQBACYABQEBBQEAIwAFBQEBACQAAQUBAQAhB1lZsDgrATIfAQ4BIyIuAQI1NBI2JDMyFhcHDgEjIi4EIyIOAhUUHgIzMj4CNzYEoBANTFj7sZv8smJpvgEJoJ7lWT8HEhENHSg2SmJAc7%2BKTU2FtmlAZldLJhEBKA1TZnJrwQEOoqIBDsJrYlRZCg0THCAcE0%2BS0oKG0pFMDyAxIg8AAgCuAAAFiAWZAAwAGQB3QAoWFBMRCQcGBAQHK0uwX1BYQBoAAgIBAQAkAAEBCx8AAwMAAQAkAAAADAAgBBtLsGxQWEAYAAEAAgMBAgEAJgADAwABACQAAAAPACADG0AhAAEAAgMBAgEAJgADAAADAQAjAAMDAAEAJAAAAwABACEEWVmwOCsBFAIGBCMhESEyBBYSBzQuAiMhESEyPgIFiGa6%2Fvye%2FegCGJ4BBLpmx0iEvHP%2BqwFVc7yESALMof74vGcFmWe9%2FvihhNCQTPuhTI%2FQAAABAK4AAAQhBZkACwCgQBIAAAALAAsKCQgHBgUEAwIBBwcrS7BfUFhAJQABAAIDAQIAACYAAAAFAAAkBgEFBQsfAAMDBAAAJAAEBAwEIAUbS7BsUFhAIwYBBQAAAQUAAAAmAAEAAgMBAgAAJgADAwQAACQABAQPBCAEG0AsBgEFAAABBQAAACYAAQACAwECAAAmAAMEBAMAACMAAwMEAAAkAAQDBAAAIQVZWbA4KwEVIREhFSERIRUhEQQh%2FVACLf3TArD8jQWZnv4kmP4XngWZAAABAK4AAAQhBZkACQCLQBAAAAAJAAkIBwYFBAMCAQYHK0uwX1BYQB4AAQACAwECAAAmAAAABAAAJAUBBAQLHwADAwwDIAQbS7BsUFhAHAUBBAAAAQQAAAAmAAEAAgMBAgAAJgADAw8DIAMbQCcAAwIDNQUBBAAAAQQAAAAmAAECAgEAACMAAQECAAAkAAIBAgAAIQVZWbA4KwEVIREhFSERIxEEIf1QAkz9tMMFmZ7%2BC579mAWZAAEAWv%2FwBUAFqQA0AOVAFAEALColIx0bExEMCwgGADQBNAgHK0uwX1BYQDshAQUGBQEAAQ0BAwADHgAFBgIGBQIyAAIAAQACAQEAJgAGBgQBACQABAQRHwcBAAADAQAkAAMDEgMgBxtLsGxQWEA5IQEFBgUBAAENAQMAAx4ABQYCBgUCMgAEAAYFBAYBACYAAgABAAIBAQAmBwEAAAMBACQAAwMVAyAGG0BDIQEFBgUBAAENAQMAAx4ABQYCBgUCMgAEAAYFBAYBACYAAgABAAIBAQAmBwEAAwMAAQAjBwEAAAMBACQAAwADAQAhB1lZsDgrJTI%2BAjcRIyImPQEhEQ4DIyIkJgI1NBI2JDMyHgIXBwYjIicuAyMiDgIVFB4CAy06YVZMJt4TFwG4NnWFmFmc%2Fvy8aWe%2FAQ%2BoVZJ9ai43ERsQExk%2BWXlTecSKSk2MwI0LFh8UATwWEG792ic6JxNrwQEOoqQBDsFqGS9DKlgbCw4oJRpPk9GCiNWUTgABAK4AAAU4BZkACwCyQA4LCgkIBwYFBAMCAQAGBytLsF9QWEAYAAQAAQAEAQAAJgUBAwMLHwIBAAAMACADG0uwbFBYQBoABAABAAQBAAAmBQEDAwAAACQCAQAADwAgAxtLsOhQWEAkBQEDBAADAAAjAAQAAQAEAQAAJgUBAwMAAAAkAgEAAwAAACEEG0ArAAUEAAUAACMABAABAgQBAAAmAAMAAgADAgAAJgAFBQAAACQAAAUAAAAhBVlZWbA4KyEjESERIxEzESERMwU4w%2Fz8w8MDBMMCjP10BZn9gQJ%2FAAEA0gAAAZQFmQADAFFABgMCAQACBytLsF9QWEAMAAEBCx8AAAAMACACG0uwbFBYQA4AAQEAAAAkAAAADwAgAhtAFwABAAABAAAjAAEBAAAAJAAAAQAAACEDWVmwOCshIxEzAZTCwgWZAAABADz%2F8ALJBZkAFwCtQAoXFhEPDgwGBAQHK0uwGlBYQBoHAQABAR4AAwMLHwIBAQEAAQAkAAAAEgAgBBtLsF9QWEAhBwEAAgEeAAEDAgMBAjIAAwMLHwACAgABACQAAAASACAFG0uwbFBYQB4HAQACAR4AAwEDNAABAgE0AAICAAEAJAAAABUAIAUbQCcHAQACAR4AAwEDNAABAgE0AAIAAAIBACMAAgIAAQAkAAACAAEAIQZZWVmwOCsBFA4CIyInPgE3PgEzMhYzMj4CNREzAsk7c6htYWkCBgMCFRUSPDJCZ0clwQHveL6DRhwdORwRFRIoVINaA64AAQDCAAAFOgWZACIAykAOIiEgHx4cExEJBwIABgcrS7BfUFhAHg0BAwABHgAAAAMCAAMBACYFAQEBCx8EAQICDAIgBBtLsGxQWEAgDQEDAAEeAAAAAwIAAwEAJgUBAQECAQAkBAECAg8CIAQbS7DoUFhAKg0BAwABHgUBAQACAQEAIwAAAAMCAAMBACYFAQEBAgEAJAQBAgECAQAhBRtAMQ0BAwABHgABBQIBAQAjAAAAAwQAAwEAJgAFAAQCBQQAACYAAQECAQAkAAIBAgEAIQZZWVmwOCsBMzI2NwE%2BATsBAQ4BBx4BFwEjIi4CJwEuAysBESMRMwGDSSYtFAHdFikgpf3eFSUVHCoXAjqoExoTEAj%2BEQsTGSEYWMHBAyUTFwIcGRX9lxcgCgkkG%2F1ZBgoQCQI5DBEMBf1wBZkAAQCuAAAD3AWZAAUAZEAIBQQDAgEAAwcrS7BfUFhAEwACAgsfAAAAAQACJAABAQwBIAMbS7BsUFhAEwACAAI0AAAAAQACJAABAQ8BIAMbQBwAAgACNAAAAQEAAAAjAAAAAQACJAABAAEAAiEEWVmwOCslIRUhETMBcAJs%2FNLCo6MFmQAAAQCuAAAGgQWZACMAwEAMIB4dHBYTDQwLCQUHK0uwX1BYQBwDAQIAAR4AAgABAAIBMgQBAAALHwMBAQEMASAEG0uwbFBYQB4DAQIAAR4AAgABAAIBMgQBAAABAAAkAwEBAQ8BIAQbS7DoUFhAKAMBAgABHgACAAEAAgEyBAEAAgEAAQAjBAEAAAEAACQDAQEAAQAAIQUbQC8DAQIEAR4AAgQDBAIDMgAABAEAAQAjAAQAAwEEAwAAJgAAAAEAACQAAQABAAAhBllZWbA4KwEeARc%2BATcBPgE7AREjETQ2NwEGKwEiJwEeARURIxEzMhYXAQNvDhUKChYOAeUNHBqPqgIC%2FhUZLRwtGf4KAwOqjxocDQHvAgYYNRscMxoDcRcK%2BmcEHRUwGfyALS0DgxoyFfvjBZkKF%2FyOAAABAK4AAAU4BZkAFgCSQAwWFRQTDAoJCAEABQcrS7BfUFhADwQBAgAACx8DAQICDAIgAhtLsGxQWEARBAECAAACAQAkAwECAg8CIAIbS7DoUFhAHAQBAgACAgAAACMEAQIAAAIBACQDAQIAAgEAIQMbQCcAAAEEACgAAQQCAQAAIwAEAAMCBAMAAiYAAQECAQAkAAIBAgEAIQVZWVmwOCsBMhYXAS4BNREzESMiJicBHgEVESMRMwESGhkQAz4DAqpiFx8P%2FMMCAqpkBZkNFPvIGjEXA%2Ff6ZxATBDcZMBT8AwWZAAACAFz%2F8QXhBakAEwAnAHdACiQiGhgQDgYEBAcrS7BfUFhAGgACAgEBACQAAQERHwADAwABACQAAAASACAEG0uwbFBYQBgAAQACAwECAQAmAAMDAAEAJAAAABUAIAMbQCEAAQACAwECAQAmAAMAAAMBACMAAwMAAQAkAAADAAEAIQRZWbA4KwEUAgYEIyIkJgI1NBI2JDMyBBYSBzQuAiMiDgIVFB4CMzI%2BAgXhZrr%2B%2B56e%2Fvy6Zma6AQSengEFumbHSIS8dHO8hUhIhbxzdLyESALMof7zwmtrwgENoaEBDcNsbMP%2B86GE0pFOTpHShITRkU1NkdEAAAIAwgAABH8FmQAOABkAi0AQAAAZFxEPAA4ADQUDAgEGBytLsF9QWEAeAAMFAQIAAwIBACYABAQBAQAkAAEBCx8AAAAMACAEG0uwbFBYQBwAAQAEAwEEAQAmAAMFAQIAAwIBACYAAAAPACADG0AnAAACADUAAQAEAwEEAQAmAAMCAgMBACMAAwMCAQAkBQECAwIBACEFWVmwOCsBESMRITIeAhUUDgIjJzMyPgI1NCYrAQGDwQGniMmEQUaHyIHm5lN%2FViypq%2BYCGP3oBZk%2FdKRlZKZ4Q5osT25CiZoAAAIAXP7YBiQFqQAcADAA%2B0AMLSsjIRkXDw0IBgUHK0uwCVBYQCYLBQIBBAEeAAABADUAAwMCAQAkAAICER8ABAQBAQAkAAEBEgEgBhtLsBVQWEAmCwUCAQQBHgADAwIBACQAAgIRHwAEBAEBACQAAQESHwAAABAAIAYbS7BfUFhAJgsFAgEEAR4AAAEANQADAwIBACQAAgIRHwAEBAEBACQAAQESASAGG0uwbFBYQCQLBQIBBAEeAAABADUAAgADBAIDAQAmAAQEAQEAJAABARUBIAUbQC0LBQIBBAEeAAABADUAAgADBAIDAQAmAAQBAQQBACMABAQBAQAkAAEEAQEAIQZZWVlZsDgrARQOAgcBIyImJwMOASMiJCYCNTQSNiQzMgQWEgc0LgIjIg4CFRQeAjMyPgIF4SlOcEYBcKAkOBf8OXtDnv78umZmugEEnp4BBbpmx0iEvHRzvIVISIW8c3S8hEgCzGW2nYAv%2FnMUGQESEhRrwgENoaEBDcNsbMP%2B86GE0pFOTpHShITRkU1NkdEAAgDCAAAE5QWZABgAIwDfQBIAACMhGxkAGAAXExEFAwIBBwcrS7BfUFhAJQ4BAwQBHgAEBgEDAAQDAQAmAAUFAQEAJAABAQsfAgEAAAwAIAUbS7BsUFhAIw4BAwQBHgABAAUEAQUBACYABAYBAwAEAwEAJgIBAAAPACAEG0uw6FBYQC4OAQMEAR4CAQADADUAAQAFBAEFAQAmAAQDAwQBACMABAQDAQAkBgEDBAMBACEGG0A0DgEDBAEeAAIDAAMCADIAAAAzAAEABQQBBQEAJgAEAwMEAQAjAAQEAwEAJAYBAwQDAQAhB1lZWbA4KwERIxEhMh4CFRQOAgcWFwEjIicBLgEjJzMyPgI1NCYrAQGDwQGViMaBPjBbg1MkHAGirDUZ%2FowRKCiTy1WBVyypp9QCVv2qBZk3aJNbTIRpShMVKP3HKQIAGBWNKUtoP4CCAAABADr%2F8APbBakAPQDGQA47OSgmIyEcGgkHBAIGBytLsF9QWEAzPQEBBR4BBAMCHgAAAQMBAAMyAAMEAQMEMAABAQUBACQABQURHwAEBAIBACQAAgISAiAHG0uwbFBYQDE9AQEFHgEEAwIeAAABAwEAAzIAAwQBAwQwAAUAAQAFAQEAJgAEBAIBACQAAgIVAiAGG0A6PQEBBR4BBAMCHgAAAQMBAAMyAAMEAQMEMAAFAAEABQEBACYABAICBAEAIwAEBAIBACQAAgQCAQAhB1lZsDgrAQ4BIyIuAiMiDgIVFB4GFRQOAiMiJic3PgEzMh4CMzI%2BAjU0LgY1ND4CMzIWFwOMCRQQES1FYUVBZEMiO2F7gXthO0B7s3KL5VE4CBcOFTZRc1NFbEsoO2B7gXtgOztwpWt4xkoEuQ8PIikiIzxRLzxPOCksN1R6WV6lekZlVlwLDy02LSZFYDtBUzgnKTZWgV9Mjm5CTEgAAQAcAAAEfgWZAAcAnUAOAAAABwAHBgUEAwIBBQcrS7BfUFhAFQIBAAADAAAkBAEDAwsfAAEBDAEgAxtLsGxQWEATBAEDAgEAAQMAAAAmAAEBDwEgAhtLsOhQWEAfAAEAATUEAQMAAAMAACMEAQMDAAAAJAIBAAMAAAAhBBtAJQACAwAAAioAAQABNQQBAwIAAwACIwQBAwMAAAAkAAADAAAAIQVZWVmwOCsBFSERIxEhNQR%2B%2FjHC%2Fi8FmaP7CgT2owABAKD%2F7wUVBZkAGQCdQA4BABQTDgwHBgAZARkFBytLsF9QWEAVAwEBAQsfBAEAAAIBACQAAgISAiADG0uwbFBYQBUDAQEAATQEAQAAAgEAJAACAhUCIAMbS7DoUFhAHwMBAQABNAQBAAICAAEAIwQBAAACAQAkAAIAAgEAIQQbQCMAAQMBNAADAAM0BAEAAgIAAQAjBAEAAAIBACQAAgACAQAhBVlZWbA4KyUyPgI1ETMRFA4CIyIuAjURMxEUHgIC21mMYTPBT5PUhITUlE%2FBM2GNmjxslloDZ%2FyZfNSbWFib1HwDZ%2FyaWpZsPQAAAQAIAAAFRwWZABIAd0AIEhEQDgIAAwcrS7BfUFhAEwgBAgABHgEBAAALHwACAgwCIAMbS7BsUFhAEwgBAgABHgEBAAIANAACAg8CIAMbS7DoUFhAEQgBAgABHgEBAAIANAACAisDG0AVCAECAQEeAAABADQAAQIBNAACAisEWVlZsDgrEzMyFhcBHgEXPgE3AT4BOwEBIwibGiAIAZUOFwsJFQ4BkwciGZz9uK8FmRoU%2FA0iUCsrUCID8xEd%2BmcAAQAOAAAH5wWZACgAk0AMKCcgHx4cEQ4CAAUHK0uwX1BYQBcjFggDAwABHgIBAgAACx8EAQMDDAMgAxtLsGxQWEAXIxYIAwMAAR4CAQIAAwA0BAEDAw8DIAMbS7DoUFhAFSMWCAMDAAEeAgECAAMANAQBAwMrAxtAISMWCAMEAgEeAAABADQAAQIBNAACBAI0AAQDBDQAAwMrBllZWbA4KxMzMhYXAR4BFz4BNwE%2BATsBMhYXARYXPgE3AT4BOwEBIwEmJw4BBwEjDqEaIgYBKAgNBgcOCQFRBiMZOBohBwFPEg4GCggBKQUjGZf%2BQa7%2BlQsJBQkF%2FpOuBZkaFPwcGz4iIj8aA%2BQRHRoU%2FBw0QyE8GgPkEhz6ZwRFHykUJQ%2F7uwABAA4AAAT2BZkAGwCiQAobGREPDQsDAQQHK0uwX1BYQBUOAAICAAEeAQEAAAsfAwECAgwCIAMbS7BsUFhAFw4AAgIAAR4BAQAAAgEAJAMBAgIPAiADG0uw6FBYQCEOAAICAAEeAQEAAgIAAQAjAQEAAAIBACQDAQIAAgEAIQQbQCgOAAIDAQEeAAEDAgEBACMAAAADAgADAQAmAAEBAgEAJAACAQIBACEFWVlZsDgrCQEzMhYXATY3AT4BOwEJASMiJicBBgcBDgErAQH7%2FifBFRQIAXYHDgFhCRUPuf4lAevAFhkI%2FoAHC%2F6KCRcVtALgArkODf3CFRkCDA4R%2FVD9FxcOAlkVE%2F3PDhcAAQAIAAAE5AWZABQAf0AIFBIGBAIBAwcrS7BfUFhAFQwDAAMAAQEeAgEBAQsfAAAADAAgAxtLsGxQWEAVDAMAAwABAR4CAQEAATQAAAAPACADG0uw6FBYQBMMAwADAAEBHgIBAQABNAAAACsDG0AXDAMAAwACAR4AAQIBNAACAAI0AAAAKwRZWVmwOCsBESMRATMyFhcBHgEXPgE3AT4BOwEC1sH986oaHgsBSBQbCwsaFAFHCR8ZrAI6%2FcYCOgNfGhP90yM%2BHh8%2BIgItEB0AAAEAVgAABJQFmQANAH5ADgAAAA0ADQwLBwYFBAUHK0uwX1BYQBsAAgIDAAAkBAEDAwsfAAAAAQAAJAABAQwBIAQbS7BsUFhAGQQBAwACAAMCAAAmAAAAAQAAJAABAQ8BIAMbQCIEAQMAAgADAgAAJgAAAQEAAAAjAAAAAQAAJAABAAEAACEEWVmwOCsBFRQHASEVITU0NwEhNQSUFfzVAzL70BMDLPznBZlIIh77jZ5MHhsEdp4AAQCO%2Ft8B%2FgX9AA0AOEAOAAAADQANCggHBQIBBQcrQCIAAAABAgABAQAmAAIDAwIBACMAAgIDAAAkBAEDAgMAACEEsDgrExEhFRQGKwERMzIWHQGOAXAbFqmpFhv%2B3wceRhYZ%2Bc0ZF0YAAAH%2F7P%2BmAu8FwQAJAC1ABgcFAgACBytLsI1QWEAMAAEAATUAAAANACACG0AKAAABADQAAQErAlmwOCsDMzIWFwEjIiYnFEwhMA0CWUsdOA0FwSIg%2BiciIwABAFr%2B3wHKBf0ADQAzQAoNDAsKBwUEAgQHK0AhAAIAAQACAQEAJgAAAwMAAQAjAAAAAwAAJAADAAMAACEEsDgrFzQ2OwERIyImPQEhESFaGxapqRYbAXD%2BkNsUHAYzGxRG%2BOIAAQCeAxMD3QWZABEAW0AIEQ8EAgEAAwcrS7BfUFhAEwoBAQABHgIBAQABNQAAAAsAIAMbS7DoUFhAEQoBAQABHgAAAQA0AgEBASsDG0AVCgECAAEeAAACADQAAgECNAABASsEWVmwOCsBMwEjIiYnAy4BJwYHAw4BKwECBHMBZoERGAjEDRMHDhfCCBcUiAWZ%2FXoUDgFgFysVLCv%2BoA4UAAEAAP7jAxT%2FWwADACtACgAAAAMAAwIBAwcrQBkCAQEAAAEAACMCAQEBAAAAJAAAAQAAACEDsDgrBRUhNQMU%2FOyleHgAAQAmBIsBswWpAAkAM0AKAQAGBAAJAQkDBytLsF9QWEANAAEAATUCAQAAEQAgAhtACwIBAAEANAABASsCWbA4KxMyFh8BIyImJwPPISAOlWYVGg7qBakVF%2FINDwECAAIAXP%2FwA3oEBwApADkBMkAWKyoxMCo5KzklIx4cGRcUEwsJAgAJBytLsB5QWEA5IQEEAy8FAgYHAh4ABAMCAwQCMgACAAcGAgcBACYAAwMFAQAkAAUFFB8IAQYGAAEAJAEBAAAMACAHG0uwX1BYQD0hAQQDLwUCBgcCHgAEAwIDBAIyAAIABwYCBwEAJgADAwUBACQABQUUHwAAAAwfCAEGBgEBACQAAQESASAIG0uwbFBYQDshAQQDLwUCBgcCHgAEAwIDBAIyAAUAAwQFAwEAJgACAAcGAgcBACYAAAAPHwgBBgYBAQAkAAEBFQEgBxtASCEBBAMvBQIGBwIeAAQDAgMEAjIAAAYBBgABMgAFAAMEBQMBACYAAgAHBgIHAQAmCAEGAAEGAQAjCAEGBgEBACQAAQYBAQAhCFlZWbA4KyEjIiYvAQ4DIyIuAjU0PgI3NTQmIyIOAiMiJi8BPgEzMh4CFQEyPgI3NQ4DFRQeAgN6TxogBRQoTFRfOjtnTC1Ck%2B6sZWNBWUEvFxIbCCBUwnZVhFou%2FjIvTkU%2FHnusbDEaLDwQGl4kOScUIUJlRTxvVjcET3Z5ISkhEw45UVA4ZI5V%2FeUTIzIg0wQfMkQqKDolEQAAAgCY%2F%2FIEFgXBABYAJQFfQBYYFwAAHx0XJRglABYAFREPBwUCAQgHK0uwCVBYQCsbGhMDBAUEAR4AAAANHwcBBAQBAQAkAAEBFB8ABQUCAQAkBgMCAgISAiAGG0uwIlBYQCsbGhMDBAUEAR4AAAANHwcBBAQBAQAkAAEBFB8ABQUCAQAkBgMCAgIVAiAGG0uwX1BYQC8bGhMDBAUEAR4AAAANHwcBBAQBAQAkAAEBFB8GAQMDDB8ABQUCAQAkAAICFQIgBxtLsGxQWEAtGxoTAwQFBAEeAAEHAQQFAQQBACYAAAANHwYBAwMPHwAFBQIBACQAAgIVAiAGG0uwjVBYQCwbGhMDBAUEAR4AAQcBBAUBBAEAJgAFAAIFAgEAJQYBAwMAAAAkAAAADQMgBRtANhsaEwMEBQQBHgABBwEEBQEEAQAmAAUDAgUBACMAAAYBAwIAAwEAJgAFBQIBACQAAgUCAQAhBllZWVlZsDgrMxEzET4BMzIeAhUUDgIjIiYnBwYjASIGBxEeATMyNjU0LgKYsz%2BjaViOZDY8caNmYokzCQgmAVFXgzcwdUiOmCNCYAXB%2FaJJWUKDwX5wwY1RTERcJgN3UEn%2BFkI2yrtjjlsqAAEASv%2FyA38EBQAqAQJADigmHhwYFhMRCQcEAgYHK0uwCVBYQDMqAQEFGgECAwIeAAABAwEAAzIAAwIBAwIwAAEBBQEAJAAFBRQfAAICBAEAJAAEBBIEIAcbS7BfUFhAMyoBAQUaAQIDAh4AAAEDAQADMgADAgEDAjAAAQEFAQAkAAUFFB8AAgIEAQAkAAQEFQQgBxtLsGxQWEAxKgEBBRoBAgMCHgAAAQMBAAMyAAMCAQMCMAAFAAEABQEBACYAAgIEAQAkAAQEFQQgBhtAOioBAQUaAQIDAh4AAAEDAQADMgADAgEDAjAABQABAAUBAQAmAAIEBAIBACMAAgIEAQAkAAQCBAEAIQdZWVmwOCsBDgEjIi4CIyIOAhUUHgIzMj4CMzIfAQ4BIyIuAjU0PgIzMhYXA0UIEA8PIzZNOEpyTScqTG1EQVQ4JBIXCzJCxm5fo3hFP3myc2qkPwNBCwwZHhk1ZI5YXI9hMx8mHxFBUUtGhcJ8ccCLTkU%2FAAACAEj%2F8gPFBcEAFgAlATtAFhgXAQAfHRclGCUVFBEPBwUAFgEWCAcrS7AiUFhALhMBBQIbGgMDBAUCHgADAw0fAAUFAgEAJAACAhQfBwEEBAABACQBBgIAAAwAIAYbS7BfUFhAMhMBBQIbGgMDBAUCHgADAw0fAAUFAgEAJAACAhQfBgEAAAwfBwEEBAEBACQAAQEVASAHG0uwbFBYQDATAQUCGxoDAwQFAh4AAgAFBAIFAQAmAAMDDR8GAQAADx8HAQQEAQEAJAABARUBIAYbS7CNUFhALxMBBQIbGgMDBAUCHgACAAUEAgUBACYHAQQAAQQBAQAlBgEAAAMAACQAAwMNACAFG0A6EwEFAhsaAwMEBQIeAAIABQQCBQEAJgcBBAABBAEAIwADBgEAAQMAAQAmBwEEBAEBACQAAQQBAQAhBllZWVmwOCshIi8BDgEjIi4CNTQ%2BAjMyFhcRMxElMjY3ES4BIyIGFRQeAgNbJgoQQadsV45kNjxxomddhDSy%2Fj1XgzcxdUeOmCJCYCV7T19DgsJ%2BcMGOUT85AjL6P4JQSQHqQjXKu2ONWyoAAgBK%2F%2FIDxwQFACQALQEQQBgmJQEAKSglLSYtHBoUEg8NCQcAJAEkCQcrS7AJUFhANBYBAgMBHgADAQIBAwIyAAYAAQMGAQEAJggBBQUAAQAkBwEAABQfAAICBAEAJAAEBBIEIAcbS7BfUFhANBYBAgMBHgADAQIBAwIyAAYAAQMGAQEAJggBBQUAAQAkBwEAABQfAAICBAEAJAAEBBUEIAcbS7BsUFhAMhYBAgMBHgADAQIBAwIyBwEACAEFBgAFAQAmAAYAAQMGAQEAJgACAgQBACQABAQVBCAGG0A7FgECAwEeAAMBAgEDAjIHAQAIAQUGAAUBACYABgABAwYBAQAmAAIEBAIBACMAAgIEAQAkAAQCBAEAIQdZWVmwOCsBMh4CFRQGIyEeAzMyPgIzMh8BDgMjIi4CNTQ%2BAhciBgchNC4CAiNbmnA%2FEhn9XgIwVHRIQ2FGLxEWDDIhXGlwN2mxgUhBerBygZQSAiciQl8EBT1zqWwqHGCOXy8fJB8RQSg7JhNHicqDariHTYOVhD5nSykAAAEAGgAAApQFrgAeASVAEgAAAB4AHh0cGxoVEg4MBwYHBytLsDJQWEArDwECAQEBBQQCHgACAgEBACQAAQERHwAEBAAAACQDAQAADh8GAQUFDAUgBhtLsF9QWEApDwECAQEBBQQCHgMBAAAEBQAEAAAmAAICAQEAJAABAREfBgEFBQwFIAUbS7BsUFhAJw8BAgEBAQUEAh4AAQACAAECAQAmAwEAAAQFAAQAACYGAQUFDwUgBBtLsOhQWEAzDwECAQEBBQQCHgYBBQQFNQABAAIAAQIBACYDAQAEBAAAACMDAQAABAAAJAAEAAQAACEGG0A5DwECAQEBBQQCHgAAAgMCAAMyBgEFBAU1AAEAAgABAgEAJgADBAQDAAAjAAMDBAAAJAAEAwQAACEHWVlZWbA4KzMRJy4BPQEzNTQ%2BAjMyFwcOASsBIg4CHQEhFSERunAVG6AxW4BQRDoEASAdHy5LNh0BJf7hA10NBRUUSWJXh10wFFkUCBg2WEFdgfygAAMAMv6TA94EBgA5AE0AXQFgQBxPTgEAV1VOXU9dSkhAPiMhGRcQDgQDADkBOQsHK0uwGVBYQEUIAQcIMhECAgdBKgIFAwMeCgEHAAIDBwIBACYAAwAFBgMFAQAmAAEBDh8ACAgAAQAkCQEAABQfAAYGBAEAJAAEBBYEIAgbS7BJUFhASAgBBwgyEQICB0EqAgUDAx4AAQAIAAEIMgoBBwACAwcCAQAmAAMABQYDBQEAJgAICAABACQJAQAAFB8ABgYEAQAkAAQEFgQgCBtLsF9QWEBFCAEHCDIRAgIHQSoCBQMDHgABAAgAAQgyCgEHAAIDBwIBACYAAwAFBgMFAQAmAAYABAYEAQAlAAgIAAEAJAkBAAAUCCAHG0BPCAEHCDIRAgIHQSoCBQMDHgABAAgAAQgyCQEAAAgHAAgBACYKAQcAAgMHAgEAJgADAAUGAwUBACYABgQEBgEAIwAGBgQBACQABAYEAQAhCFlZWbA4KwEyFhchFRQPARYVFA4CIyInDgEVFB4GFRQOAiMiLgI1NDY3LgE1ND4CNy4BNTQ%2BAgE0LgQnDgEVFB4CMzI%2BAgEyPgI1NCYjIgYVFB4CAedCcy8BEypzIjlli1NHPyAhOmB6f3pgOkF6sG9vp243X1MrMxAhMCBLVTlmjQGQKkheaGwxOUcjSG1KSHJPKv7ENlM4HHFsa3EdOFIEBh0cQiEJEEFQSnlWLhEULhYkJRAECRYyWEZBel85LEphNUtpHxRDOBYvLioQKotdSnlVLvvDJi4ZDAUGCBtONiI7KxkaMEICTh42Sy1dbm5dLUs2HgABAJIAAAPdBcEAFQD1QBAAAAAVABUSEA0MBwUCAQYHK0uwX1BYQCEUAwICAwEeAAAADR8AAwMBAQAkAAEBFB8FBAICAgwCIAUbS7BsUFhAHxQDAgIDAR4AAQADAgEDAQAmAAAADR8FBAICAg8CIAQbS7CNUFhAIRQDAgIDAR4AAQADAgEDAQAmBQQCAgIAAAAkAAAADQIgBBtLsOhQWEAqFAMCAgMBHgAAAQIAAAAjAAEAAwIBAwEAJgAAAAIAACQFBAICAAIAACEFG0AuFAMCBAMBHgACBAI1AAABBAAAACMAAQADBAEDAQAmAAAABAAAJAUBBAAEAAAhBllZWVmwOCszETMRPgEzMh4CFREjETQmIyIGBxGSskGeZ1N%2FVSyyaWxPiToFwf2sRVM3ZY5W%2FXsChXN%2FTEH9FgAAAgCCAAABgAWzAAMAFwDCQA4AABQSCggAAwADAgEFBytLsAlQWEAZAAICAwEAJAADAxEfBAEBAQ4fAAAADAAgBBtLsF9QWEAZAAICAwEAJAADAw0fBAEBAQ4fAAAADAAgBBtLsGxQWEAbAAICAwEAJAADAw0fBAEBAQAAACQAAAAPACAEG0uwjVBYQBgEAQEAAAEAAAAlAAICAwEAJAADAw0CIAMbQCMAAwACAQMCAQAmBAEBAAABAAAjBAEBAQAAACQAAAEAAAAhBFlZWVmwOCsBESMRExQOAiMiLgI1ND4CMzIeAgFYstoVIy4aGi0jFBQjLRoaLiMVA%2FX8CwP1AT4aLSMUFCMtGhovIxQUIy8AAAL%2FyP6UAYAFswAUACgBAUAQAAAlIxsZABQAFBEMBwUGBytLsAlQWEAmCQEAAQEeAAMDBAEAJAAEBBEfBQECAg4fAAEBAAEAJAAAABYAIAYbS7BJUFhAJgkBAAEBHgADAwQBACQABAQNHwUBAgIOHwABAQABACQAAAAWACAGG0uwX1BYQCMJAQABAR4AAQAAAQABACUAAwMEAQAkAAQEDR8FAQICDgIgBRtLsI1QWEAmCQEAAQEeBQECAwEDAgEyAAEAAAEAAQAlAAMDBAEAJAAEBA0DIAUbQDAJAQABAR4FAQIDAQMCATIABAADAgQDAQAmAAEAAAEBACMAAQEAAQAkAAABAAEAIQZZWVlZsDgrAREUDgIjIiYnNz4BMzIWMzI2NRETFA4CIyIuAjU0PgIzMh4CAVggRW1MITYbCAIODwgSDU5C2hUjLhoaLSMUFCMtGhouIxUD9fvAPWlOLQoKYA0HAUlRBEABPhotIxQUIy0aGi8jFBQjLwAAAQCYAAAD%2BAXBAB4BEUASAAAAHgAeHRwbGRQSCggDAQcHK0uwX1BYQCMOAQMAAR4AAAADAgADAQAmBgEFBQ0fAAEBDh8EAQICDAIgBRtLsGxQWEAlDgEDAAEeAAAAAwIAAwEAJgYBBQUNHwABAQIBACQEAQICDwIgBRtLsI1QWEAoDgEDAAEeAAEAAgEBACMAAAADAgADAQAmBAECAgUAACQGAQUFDQUgBRtLsOhQWEAxDgEDAAEeBgEFAQIFAAAjAAEAAgEBACMAAAADAgADAQAmAAEBAgEAJAQBAgECAQAhBhtAMg4BAwABHgABAAIBAQAjAAAAAwQAAwEAJgYBBQAEAgUEAAAmAAEBAgEAJAACAQIBACEGWVlZWbA4KwERMzI2NwE%2BATsBAQ4BBx4BFwEjIiYnAS4BKwERIxEBSy4UGhABQA8eGaL%2Biw4bERIdDQGMoBYfDv6zDx4eMrMFwfydCxEBVxAU%2FnMRGgoMHxT%2BDBESAZ8VDf4cBcEAAAEApgAAAVgFwQADAG9ACgAAAAMAAwIBAwcrS7BfUFhADQIBAQENHwAAAAwAIAIbS7BsUFhADQIBAQENHwAAAA8AIAIbS7CNUFhADwAAAAEAACQCAQEBDQAgAhtAGQIBAQAAAQAAIwIBAQEAAAAkAAABAAAAIQNZWVmwOCsBESMRAViyBcH6PwXBAAEAkgAABe8EBQAqARtAFgAAACoAKiclIiEcGhcWEQ8JBwMBCQcrS7AeUFhAISkLBQMDBAEeBgEEBAABACQCAQIAAA4fCAcFAwMDDAMgBBtLsF9QWEAlKQsFAwMEAR4AAAAOHwYBBAQBAQAkAgEBARQfCAcFAwMDDAMgBRtLsGxQWEAlKQsFAwMEAR4CAQEGAQQDAQQBACYAAAADAAAkCAcFAwMDDwMgBBtLsOhQWEAuKQsFAwMEAR4AAAQDAAEAIwIBAQYBBAMBBAEAJgAAAAMAACQIBwUDAwADAAAhBRtAQCkLBQMHBAEeAAUHAwcFAzIAAwMzAAAGBwABACMAAQAGBAEGAQAmAAIABAcCBAEAJgAAAAcAACQIAQcABwAAIQhZWVlZsDgrMxEzMh8BPgEzMhYXPgMzMh4CFREjETQmIyIOAhURIxE0JiMiBgcRkmomCg04i1xnfxwVRVZhMlB9Vy6yaGMsTzwjsmJeQnEvA%2FUlaEVYcmE3UDQYM2KPXP17AoV3ex88Wzz9ewKFenhHPf0NAAABAJIAAAPdBAUAFwDzQBAAAAAXABcUEg8OCQcDAQYHK0uwHlBYQB0WBQICAwEeAAMDAAEAJAEBAAAOHwUEAgICDAIgBBtLsF9QWEAhFgUCAgMBHgAAAA4fAAMDAQEAJAABARQfBQQCAgIMAiAFG0uwbFBYQCEWBQICAwEeAAEAAwIBAwEAJgAAAAIAACQFBAICAg8CIAQbS7DoUFhAKhYFAgIDAR4AAAMCAAEAIwABAAMCAQMBACYAAAACAAAkBQQCAgACAAAhBRtALhYFAgQDAR4AAgQCNQAAAwQAAQAjAAEAAwQBAwEAJgAAAAQAACQFAQQABAAAIQZZWVlZsDgrMxEzMh8BPgEzMh4CFREjETQmIyIGBxGSaiYKDkKja1N%2FVSyyaWxPiToD9SVuSVo3ZY5W%2FXsChXN%2FTEH9FgACAEj%2F8gQOBAUAEwAjAKtAEhUUAQAbGRQjFSMLCQATARMGBytLsAlQWEAcAAMDAAEAJAQBAAAUHwUBAgIBAQAkAAEBEgEgBBtLsF9QWEAcAAMDAAEAJAQBAAAUHwUBAgIBAQAkAAEBFQEgBBtLsGxQWEAaBAEAAAMCAAMBACYFAQICAQEAJAABARUBIAMbQCQEAQAAAwIAAwEAJgUBAgEBAgEAIwUBAgIBAQAkAAECAQEAIQRZWVmwOCsBMh4CFRQOAiMiLgI1ND4CEzI2NTQmIyIOAhUUHgICLG%2BzfUNDfbNvb7N%2BRER%2Bs2%2BWlJSWTHBLJSVLcAQFSojBd3jAiElJiMB4d8GISvx4ybS1yjRij1pajmE0AAIAkv6pBA8EBwAWACUBdUAWGBcAAB8dFyUYJQAWABYTEQkHAwEIBytLsAlQWEAuGxoFAwUEFQECBQIeBwEEBAABACQBAQAADh8ABQUCAQAkAAICEh8GAQMDEAMgBhtLsBpQWEAuGxoFAwUEFQECBQIeBwEEBAABACQBAQAADh8ABQUCAQAkAAICFR8GAQMDEAMgBhtLsElQWEAyGxoFAwUEFQECBQIeAAAADh8HAQQEAQEAJAABARQfAAUFAgEAJAACAhUfBgEDAxADIAcbS7BfUFhANBsaBQMFBBUBAgUCHgcBBAQBAQAkAAEBFB8ABQUCAQAkAAICFR8GAQMDAAEAJAAAAA4DIAcbS7BsUFhALxsaBQMFBBUBAgUCHgABBwEEBQEEAQAmAAAGAQMAAwAAJQAFBQIBACQAAgIVAiAFG0A5GxoFAwUEFQECBQIeAAAEAwABACMAAQcBBAUBBAEAJgAFAAIDBQIBACYAAAADAAAkBgEDAAMAACEGWVlZWVmwOCsTETMyHwE%2BATMyHgIVFA4CIyImJxEBIgYHER4BMzI2NTQuApJqJgoPQadtV45kNjxwo2ZehTMBEVeDNzF1SI2YI0Jg%2FqkFTCV4T2BDg8J%2BcMGNUT45%2FkAEzlBJ%2FhZCNsq7Y45bKgACAEj%2BqQPFBAcAFgAlAXZAFhgXAAAfHRclGCUAFgAVEQ8HBQIBCAcrS7AJUFhALhMBBQIbGgMDBAUCHgAFBQIBACQGAwICAhQfBwEEBAEBACQAAQESHwAAABAAIAYbS7AaUFhALhMBBQIbGgMDBAUCHgAFBQIBACQGAwICAhQfBwEEBAEBACQAAQEVHwAAABAAIAYbS7BJUFhAMhMBBQMbGgMDBAUCHgYBAwMOHwAFBQIBACQAAgIUHwcBBAQBAQAkAAEBFR8AAAAQACAHG0uwX1BYQDQTAQUDGxoDAwQFAh4ABQUCAQAkAAICFB8HAQQEAQEAJAABARUfAAAAAwEAJAYBAwMOACAHG0uwbFBYQC8TAQUDGxoDAwQFAh4AAgAFBAIFAQAmBgEDAAADAAAAJQcBBAQBAQAkAAEBFQEgBRtAOhMBBQMbGgMDBAUCHgYBAwUAAwEAIwACAAUEAgUBACYHAQQAAQAEAQEAJgYBAwMAAAAkAAADAAAAIQZZWVlZWbA4KwERIxEOASMiLgI1ND4CMzIWFzc2MwEyNjcRLgEjIgYVFB4CA8WyQKNpV45kNjxxomdiiTYMCib%2Bp1eDNzB2R46YIkJgA%2FX6tAHtSlpDgsJ%2BcMGOUUZATyX8jVBJAepAN8q7Y41bKgABAJIAAAL6BAcAFgDhQBAAAAAWABYTERAOCggDAQYHK0uwGlBYQCEMAQIAFQYCBAICHgMBAgIAAQAkAQEAAA4fBQEEBAwEIAQbS7BfUFhALAwBAwAVBgIEAgIeAAIDBAMCBDIAAAAOHwADAwEBACQAAQEUHwUBBAQMBCAGG0uwbFBYQCwMAQMAFQYCBAICHgACAwQDAgQyAAEAAwIBAwEAJgAAAAQAACQFAQQEDwQgBRtANQwBAwAVBgIEAgIeAAIDBAMCBDIAAAMEAAEAIwABAAMCAQMBACYAAAAEAAAkBQEEAAQAACEGWVlZsDgrMxEzMhYfAT4BMzIWFwcGIyImIyIGBxGSZh0WBAw0mWcqRB0XBxgOOjRdfSoD9RYbnmp3ExGFGRNsZ%2F17AAABAD7%2F8AMPBAUAPADGQA46OCclIiAbGQgGAwEGBytLsF9QWEAzPAEBBR0BAgQCHgAAAQMBAAMyAAMEAQMEMAABAQUBACQABQUUHwAEBAIBACQAAgISAiAHG0uwbFBYQDE8AQEFHQECBAIeAAABAwEAAzIAAwQBAwQwAAUAAQAFAQEAJgAEBAIBACQAAgIVAiAGG0A6PAEBBR0BAgQCHgAAAQMBAAMyAAMEAQMEMAAFAAEABQEBACYABAICBAEAIwAEBAIBACQAAgQCAQAhB1lZsDgrAQYjIi4CIyIOAhUUHgYVFA4CIyImJzc%2BATMyHgIzMj4CNTQuBjU0PgIzMhYXAtYMGQ8mN0w0LUgzGy1KXmNeSi0yYo5daqw8KggWEhIoOVE9NE40GS1KX2NfSi0wXIZWZJ86A04WFhsXFyg1Hyc0Jh0hKDxXPUZ3VzJFNkQNDhwiHBsuPCIqNycdICk%2BW0E6a1EwPzcAAAEALP%2FwAroFPgAhAU9AFAEAHRsYFhMSERAPDQYEACEBIQgHK0uwMlBYQDMJAQEDHwEABQIeAAIDAjQABgEFAQYFMgQBAQEDAAAkAAMDDh8ABQUAAQIkBwEAABIAIAcbS7BfUFhAMQkBAQMfAQAFAh4AAgMCNAAGAQUBBgUyAAMEAQEGAwEBACYABQUAAQIkBwEAABIAIAYbS7BsUFhAMQkBAQMfAQAFAh4AAgMCNAAGAQUBBgUyAAMEAQEGAwEBACYABQUAAQIkBwEAABUAIAYbS7DoUFhAOgkBAQMfAQAFAh4AAgMCNAAGAQUBBgUyAAMEAQEGAwEBACYABQAABQEAIwAFBQABAiQHAQAFAAECIQcbQEAJAQQDHwEABQIeAAIDAjQAAQQGBAEGMgAGBQQGBTAAAwAEAQMEAAAmAAUAAAUBACMABQUAAQIkBwEABQABAiEIWVlZWbA4KwUiJjURIyImPQE3Ez4BOwERIRUhERQWMzI%2BAjMyHwEOAQHFeIF6EBamKQIWEVoBIv7ePjEcKR4VCA4LNC6CEIZ%2BAmwTFEcVATkPE%2F6jgf2gQD4PEg8RVSsxAAEAev%2FwA8UD9QAXAPhAEAAAABcAFxIQDAoJCAUDBgcrS7AeUFhAHQ4HAgABAR4FBAIBAQ4fAAAAAgEAJAMBAgIMAiAEG0uwX1BYQCEOBwIAAQEeBQQCAQEOHwACAgwfAAAAAwEAJAADAxIDIAUbS7BsUFhAIw4HAgABAR4FBAIBAQIBACQAAgIPHwAAAAMBACQAAwMVAyAFG0uw6FBYQCoOBwIAAQEeAAACAwABACMFBAIBAAIDAQIBACYAAAADAQAkAAMAAwEAIQUbQDEOBwIABAEeBQEEAQABBAAyAAACAwABACMAAQACAwECAQAmAAAAAwEAJAADAAMBACEGWVlZWbA4KwERFBYzMjY3ETMRIyIvAQ4BIyIuAjURASxqa06KOrJqJgoOQqRqU39WKwP1%2FXpzfkpCAuv8CyVtSVk3ZI5WAoYAAQASAAAD7QP1ABIAd0AIEhEQDgIAAwcrS7BfUFhAEwgBAgABHgEBAAAOHwACAgwCIAMbS7BsUFhAEwgBAgABHgEBAAIANAACAg8CIAMbS7DoUFhAEQgBAgABHgEBAAIANAACAisDG0AVCAECAQEeAAABADQAAQIBNAACAisEWVlZsDgrEzMyFhcBHgEXPgE3AT4BOwEBIxKSFRwGAQEOEAcIEg4BBAYbFIv%2BY6ED9RYP%2FXQkSCMjSCQCjBAV%2FAsAAQAOAAAF7wP3AC4AtUAMLiwiIB8dEQ4CAAUHK0uwX1BYQBcnFwgDAwABHgIBAgAADh8EAQMDDAMgAxtLsGxQWEAXJxcIAwMAAR4CAQIAAwA0BAEDAw8DIAMbS7DHUFhAFScXCAMDAAEeAgECAAMANAQBAwMrAxtLsOhQWEAZJxcIAwMAAR4AAQABNAIBAAMANAQBAwMrBBtAIScXCAMEAgEeAAEAATQAAAIANAACBAI0AAQDBDQAAwMrBllZWVmwOCsTMzIWFxMeARc%2BATcTPgE7ATIWFxMeARc%2BATcTPgE7AQEjIicDLgEnDgEHAwYrAQ6MFhwFwggOBQgUC9YFGRNNFBoF0QsRCAUQCcYFHBOG%2FriNGgrgCAoFBQoI4wsehgP1Fg%2F9dCRDIiJDJAKQDxQUD%2F1wI0QhIUgfAowQFfwLIgKvFy8XFzAX%2FVIiAAEAHAAAA9ID9QAbAKpAChsZEQ8NCwMBBAcrS7BfUFhAFxQOBgAEAgABHgEBAAAOHwMBAgIMAiADG0uwbFBYQBkUDgYABAIAAR4BAQAAAgEAJAMBAgIPAiADG0uw6FBYQCMUDgYABAIAAR4BAQACAgABACMBAQAAAgEAJAMBAgACAQAhBBtAKhQOBgAEAwEBHgABAwIBAQAjAAAAAwIAAwEAJgABAQIBACQAAgECAQAhBVlZWbA4KwkBMzIWFxM2NxM%2BATsBCQEjIiYnAwYHAw4BKwEBf%2F6rqxYUCPgJEdoKFA%2Bk%2FqsBY6sWGQj%2FBw7sChcUnwIHAe4ODf6EHBwBQA4R%2Fhz97xcOAY0dF%2F6nDhcAAQAO%2FqkD8AP1ABYAe0AIFhQIBgQCAwcrS7BJUFhAFA4FAgABAR4CAQEBDh8AAAAQACADG0uwX1BYQBQOBQIAAQEeAAABADUCAQEBDgEgAxtLsOhQWEASDgUCAAEBHgIBAQABNAAAACsDG0AWDgUCAAIBHgABAgE0AAIAAjQAAAArBFlZWbA4KwEOASsBEwEzMhYXAR4BFz4BNwE%2BATsBAbsJGxyEuf5emhcaBgEPCQ0FBw4JAQcGHRGO%2FtUUGAGSA7oXDv2CFiwXFywXAn0QFQAAAQBGAAADVQP1AA8Ad0AKDw4NDAcGBQQEBytLsF9QWEAaAAICAwAAJAADAw4fAAAAAQAAJAABAQwBIAQbS7BsUFhAGAADAAIAAwIAACYAAAABAAAkAAEBDwEgAxtAIQADAAIAAwIAACYAAAEBAAAAIwAAAAEAACQAAQABAAAhBFlZsDgrARQGBwEhFSE1NDY3ASE1IQNVDgv93AIp%2FQUNDAIn%2Fd8C8AOpEyMO%2FSaLSg0jEALfjAABACz%2B3wIABf0AQABHQA44NjMwGBUSEAUEAwIGBytAMSQBAAEBHgACAAMBAgMBACYAAQAABAEAAQAmAAQFBQQBACMABAQFAQAkAAUEBQEAIQawOCsTNCYjNTI2NTQuAjU0PgI7ARUUBisBIgYVFB4CFRQOAgceAxUUDgIVFBY7ATIWHQEjIi4CNTQ%2BArVGQ0NGEBMQKVN7UjUcDBRNWQ4SDhYpNyEhNykWDhIOWU0UDBw1UntTKRATEAGpP1FrUEAyYmJkNEV0VC5PFBJlVjhoY2IyJkEzJQkJJTRAJTJiY2g4V2QSFFAvVHRFNGNjYgABAOb%2BqQFwBf0AAwA8QAYDAgEAAgcrS7BJUFhADgAAAAEAACQAAQEQASACG0AXAAABAQAAACMAAAABAAAkAAEAAQAAIQNZsDgrEzMRI%2BaKigX9%2BKwAAAEAWP7fAiwF%2FQBAAEdADj8%2BPTwxLywpEQ4LCQYHK0AxHQEFBAEeAAMAAgQDAgEAJgAEAAUBBAUBACYAAQAAAQEAIwABAQABACQAAAEAAQAhBrA4KwEUHgIVFA4CKwE1NDY7ATI2NTQuAjU0PgI3LgM1ND4CNTQmKwEiJj0BMzIeAhUUDgIVFBYzFSIGAaMQExAqUntSNRwMFE1ZDhIOFik3ISE3KRYOEg5ZTRQMHDVSe1IqEBMQRkNDRgGpMmJjYzRFdFQvUBQSZFc4aGNiMiVANCUJCSUzQSYyYmNoOFZlEhRPLlR0RTRkYmIyQFBrUQAAAQB0AZ4EEgMAABsAR0ASAQAYFhIRDw0KCAQDABsBGwcHK0AtAAEFATQABAIENQYBAAMCAAEAIwAFAAMCBQMBACYGAQAAAgEAJAACAAIBACEGsDgrATI2NzMUDgIjIi4CIyIGByM0PgIzMh4CAvdBSQGQJUVmQDRmX1YkQUkBkCVFZUE0Zl9WAmVVRkNwUCwgJyFUR0NwUC0hJyEAAgDa%2FqkB1AQFAA0AIQB9QA4AAB4cFBIADQANBwYFBytLsElQWEAbAAMDAgEAJAACAhQfAAAAAQAAJAQBAQEQASAEG0uwX1BYQBgAAAQBAQABAAAlAAMDAgEAJAACAhQDIAMbQCIAAgADAAIDAQAmAAABAQAAACMAAAABAAAkBAEBAAEAACEEWVmwOCsBETQ%2BAjczHgMVEQM0PgIzMh4CFRQOAiMiLgIBBgMGCQZ5BgkGA9UTIi0bGi0iFBQiLRobLSIT%2FqkCHS1VV1w0NFxXVS394wTfGy0iExMiLRsaLiIUFCIuAAACAIr%2FFQQCBOYALgA3AZlAEC4sKSgjIR4dGBYPDQoJBwcrS7AJUFhARQsBAAEzHBMQBAIAMiYCAwQqAAIGBQQeAAEAATQAAgAEAAIEMgAEAwAEAzAAAwMFAQIkAAUFFR8ABgYAAQAkAAAAFAYgCBtLsAtQWEBFCwEAATMcExAEAgAyJgIDBCoAAgYFBB4AAQABNAACAAQAAgQyAAQDAAQDMAADAwUBAiQABQUSHwAGBgABACQAAAAUBiAIG0uwX1BYQEULAQABMxwTEAQCADImAgMEKgACBgUEHgABAAE0AAIABAACBDIABAMABAMwAAMDBQECJAAFBRUfAAYGAAEAJAAAABQGIAgbS7BsUFhAQgsBAAEzHBMQBAIAMiYCAwQqAAIGBQQeAAEAATQAAgAEAAIEMgAEAwAEAzAAAAAGAAYBACUAAwMFAQIkAAUFFQUgBxtATAsBAAEzHBMQBAIAMiYCAwQqAAIGBQQeAAEAATQAAgAEAAIEMgAEAwAEAzAAAAIGAAEAIwADAAUGAwUBAiYAAAAGAQAkAAYABgEAIQhZWVlZsDgrBS4DNTQ%2BAj8BPgE7AQceARcHDgEjIi4CJwM%2BAzMyFh8BDgEPAQ4BKwEDFBYXEw4DAjFcm3E%2FQn64dwwCGxVCEFKENi4IDw4MIS0%2FKjQ%2FVTsmEAsSBTA8uWsMAhsVQueHeTRMc04nCwpPhLZyb7uKUQOzFB3pDD8xPgsLERgYB%2F0GBB8iHAkHP0hKB68THQLlosAXAvgGOWOIAAEANAAABFsFqAA%2BAS9AFD49NjQvLSclIiEcGhQSCwkEAgkHK0uwX1BYQDkPAQIDNysCBwYCHgACAwADAgAyBAEACAEFBgAFAQAmAAMDAQEAJAABAREfAAYGBwEAJAAHBwwHIAcbS7BsUFhANw8BAgM3KwIHBgIeAAIDAAMCADIAAQADAgEDAQAmBAEACAEFBgAFAQAmAAYGBwEAJAAHBw8HIAYbS7DoUFhAQA8BAgM3KwIHBgIeAAIDAAMCADIAAQADAgEDAQAmBAEACAEFBgAFAQAmAAYHBwYBACMABgYHAQAkAAcGBwEAIQcbQEgPAQIDNysCBwYCHgACAwADAgAyAAEAAwIBAwEAJgAAAAgFAAgAACYABAAFBgQFAQAmAAYHBwYBACMABgYHAQAkAAcGBwEAIQhZWVmwOCsTNDY7ARE0PgIzMh4CFwcOASMiJicuAyMiDgIVESEVFAYjIRUUBgc%2BATMhFRQOAiMhNT4DNREjNCAdhjZupG5OeV5FGEgKFQoOGQsUKTNCLT9gQCABuR4W%2Fns5Mh05HgKkCxQcEvw8Ij4wHcMCoBokAQVepXtHJ0RaNC4GBQsOGS8jFSpObkT%2B%2BUgSHvNLbS0FB0wOGxcOcwoiM0UuASEAAgCEAOAEBARgACMANwCVQAo0MiooHBoKCAQHK0uwX1BYQDgODAYEBAMAIRUPAwQCAx4YFgMBAgMeDQUCABwgHxcDARsAAgABAgEBACUAAwMAAQAkAAAAFAMgBhtAQg4MBgQEAwAhFQ8DBAIDHhgWAwECAx4NBQIAHCAfFwMBGwAAAAMCAAMBACYAAgEBAgEAIwACAgEBACQAAQIBAQAhB1mwOCsTNDY3JzcXPgEzMhYXNxcHHgEVFAYHFwcnDgEjIiYnByc3LgE3FB4CMzI%2BAjU0LgIjIg4C3yEdmVuXLGg6OWYrmVmXHyIhHZhbmCxoOTllLJlZlx4ihCM%2BUS8vUz0kJD1TLy9RPiMCoDllLJlamB8iIR6ZW5gsZzo5ZiuXXJgeIiEdmVuYLGc6LlE9JCQ9US4vUj4jIz5SAAEALAAABFMFmQAiARJAGCIhIB8eHRwbGhkYFxYVFBMSEAQCAQALBytLsF9QWEArCgEAAQEeAwEACgEEBQAEAAImCQEFCAEGBwUGAAAmAgEBAQsfAAcHDAcgBRtLsGxQWEArCgEAAQEeAgEBAAE0AwEACgEEBQAEAAImCQEFCAEGBwUGAAAmAAcHDwcgBRtLsOhQWEA3CgEAAQEeAgEBAAE0AAcGBzUDAQAKAQQFAAQAAiYJAQUGBgUAACMJAQUFBgAAJAgBBgUGAAAhBxtASgoBAAIBHgABAgE0AAIAAjQABwYHNQAAAAoEAAoAAiYAAwAEBQMEAAImAAUJBgUAACMACQAIBgkIAAAmAAUFBgAAJAAGBQYAACEKWVlZsDgrEyEBMzIWFwEeARc%2BATcBPgE7AQEhFSEVIRUhESMRITUhNSGSATL%2BaJUaHwoBFA4UBwcSDgETCCEZlv5nATP%2BrAFU%2Fqyz%2FqwBVP6sAnEDKBkU%2FcojOh0dOyICNhEc%2FNhmaWf%2BxQE7Z2kAAgDm%2FqkBcAX9AAMABwBUQAoHBgUEAwIBAAQHK0uwSVBYQBgAAAABAgABAAAmAAICAwAAJAADAxADIAMbQCEAAAABAgABAAAmAAIDAwIAACMAAgIDAAAkAAMCAwAAIQRZsDgrEzMRIxEzESPmioqKigX9%2FOb%2B4fzlAAACAHL%2FgwOHBacASABaAJdADkZELSsoJiEfCAYDAQYHK0uwX1BYQDdIAQEFWE49GAQDACMBAgQDHgAAAQMBAAMyAAMEAQMEMAAEAAIEAgEAJQABAQUBACQABQURASAGG0BBSAEBBVhOPRgEAwAjAQIEAx4AAAEDAQADMgADBAEDBDAABQABAAUBAQAmAAQCAgQBACMABAQCAQAkAAIEAgEAIQdZsDgrAQYjIi4CIyIOAhUUHgYVFAYHHgEVFA4CIyImJzc%2BATMyHgIzMj4CNTQuBjU0NjcuATU0PgIzMhYXARQeAhc%2BATU0LgQnDgEDMQwZDyY3TDQwTTUcMU9maWZPMU5UMT4yYY9caqw8KQgXERIoOlU%2FMk82HDJSaG5oUjJWXTI%2FMFyGVmSfOv23Rm2EPjYwHjRGT1QoQjYE8RYWGxcZKjgfJjkvKy43R1w9UX8mJWJFRndXMkU2RA0OHCMcGS0%2BJi1CMyosM0ZdQE59IyZpSzprUDA%2BN%2F2kM0c5NR8aSy8kOC4mIyMUHkkAAAIADgSaAlYFewATACcAb0AKJCIaGBAOBgQEBytLsCBQWEAQAgEAAAEBACQDAQEBCwAgAhtLsOhQWEAaAwEBAAABAQAjAwEBAQABACQCAQABAAEAIQMbQCEAAQMAAQEAIwADAAIAAwIBACYAAQEAAQAkAAABAAEAIQRZWbA4KxMUDgIjIi4CNTQ%2BAjMyHgIFFA4CIyIuAjU0PgIzMh4C7xIgKRcWKB8SEh8oFhcpIBIBZxIfKRcXKR4SEh4pFxcpHxIFCRcoHhISHigXFyofEhIfKhcXKB4SEh4oFxcqHxISHyoAAAMARP%2FyBfkFqAAuAEoAYgFaQBZfXVNRRUM3NSspIR8cGhUTCwkEAgoHK0uwCVBYQEcXAQQCBwEFAAIeAAMEAAQDADIAAAUEAAUwAAIABAMCBAEAJgAFAAEIBQEBACYACQkGAQAkAAYGER8ACAgHAQAkAAcHEgcgCRtLsF9QWEBHFwEEAgcBBQACHgADBAAEAwAyAAAFBAAFMAACAAQDAgQBACYABQABCAUBAQAmAAkJBgEAJAAGBhEfAAgIBwEAJAAHBxUHIAkbS7BsUFhARRcBBAIHAQUAAh4AAwQABAMAMgAABQQABTAABgAJAgYJAQAmAAIABAMCBAEAJgAFAAEIBQEBACYACAgHAQAkAAcHFQcgCBtAThcBBAIHAQUAAh4AAwQABAMAMgAABQQABTAABgAJAgYJAQAmAAIABAMCBAEAJgAFAAEIBQEBACYACAcHCAEAIwAICAcBACQABwgHAQAhCVlZWbA4KwE%2BATMyFh8BDgEjIi4CNTQ%2BAjMyFhcHDgEjIi4CIyIOAhUUHgIzMj4CATQ%2BBDMyHgQVFA4EIyIuBDcUHgQzMj4CNTQuBCMiDgIEBggLBgsIBj05pnRioXM%2FRXqnYmyYOS4FEAwOHzJMO0ZxTysrTGo%2BMEIwJfxSNF%2BGorplZbuihl80NF%2BGortlZbqihl80ZCxScoyiWITnq2MtUnOMo1iE5qpiAc8FBwYGQEJJRHqoZGWpeUNEN0EGDBYbFy1UeEtNeVIrDBQYAQllu6OFYDQ0YIWju2Vku6KFYDQ0YIWiumVZpI90Uy1kremGWaaPdlMuZa%2FrAAACAFwDPwJUBaoAKQA1APRAFisqLy4qNSs1JSMeHBkXFBMLCQIACQcrS7A2UFhAOSEBAwUtAQYHBQEABgMeAAQDAgMEAjIAAgAHBgIHAQAmCAEGAQEABgABACUAAwMFAQAkAAUFEQMgBhtLsF9QWEBAIQEDBS0BBgcFAQAGAx4ABAMCAwQCMgAABgEGAAEyAAIABwYCBwEAJggBBgABBgEBACUAAwMFAQAkAAUFEQMgBxtASyEBAwUtAQYHBQEABgMeAAQDAgMEAjIAAAYBBgABMgAFAAMEBQMBACYAAgAHBgIHAQAmCAEGAAEGAQAjCAEGBgEBACQAAQYBAQAhCFlZsDgrASMiJi8BDgMjIi4CNTQ%2BAjc1NCYjIg4CIyImLwE%2BATMyHgIVATI2NzUOAxUUFgJUPBISCAwYLjI4IiZBMBsmWJFrOjkmMiUdEA4UBRY0eUk2VDoe%2FuEzSiRGYTwaNANICxIxFSAXCxQpPCkiQzUjAiU%2FPBIVEQ8KKjEuIjxUM%2F7WJiNpAhEbIxUqIgAAAgCKAIEDAQOiABQAKQAJQAYXKQIUAgsrEzUTFx4BFRQHAwYHFhcTHgEVFA8BEzUTFx4BFRQHAwYHFhcTHgEVFA8Bivk6Dg4Knw4ODw2fBQUcOi%2F5Og4OCp8ODg8NnwUFHDoCBhcBhRwHFg0REP77GA0OFv77CBIIHA0cAYUXAYUcBxYNERD%2B%2BxgNDhb%2B%2BwgSCBwNHAAAAQCUATsD8ALjAAUAUkAIBQQDAgEAAwcrS7AJUFhAHQABAgIBKQAAAgIAAAAjAAAAAgAAJAACAAIAACEEG0AcAAECATUAAAICAAAAIwAAAAIAACQAAgACAAAhBFmwOCsTIREjESGUA1yX%2FTsC4%2F5YASEAAQBkAgwCUgKjAAMAJUAGAwIBAAIHK0AXAAABAQAAACMAAAABAAAkAAEAAQAAIQOwOCsTIRUhZAHu%2FhICo5cAAAQARP%2FyBfkFqAAbADMASQBWAY5AGjQ0VlRMSjRJNEhEQjk3NjUwLiQiFhQIBgsHK0uwCVBYQD4%2BAQcIAR4GAQQHAgcEAjIABQAJCAUJAQAmAAgKAQcECAcBACYAAwMAAQAkAAAAER8AAgIBAQAkAAEBEgEgCBtLsF9QWEA%2BPgEHCAEeBgEEBwIHBAIyAAUACQgFCQEAJgAICgEHBAgHAQAmAAMDAAEAJAAAABEfAAICAQEAJAABARUBIAgbS7BsUFhAPD4BBwgBHgYBBAcCBwQCMgAAAAMFAAMBACYABQAJCAUJAQAmAAgKAQcECAcBACYAAgIBAQAkAAEBFQEgBxtLsOhQWEBFPgEHCAEeBgEEBwIHBAIyAAAAAwUAAwEAJgAFAAkIBQkBACYACAoBBwQIBwEAJgACAQECAQAjAAICAQEAJAABAgEBACEIG0BLPgEHCAEeAAYHBAcGBDIABAIHBAIwAAAAAwUAAwEAJgAFAAkIBQkBACYACAoBBwYIBwEAJgACAQECAQAjAAICAQEAJAABAgEBACEJWVlZWbA4KxM0PgQzMh4EFRQOBCMiLgQ3FB4EMzI%2BAjU0LgQjIg4CBREjESEyFhUUBgceARcTIyInAy4BIyczMj4CNTQuAisBRDRfhqK6ZWW7ooZfNDRfhqK7ZWW6ooZfNGQsUnKMoliE56tjLVJzjKNYhOaqYgHmnAEgrKZrahEZC%2BSUIRDJCRkaUHQ3TS8VEytGNIQCzGW7o4VgNDRghaO7ZWS7ooVgNDRghaK6ZVmkj3RTLWSt6YZZpo92Uy5lr%2Bvg%2Fp4DfH16XoQZCh4U%2FrIZAS4NDnIVKDomJTgkEgABABQEzwJSBUQAAwAlQAYDAgEAAgcrQBcAAAEBAAAAIwAAAAEAACQAAQABAAAhA7A4KxMhFSEUAj79wgVEdQAAAgBGAycC0gWqABMAJwBTQAokIhoYEA4GBAQHK0uwX1BYQBcAAgABAgEBACUAAwMAAQAkAAAAEQMgAxtAIQAAAAMCAAMBACYAAgEBAgEAIwACAgEBACQAAQIBAQAhBFmwOCsTND4CMzIeAhUUDgIjIi4CNxQeAjMyPgI1NC4CIyIOAkYyWHdFRXdYMjJYd0VFd1gyfx42SSoqSDYeHjZIKipJNh4EaEN2VzIyV3ZDQnVXMzNXdUEqSTYfHzZJKipKNx8fN0oAAgBkAFAEIgSyAAsADwCLQBYAAA8ODQwACwALCgkIBwYFBAMCAQkHK0uw6FBYQC4EAQADAQECAAEAACYIAQUAAgYFAgAAJgAGBwcGAAAjAAYGBwAAJAAHBgcAACEFG0A2AAQAAwEEAwAAJgAAAAECAAEAACYIAQUAAgYFAgAAJgAGBwcGAAAjAAYGBwAAJAAHBgcAACEGWbA4KwERIRUhESMRITUhEQEhFSECiwGX%2FmmS%2FmsBlf5rA778QgSy%2FoiI%2FpABcIgBePwlhwAAAQBSA4QCUQZlAC0AgEAQAQAoJiIgFBMQDQAtAS0GBytLsF9QWEArKwEEAwsBAgECHgAEAwEDBAEyBQEAAAMEAAMBACYAAgIBAQAkAAEBDgIgBRtANCsBBAMLAQIBAh4ABAMBAwQBMgUBAAADBAADAQAmAAECAgEBACMAAQECAAAkAAIBAgAAIQZZsDgrATIeAhUUDgIPAT4BOwEyFh0BITU0Nj8BPgM1NCYjIgYHDgEjIiYvAT4BAVo0VTwhGSo2HqIXLxXDFRf%2BAQoM3RksIBM8LS45DggTEQQJBUcPigZlHjZNLyhFPjoepQYIFhRNKw0cDNsZNDU1GzM3MCoOEAEBDGpqAAEAVAN8AlIGZQA9ALJAFgEANjQwLiopKCcfHRgWEA4APQE9CQcrS7BLUFhAQTkBBwYHAQQFFAEDAgMeAAcGBQYHBTIAAgQDBAIDMggBAAAGBwAGAQAmAAUABAIFBAEAJgABAQMBACQAAwMOASAHG0BKOQEHBgcBBAUUAQMCAx4ABwYFBgcFMgACBAMEAgMyCAEAAAYHAAYBACYABQAEAgUEAQAmAAMBAQMBACMAAwMBAQAkAAEDAQEAIQhZsDgrATIeAhUUBx4BFRQOAiMiLgInNzYzMhceAzMyPgI1NC4CIzU%2BATU0JiMiBgcOASMiJi8BPgMBYjNSOyB3QkUqRVswOVQ9Kw83Dw4dCwYSHisgHy8gEBEnQS9XRzowMDkMCBEPBAkFQwcsQVQGZR0zRCiALRNOPjdUOR0ZMUgvGAYXDSAcExQfKBUeKxwOVwE8NDI0LygQDwEBDDVPNRsAAQDEBIsCVQWpAAkAM0AKAAAACQAIBQMDBytLsF9QWEANAAABADUCAQEBEQEgAhtACwIBAQABNAAAACsCWbA4KwEDDgErATc%2BATMCVekOGxVqlA4hIAWp%2Fv4PDfIXFQAAAQB6%2FqkDxQP1AB0BWUASAAAAHQAdGhgSEAwKCQgFAwcHK0uwSVBYQCYOBwIAARQBAgACHgYFAgEBDh8AAAACAQAkAwECAgwfAAQEEAQgBRtLsE1QWEAoDgcCAAEUAQIAAh4AAAACAQAkAwECAgwfAAQEAQAAJAYFAgEBDgQgBRtLsF9QWEAsDgcCAAEUAQMAAh4AAAADAQAkAAMDDB8AAgIMHwAEBAEAACQGBQIBAQ4EIAYbS7BsUFhALg4HAgABFAEDAAIeAAQBBAEAIgAAAAMBACQAAwMPHwYFAgEBAgEAJAACAg8CIAYbS7DoUFhAMg4HAgABFAEDAAIeAAAAAwIAAwEAJgYFAgEAAgQBAgEAJgYFAgEBBAEAJAAEAQQBACEFG0A4DgcCAAUUAQMAAh4GAQUABAUAACMAAAADAgADAQAmAAEAAgQBAgEAJgYBBQUEAQAkAAQFBAEAIQZZWVlZWbA4KwERFBYzMjY3ETMRIyIvAQ4BIyImJx4BFREjIiY1EQEsbGlOijqyaiYKDkONV0pwJwcGWSYpA%2FX9bm14SkIC6%2FwLJW1IRDMuKlcm%2FukoJAUAAAABACr%2FNwUWBZkAEwCiQBIAAAATABIKCQgHBgUEAwIBBwcrS7BfUFhAHQAEAAEABAEyAwEBATMCAQAABQEAJAYBBQULACAEG0uw6FBYQCcABAABAAQBMgMBAQEzBgEFAAAFAQAjBgEFBQAAACQCAQAFAAAAIQUbQDIAAAIEAgAqAAQDAgQDMAADAQIDATAAAQEzBgEFAgIFAQAjBgEFBQIAACQAAgUCAAAhB1lZsDgrARUjESMRIREjESIuAjU0PgIzBRbbnf7rnWimdT8%2FdaZoBZmZ%2BjcFyfo3A109aY5RVo1lOAABAHwBvQGnAugAEwAlQAYQDgYEAgcrQBcAAAEBAAEAIwAAAAEBACQAAQABAQAhA7A4KxM0PgIzMh4CFRQOAiMiLgJ8Fyk2Hh84KBgYKDgfHjYpFwJRHzgoGBgoOB8eNikXFyk2AAABAIT%2BoQHvAAoAHQDDQA4BABkXDw4GBAAdAR0FBytLsAlQWEAhEA0CAAIbAQMAAh4AAgAAAigBBAIAAAMBAiQAAwMQAyAEG0uwFVBYQCAQDQIAAhsBAwACHgACAAI0AQQCAAADAQIkAAMDEAMgBBtLsElQWEAkEA0CAAIbAQMBAh4AAgACNAQBAAEANAABAQMBAiQAAwMQAyAFG0AtEA0CAAIbAQMBAh4AAgACNAQBAAEANAABAwMBAQAjAAEBAwECJAADAQMBAiEGWVlZsDgrFzIeAjMyNjU0LgInNzMHHgEVFA4CIyImJzc2rAYQFiAVKisWKTwmK3AYWlEgOVAwKUofEQb3BwkHIRoTGhIMBY1QFEU2IDMkExEONxIAAQB4A4QCRAZfAA8AokAMDw4NDAsKBwUBAAUHK0uwJFBYQCEJAwIDAQIBHgACAQI0AAEAATQABAQAAAAkAwEAAA4EIAUbS7DoUFhAKwkDAgMBAgEeAAIBAjQAAQABNAMBAAQEAAAAIwMBAAAEAAIkAAQABAACIQYbQDAJAwIDAQIBHgACAQI0AAEAATQAAwAEAAMqAAADBAAAACMAAAAEAAIkAAQABAACIQdZWbA4KxMzETcHBiMiLwE3MxEzFSGtkwRrDA4XCSfebIL%2BaQPZAbgrWAkOOL79elUAAAIASAM8ArEFqQATAB8AYEASFRQBABsZFB8VHwsJABMBEwYHK0uwX1BYQBkFAQIAAQIBAQAlAAMDAAEAJAQBAAARAyADG0AkBAEAAAMCAAMBACYFAQIBAQIBACMFAQICAQEAJAABAgEBACEEWbA4KwEyHgIVFA4CIyIuAjU0PgITMjY1NCYjIgYVFBYBfkZxUCwsUHFGR3JRLCxRckdUU1NUV1NTBakrUHNHSHRRKytRdEhHc1Ar%2Ff1pZGRoaGRkaQAAAgCWAIEDDQOiABIAJQAJQAYlFRAAAgsrNycmNTQ3EzY3JicDJjU0PwETFSUVAycmNTQ3EzY3JicDJjU0PwHsOhwKnw0ODA%2BfChw6%2BQEo%2BTocCp8NDgwPnwocOoEcDRwREQEFGAwLGgEFEREcDRz%2BexcXF%2F57HA0cEREBBRgMCxoBBRERHA0cAAQAZgAABXwFmgAQACAAJgAwAbVAHDAuKykmJSAfHh0cGxgWEhEQDwsJCAcGBAEADQcrS7BfUFhAQBoUEwMGByQBAAkCHgAGBwUHBgUyCAEFAAkABQkAAiYKAQADAQECAAEBACYMAQcHCx8ABAQCAQAkCwECAgwCIAcbS7BsUFhAPRoUEwMGByQBAAkCHgwBBwYHNAAGBQY0CAEFAAkABQkAAiYKAQADAQECAAEBACYABAQCAQAkCwECAg8CIAcbS7BOUFhARhoUEwMGByQBAAkCHgwBBwYHNAAGBQY0AAQJAgQAACMIAQUACQAFCQACJgoBAAMBAQIAAQEAJgAEBAIBACQLAQIEAgEAIQgbS7gD6FBYQEoaFBMDBgwkAQAJAh4ABwwHNAAMBgw0AAYFBjQABAkCBAAAIwgBBQAJAAUJAAImCgEAAwEBAgABAQImAAQEAgEAJAsBAgQCAQAhCRtAXxoUEwMGDCQBAAkCHgAHDAc0AAwGDDQABgUGNAAIBQQFCCoACwECAQsCMgAECQIEAAAjAAUACQAFCQACJgAKAAMBCgMBAiYAAAABCwABAQAmAAQEAgAAJAACBAIAACEMWVlZWbA4KwEzFRQGKwEVIzUhIiYvAQEzJTMRNwcGIyIvATczETMVIQU0NjcDMwUOASsBAT4BOwEFD20ODVJt%2Fs4SFQIKAVZ8%2B4yTBGsMDhcJJ95sgv5pBAcCA%2FHs%2FRATLB1MAzISLiBNAQtBCw%2BwsBAMOQHUOwG4K1gJDji%2B%2FXpVwxMsF%2F651h8WBVwdIAADAGYAAAVdBZoALQA9AEcB5kAeAQBHRUJAPTw7Ojk4NTMvLigmIiAUExANAC0BLQ0HK0uwX1BYQEs3MTADBgcrAQQDCwECAQMeAAYHBQcGBTIABAMBAwQBMggBBQAJAwUJAAImDAEAAAMEAAMBACYLAQcHCx8AAQECAQAkCgECAgwCIAgbS7BsUFhASDcxMAMGBysBBAMLAQIBAx4LAQcGBzQABgUGNAAEAwEDBAEyCAEFAAkDBQkAAiYMAQAAAwQAAwEAJgABAQIBACQKAQICDwIgCBtLsE5QWEBRNzEwAwYHKwEEAwsBAgEDHgsBBwYHNAAGBQY0AAQDAQMEATIIAQUACQMFCQACJgwBAAADBAADAQAmAAECAgEBACMAAQECAQAkCgECAQIBACEJG0u4A%2BhQWEBVNzEwAwYLKwEEAwsBAgEDHgAHCwc0AAsGCzQABgUGNAAEAwEDBAEyCAEFAAkDBQkAAiYMAQAAAwQAAwECJgABAgIBAQAjAAEBAgEAJAoBAgECAQAhChtAYjcxMAMGCysBBAMLAQoBAx4ABwsHNAALBgs0AAYFBjQACAUABQgqAAQDAQMEATIACgECAQoCMgAFAAkDBQkAAiYMAQAAAwQAAwECJgABCgIBAQAjAAEBAgAAJAACAQIAACEMWVlZWbA4KwEyHgIVFA4CDwE%2BATsBMhYdASE1NDY%2FAT4DNTQmIyIGBw4BIyImLwE%2BASUzETcHBiMiLwE3MxEzFSETDgErAQE%2BATsBBGY0VTwhGSo2HqIXLxXDFRf%2BAQoM3RksIBM8LS45DggTEQQJBUcPivyckwRrDA4XCSfebIL%2BaesTLB1MAzISLiBNAuEeNk0vKEU%2BOh6lBggWFE0rDRwM2xk0NTUbMzcwKg4QAQEMamozAbgrWAkOOL79elX9dh8WBVwdIAAEAEQAAAV9BaAAEABOAFQAXgJhQCYSEV5cWVdUU0dFQT87Ojk4MC4pJyEfEU4SThAPCwkIBwYEAQARBytLsENQWEBfSgEMCxgBCQolAQgHUgEABgQeAAwLCgsMCjIABwkICQcIMgAKAAkHCgkBACYACAAGAAgGAQAmDQEAAwEBAgABAQImAAsLBQEAJA8QAgUFCx8ABAQCAQAkDgECAgwCIAobS7BfUFhAY0oBDAsYAQkKJQEIB1IBAAYEHgAMCwoLDAoyAAcJCAkHCDIACgAJBwoJAQAmAAgABgAIBgEAJg0BAAMBAQIAAQECJgAPDwsfAAsLBQEAJBABBQULHwAEBAIBACQOAQICDAIgCxtLsGxQWEBkSgEMCxgBCQolAQgHUgEABgQeAA8FCwUPCzIADAsKCwwKMgAHCQgJBwgyEAEFAAsMBQsBACYACgAJBwoJAQAmAAgABgAIBgEAJg0BAAMBAQIAAQECJgAEBAIBACQOAQICDwIgChtLsOhQWEBtSgEMCxgBCQolAQgHUgEABgQeAA8FCwUPCzIADAsKCwwKMgAHCQgJBwgyEAEFAAsMBQsBACYACgAJBwoJAQAmAAQGAgQAACMACAAGAAgGAQAmDQEAAwEBAgABAQImAAQEAgEAJA4BAgQCAQAhCxtAfEoBDAsYAQkKJQEIB1IBAAYEHgAPBQsFDwsyAAwLCgsMCjIABwkICQcIMgAOAQIBDgIyEAEFAAsMBQsBACYACgAJBwoJAQAmAAQGAgQAACMACAAGAAgGAQAmAA0AAwENAwECJgAAAAEOAAEBACYABAQCAAAkAAIEAgAAIQ1ZWVlZsDgrATMVFAYrARUjNSEiJi8BATMBMh4CFRQHHgEVFA4CIyIuAic3NjMyFx4DMzI%2BAjU0LgIjNT4BNTQmIyIGBw4BIyImLwE%2BAwE0NjcDMwUOASsBAT4BOwEFEG0ODVJt%2Fs4SFQIKAVZ8%2FEIzUjsgd0JFKkVbMDlUPSsPNw8OHQsGEh4rIB8vIBARJ0EvV0c6MDA5DAgRDwQJBUMHLEFUA4ICA%2FHs%2FRQTLB1MAzISLiBNAQtBCw%2BwsBAMOQHUAscdM0QogC0TTj43VDkdGTFILxgGFw0gHBMUHygVHiscDlcBPDQyNC8oEA8BAQw1TzUb%2FFwTLBf%2BudYfFgVcHSAAAgAs%2FpwDAgQFACkAPQDFQA46ODAuJyUiIBMSBgQGBytLsElQWEAzFAEDAQABAAICHgABBQMFAQMyAAMCBQMCMAAFBQQBACQABAQUHwACAgABAiQAAAAWACAHG0uwX1BYQDAUAQMBAAEAAgIeAAEFAwUBAzIAAwIFAwIwAAIAAAIAAQIlAAUFBAEAJAAEBBQFIAYbQDoUAQMBAAEAAgIeAAEFAwUBAzIAAwIFAwIwAAQABQEEBQEAJgACAAACAQAjAAICAAECJAAAAgABAiEHWVmwOCsFDgMjIi4CNTQ%2BBD8BMxcVFA4EFRQeAjMyPgIzMhYXATQ%2BAjMyHgIVFA4CIyIuAgMCH0tYaDxPh2I4LUVSRzMEEnoMLUVPRS0iOk8tPVc8JgwOEQf%2BcRMhLhoaLiITEyIuGhouIRPUHTQoFyxSdktMakw2MDEhmqcMLD4yLzxQOyxFMRoeJB4MCwQQGi4iFBQiLhobLSITEyItAP%2F%2FAAoAAAVJBvYCJgAkAAAABwDaAWsAAP%2F%2FAAoAAAVJBvYCJgAkAAAABwDcAWsAAP%2F%2FAAoAAAVJBtwCJgAkAAAABwDdAXYAAP%2F%2FAAoAAAVJBtICJgAkAAAABwDfAXYAAP%2F%2FAAoAAAVJBvICJgAkAAAABwDbAXYAAP%2F%2FAAoAAAVJBy0CJgAkAAAABwDeAXMAAAAC%2F%2BgAAAbaBZkAEgAYAR5AFBQTEhANDAsKCQgHBgUEAwIBAAkHK0uwX1BYQDUVAQEAAR4AAgADCAIDAAAmAAgABgQIBgAAJgABAQAAACQAAAALHwAEBAUBACQHAQUFDAUgBxtLsGxQWEAzFQEBAAEeAAAAAQIAAQAAJgACAAMIAgMAACYACAAGBAgGAAAmAAQEBQEAJAcBBQUPBSAGG0uw6FBYQDwVAQEAAR4AAAABAgABAAAmAAIAAwgCAwAAJgAIAAYECAYAACYABAUFBAAAIwAEBAUBACQHAQUEBQEAIQcbQEMVAQEAAR4ABwQFBAcFMgAAAAECAAEAACYAAgADCAIDAAAmAAgABgQIBgAAJgAEBwUEAAAjAAQEBQAAJAAFBAUAACEIWVlZsDgrASEVIRMhFSETIRUhAyEDDgErAQEhAw4BBwLdA%2F39EzwCL%2F3kPQJh%2FPwx%2FdSzCyUalAHaAdFeDB0OBZme%2FiSY%2FheeAYj%2BpRQZAhQC8SlFHwAAAQBa%2FqEFCQWpAEsCfEAYAQBHRT08ODYxLyclIB4ZFwYEAEsBSwoHK0uwCVBYQEsbAQMEOgEFBj4ODQMAB0kBCAAEHgADBAYEAwYyAAYFBAYFMAAEBAIBACQAAgIRHwAFBQcBACQABwcVHwEJAgAACAEAJAAICBAIIAkbS7ANUFhASxsBAwQ6AQUGPg4NAwAHSQEIAAQeAAMEBgQDBjIABgUEBgUwAAQEAgEAJAACAhEfAAUFBwEAJAAHBxIfAQkCAAAIAQAkAAgIEAggCRtLsBVQWEBLGwEDBDoBBQY%2BDg0DAAdJAQgABB4AAwQGBAMGMgAGBQQGBTAABAQCAQAkAAICER8ABQUHAQAkAAcHFR8BCQIAAAgBACQACAgQCCAJG0uwSVBYQFIbAQMEOgEFBj4ODQMAB0kBCAEEHgADBAYEAwYyAAYFBAYFMAkBAAcBBwABMgAEBAIBACQAAgIRHwAFBQcBACQABwcVHwABAQgBACQACAgQCCAKG0uwX1BYQE8bAQMEOgEFBj4ODQMAB0kBCAEEHgADBAYEAwYyAAYFBAYFMAkBAAcBBwABMgABAAgBCAEAJQAEBAIBACQAAgIRHwAFBQcBACQABwcVByAJG0uwbFBYQE0bAQMEOgEFBj4ODQMAB0kBCAEEHgADBAYEAwYyAAYFBAYFMAkBAAcBBwABMgACAAQDAgQBACYAAQAIAQgBACUABQUHAQAkAAcHFQcgCBtAVxsBAwQ6AQUGPg4NAwAHSQEIAQQeAAMEBgQDBjIABgUEBgUwCQEABwEHAAEyAAIABAMCBAEAJgAFAAcABQcBACYAAQgIAQEAIwABAQgBACQACAEIAQAhCVlZWVlZWbA4KwUyHgIzMjY1NC4CJzcuAgI1NBI2JDMyFhcHDgEjIi4EIyIOAhUUHgIzMj4CNzYzMh8BDgEPAR4BFRQOAiMiJic3NgKDBhAWIBUqKxYpPCYki%2BKfVmm%2BAQmgnuVZPwcSEQ0dKDZKYkBzv4pNTYW2aUBmV0smERAQDUxT6aIQWlEgOVAwKUofEQb3BwkHIRoTGhIMBXYMdb8BAJmiAQ7Ca2JUWQoNExwgHBNPktKChtKRTA8gMSIPDVNhcAY3FEU2IDMkExEONxIA%2F%2F8ArgAABCEG9gImACgAAAAHANoBNwAA%2F%2F8ArgAABCEG9gImACgAAAAHANwBNwAA%2F%2F8ArgAABCEG3AImACgAAAAHAN0BQgAA%2F%2F8ArgAABCEG8gImACgAAAAHANsBQgAA%2F%2F%2F%2FzAAAAbwG9gImACwAAAAGANr4AAAA%2F%2F8AmgAAAooG9gImACwAAAAGANz4AAAA%2F%2F%2F%2F7wAAAnsG3AImACwAAAAGAN0DAAAA%2F%2F%2F%2F8gAAAngG8gImACwAAAAGANsCAAAAAAIAMgAABdEFmQAQACEA4UASHhwbGhkYFxUQDw4MBAIBAAgHK0uwX1BYQCYFAQAGAQMHAAMAACYABAQBAQAkAAEBCx8ABwcCAQAkAAICDAIgBRtLsGxQWEAkAAEABAABBAEAJgUBAAYBAwcAAwAAJgAHBwIBACQAAgIPAiAEG0uw6FBYQC0AAQAEAAEEAQAmBQEABgEDBwADAAAmAAcCAgcBACMABwcCAQAkAAIHAgEAIQUbQDUAAQAEAAEEAQAmAAUABgMFBgAAJgAAAAMHAAMAACYABwICBwEAIwAHBwIBACQAAgcCAQAhBllZWbA4KxMzESEyBBYSFRQCBgQjIREjJTQuAiMhESEVIREhMj4CMsUCF54BBbpmZrr%2B%2B5796cUE2EiEvHT%2BqwF9%2FoMBVXS8hEgDDAKNZ73%2B%2BKGh%2Fvi8ZwKaMoTQkEz%2BEHL%2BA0yP0AD%2F%2FwCuAAAFOAbSAiYAMQAAAAcA3wHaAAD%2F%2FwBc%2F%2FEF4Qb2AiYAMgAAAAcA2gHjAAD%2F%2FwBc%2F%2FEF4Qb2AiYAMgAAAAcA3AHjAAD%2F%2FwBc%2F%2FEF4QbcAiYAMgAAAAcA3QHuAAD%2F%2FwBc%2F%2FEF4QbSAiYAMgAAAAcA3wHuAAD%2F%2FwBc%2F%2FEF4QbyAiYAMgAAAAcA2wHuAAAAAQB%2BANsEAwRYAAsAB0AECQUBCysJAgcJAScJATcJAQP5%2FqgBYl%2F%2Bnv6bXwFk%2FqdfAVkBWAP2%2Fqj%2Bn2ABYv6cYAFkAVlg%2FqYBWAADAFz%2FkwXhBdoAIQAtADgBEkAONTMqKB4cFxUNCwYEBgcrS7AeUFhANxkBBAIyMSYlHwUFBA4IAgAFAx4AAQABNQADAw0fAAQEAgEAJAACAhEfAAUFAAEAJAAAABIAIAcbS7BfUFhANxkBBAIyMSYlHwUFBA4IAgAFAx4AAwIDNAABAAE1AAQEAgEAJAACAhEfAAUFAAEAJAAAABIAIAcbS7BsUFhANRkBBAIyMSYlHwUFBA4IAgAFAx4AAwIDNAABAAE1AAIABAUCBAEAJgAFBQABACQAAAAVACAGG0A%2BGQEEAjIxJiUfBQUEDggCAAUDHgADAgM0AAEAATUAAgAEBQIEAQAmAAUAAAUBACMABQUAAQAkAAAFAAEAIQdZWVmwOCsBFAIGBCMiJicHDgErARMmAjU0EjYkMzIWFzc%2BATsBBxYSBRQWFwEuASMiDgIFNCYnARYzMj4CBeFmuv77nmy8T2QWOh1Ov3B7ZroBBJ5zyFNSFCAgZKxncPtBS0UCkzyUV3O8hUgD%2BEE8%2FXF0nHS8hEgCzKH%2B88JrMTCIHRoBBGIBILOhAQ3DbDo2bxsX62L%2B6quH00kDgyorTpHShH7JSPyERk2R0QD%2F%2FwCg%2F%2B8FFQb2AiYAOAAAAAcA2gGdAAD%2F%2FwCg%2F%2B8FFQb2AiYAOAAAAAcA3AGdAAD%2F%2FwCg%2F%2B8FFQbcAiYAOAAAAAcA3QGoAAD%2F%2FwCg%2F%2B8FFQbyAiYAOAAAAAcA2wGoAAD%2F%2FwAIAAAE5Ab2AiYAPAAAAAcA3AE5AAAAAgDCAAAEfwWZABAAGwCcQBIAABsZExEAEAAPBwUEAwIBBwcrS7BfUFhAIQACAAUEAgUBACYABAYBAwAEAwEAJgABAQsfAAAADAAgBBtLsGxQWEAjAAIABQQCBQEAJgAEBgEDAAQDAQAmAAEBAAAAJAAAAA8AIAQbQCwAAQIAAQAAIwACAAUEAgUBACYABAYBAwAEAwEAJgABAQAAACQAAAEAAAAhBVlZsDgrAREjETMRMzIeAhUUDgIjJzMyPgI1NCYrAQGDwcHmiMmEQUaHyIHm5lN%2FViypq%2BYBEP7wBZn%2B%2BD90pGVkpnhDmixPbkKJmgABALr%2F8AR2Ba4ASADxQBIBAENCPTslIyAeGRcASAFIBwcrS7AeUFhAKhsBAQMBHgACBAMEAgMyAAQEAAEAJAYBAAARHwADAwEBACQFAQEBEgEgBhtLsF9QWEAuGwEFAwEeAAIEAwQCAzIABAQAAQAkBgEAABEfAAUFDB8AAwMBAQAkAAEBEgEgBxtLsGxQWEAsGwEFAwEeAAIEAwQCAzIGAQAABAIABAEAJgAFBQ8fAAMDAQEAJAABARUBIAYbQDgbAQUDAR4AAgQDBAIDMgAFAwEDBQEyBgEAAAQCAAQBACYAAwUBAwEAIwADAwEBACQAAQMBAQAhB1lZWbA4KwEyHgIVFA4EFRQeBBUUDgIjIiYnNz4BMzIeAjMyPgI1NC4ENTQ%2BBDU0LgIjIg4CFREjETQ%2BAgKhZ5diLytAS0ArNVBdUDU5ZIdPYZ48KQgXERIoN0s1LEYxGjhUYlQ4LUNOQy0ZOFk%2FRG9PK7NFgLQFrjxdbjM8VkIyMDMgJzQtL0ZmTk56VS1FNkQNDhwiHBsuQCU4RjMqOlNCNU8%2FNjxHMCBBNCEqVH5U%2FCYD4GiqekIA%2F%2F8AXP%2FwA3oFqQImAEQAAAAHAEMA3QAA%2F%2F8AXP%2FwA3oFqQImAEQAAAAHAHYA3QAA%2F%2F8AXP%2FwA3oFmQImAEQAAAAHAMUA3QAA%2F%2F8AXP%2FwA3oFiQImAEQAAAAHAMcA3QAA%2F%2F8AXP%2FwA3oFewImAEQAAAAHAGoA3QAA%2F%2F8AXP%2FwA3oF3gImAEQAAAAHAMYA3gAAAAMAXP%2FwBg8EBwBDAFEAXAOiQCZTUgEAWFdSXFNcTUtFRD89ODYzMS4tJSMdGxQSDw0JBwBDAUMQBytLsAlQWEBIQTsCCAcfFwICAwIeAAgHBgcIBjIAAwECAQMCMg0BBgoBAQMGAQEAJg8MAgcHAAEAJAkOAgAAFB8LAQICBAEAJAUBBAQSBCAIG0uwHFBYQEhBOwIIBx8XAgIDAh4ACAcGBwgGMgADAQIBAwIyDQEGCgEBAwYBAQAmDwwCBwcAAQAkCQ4CAAAUHwsBAgIEAQAkBQEEBBUEIAgbS7BNUFhAVEE7AggHHxcCAgMCHgAIBwYHCAYyAAMBAgEDAjINAQYKAQEDBgEBACYPDAIHBwABACQJDgIAABQfAAICBAEAJAUBBAQVHwALCwQBACQFAQQEFQQgChtLsF9QWEBhQTsCCAcfFwICAwIeAAgHBgcIBjIAAwECAQMCMg0BBgoBAQMGAQEAJg8BDAwAAQAkCQ4CAAAUHwAHBwABACQJDgIAABQfAAICBAEAJAUBBAQVHwALCwQBACQFAQQEFQQgDBtLsGxQWEBZQTsCCAcfFwICAwIeAAgHBgcIBjIAAwECAQMCMg8BDAcADAEAIwkOAgAABwgABwEAJg0BBgoBAQMGAQEAJgACAgQBACQFAQQEFR8ACwsEAQAkBQEEBBUEIAobS7CPUFhAXUE7AggHHxcCAgMCHgAIBwYHCAYyAAMBAgEDAjIPAQwHAAwBACMJDgIAAAcIAAcBACYNAQYKAQEDBgEBACYAAgsEAgEAIwALBAQLAQAjAAsLBAEAJAUBBAsEAQAhChtLsMdQWEBkQTsCCAcfFwICAwIeAAgHBgcIBjIAAwoCCgMCMg8BDAcADAEAIwkOAgAABwgABwEAJgABCgYBAQAjDQEGAAoDBgoBACYAAgsEAgEAIwALBAQLAQAjAAsLBAEAJAUBBAsEAQAhCxtLsE5QWEBmQTsCCAcfFwICAwIeAAgHBgcIBjIAAwoCCgMCMg4BAA8BDAcADAEAJgAJAAcICQcBACYAAQoGAQEAIw0BBgAKAwYKAQAmAAsEBQsBACMAAgAEBQIEAQAmAAsLBQEAJAAFCwUBACELG0BnQTsCCAcfFwICAwIeAAgHDQcIDTIAAwoCCgMCMg4BAA8BDAcADAEAJgAJAAcICQcBACYADQABCg0BAQAmAAYACgMGCgEAJgALBAULAQAjAAIABAUCBAEAJgALCwUBACQABQsFAQAhC1lZWVlZWVlZsDgrATIeAhUUBiMhHgMzMj4CMzIWHwEOAyMiJicOAyMiLgI1ND4CNzU0JiMiDgIjIiYvAT4BMzIWFz4BAQ4DFRQWMzI%2BAjUBIg4CByE0LgIEjlKNZzsQGf2NBC5NaUFFXD0mEA4SBi8hV2NqNHW%2FNxtXanc7RXJTLUKT7qxlY0FZQS8XEhsIIFS1cXiSITat%2FrZ7rGwxZFE5Y0kqAbw9YEUpBwH8HzxXBAVAeq9wKR1bh1osHSQdCQg9KDsmE3F0Plg4GSNGakg8dFw7BDJ2fiMqIxMOOVFQZltYZ%2F3hBSM4SCpXUCRKbkoB7ylOcEZBb1AtAAEASv6hA38EBQBIAWdAFgEAREI0Mi8tJSMgHhkXBgQASAFICQcrS7AVUFhARhsBBAI3AQUGOw4NAwAFRgEHAAQeAAMEBgQDBjIABgUEBgUwAAUABAUAMAAEBAIBACQAAgIUHwEIAgAABwECJAAHBxAHIAgbS7BJUFhATBsBBAI3AQUGOw4NAwAFRgEHAQQeAAMEBgQDBjIABgUEBgUwAAUABAUAMAgBAAEEAAEwAAQEAgEAJAACAhQfAAEBBwECJAAHBxAHIAkbS7BfUFhASRsBBAI3AQUGOw4NAwAFRgEHAQQeAAMEBgQDBjIABgUEBgUwAAUABAUAMAgBAAEEAAEwAAEABwEHAQIlAAQEAgEAJAACAhQEIAgbQFMbAQQCNwEFBjsODQMABUYBBwEEHgADBAYEAwYyAAYFBAYFMAAFAAQFADAIAQABBAABMAACAAQDAgQBACYAAQcHAQEAIwABAQcBAiQABwEHAQIhCVlZWbA4KwUyHgIzMjY1NC4CJzcuAzU0PgIzMhYXBw4BIyIuAiMiDgIVFB4CMzI%2BAjMyFh8BDgEPAR4BFRQOAiMiJic3NgGQBhAWIBUqKxYpPCYlU41mOj95snNqpD8vCBAPDyM2TThKck0nKkxtREFUOCQSCxEGMjuqYRFaUSA5UDApSh8RBvcHCQchGhMaEgwFeQtPhLZxccCLTkU%2FQAsMGR4ZNWSOWFyPYTMfJh8JCEFISgg6FEU2IDMkExEONxL%2F%2FwBK%2F%2FIDxwWpAiYASAAAAAcAQwD0AAD%2F%2FwBK%2F%2FIDxwWpAiYASAAAAAcAdgD0AAD%2F%2FwBK%2F%2FIDxwWZAiYASAAAAAcAxQD0AAD%2F%2FwBK%2F%2FIDxwV7AiYASAAAAAcAagD0AAD%2F%2F%2F%2F5AAABhgWpAiYAwgAAAAYAQ9MAAAD%2F%2FwCXAAACKAWpAiYAwgAAAAYAdtMAAAD%2F%2F%2F%2FSAAACNgWZAiYAwgAAAAYAxdIAAAD%2F%2F%2F%2FhAAACKQV7AiYAwgAAAAYAatMAAAAAAgBM%2F%2FMEBQWGADQASAB9QA42NUA%2BNUg2SC4sJCIFBytLsGxQWEAqOjACAgMBHjQzGRMSDwYHARwAAQADAgEDAQAmBAECAgABACQAAAAVACAFG0A0OjACAgMBHjQzGRMSDwYHARwAAQADAgEDAQAmBAECAAACAQAjBAECAgABACQAAAIAAQAhBlmwOCsBLgE1ND8BLgEnLgE1ND8BHgEXNxcWFRQPAR4DFRQOAiMiLgI1ND4CMzIWFy4BJwcTMj4CNy4DIyIOAhUUHgIBoQQFF2ctZTkSGQUUYLRRpyMIFmE8Y0YnPnu3eGKqfUg%2BdKVoZLFBFHVeuF9Hc1EuAxA0S2M%2BS3FMJy5QaQQpBw0GFg9IFCIOBRsXDw4%2BEDwwejkNCxUQQzF8m7luj%2BSgVkJ7snBep35KVleIvkCH%2FIw2baVvK1E%2FJTJXd0RRf1Yt%2F%2F8AkgAAA90FiQImAFEAAAAHAMcBAgAA%2F%2F8ASP%2FyBA4FqQImAFIAAAAHAEMA%2BwAA%2F%2F8ASP%2FyBA4FqQImAFIAAAAHAHYA%2BwAA%2F%2F8ASP%2FyBA4FmQImAFIAAAAHAMUA%2BwAA%2F%2F8ASP%2FyBA4FiQImAFIAAAAHAMcA%2BwAA%2F%2F8ASP%2FyBA4FewImAFIAAAAHAGoA%2BwAAAAMAZAC9BCIEgAADABcAKwBBQA4oJh4cFBIKCAMCAQAGBytAKwACAAMAAgMBACYAAAABBAABAAAmAAQFBQQBACMABAQFAQAkAAUEBQEAIQWwOCsTIRUhATQ%2BAjMyHgIVFA4CIyIuAhE0PgIzMh4CFRQOAiMiLgJkA778QgFiEyEtGxotIhQUIi0aGy0hExMhLRsaLSIUFCItGhstIRMC44cBphouIhQUIi4aGy0iExMiLf1TGi4iFBQiLhobLSITEyItAAADAED%2FtAQtBEkAIQArADUBK0ASLSwsNS01KCYhHxoYEA4JBwcHK0uwCVBYQDwcAQQCNDMlJAAFBQQLAQAFAx4RAQUBHQADAgM0AAEAATUABAQCAQAkAAICFB8GAQUFAAEAJAAAABIAIAgbS7BfUFhAPBwBBAI0MyUkAAUFBAsBAAUDHhEBBQEdAAMCAzQAAQABNQAEBAIBACQAAgIUHwYBBQUAAQAkAAAAFQAgCBtLsGxQWEA6HAEEAjQzJSQABQUECwEABQMeEQEFAR0AAwIDNAABAAE1AAIABAUCBAEAJgYBBQUAAQAkAAAAFQAgBxtARBwBBAI0MyUkAAUFBAsBAAUDHhEBBQEdAAMCAzQAAQABNQACAAQFAgQBACYGAQUAAAUBACMGAQUFAAEAJAAABQABACEIWVlZsDgrAR4BFRQOAiMiJicHDgErATcuATU0PgIzMhYXNz4BOwEBFBcBJiMiDgIBMj4CNTQnARYDkD1CQ32zb0yDNjcWOx1DkUJGRH6zb0%2BHOEQUICBa%2FMk7AbRJb0x0TygBN0tzTyg0%2Fk9GA3REv3Z4wIhJIiBKHRnERcJ8d8GISiYjWxsX%2FbGgYQJOODZkkf4kNWSPWpdg%2FbcwAP%2F%2FAHr%2F8APFBakCJgBYAAAABwBDAPUAAP%2F%2FAHr%2F8APFBakCJgBYAAAABwB2APUAAP%2F%2FAHr%2F8APFBZkCJgBYAAAABwDFAPUAAP%2F%2FAHr%2F8APFBXsCJgBYAAAABwBqAPUAAP%2F%2FAA7%2BqQPwBakCJgBcAAAABwB2AOQAAAACAJL%2BqQQPBcEAFAAjAX5AFhYVAAAdGxUjFiMAFAAUEQ8HBQIBCAcrS7AJUFhAMhkYAwMFBBMBAgUCHgAAAA0fBwEEBAEBACQAAQEUHwAFBQIBACQAAgISHwYBAwMQAyAHG0uwSVBYQDIZGAMDBQQTAQIFAh4AAAANHwcBBAQBAQAkAAEBFB8ABQUCAQAkAAICFR8GAQMDEAMgBxtLsF9QWEA0GRgDAwUEEwECBQIeBwEEBAEBACQAAQEUHwAFBQIBACQAAgIVHwYBAwMAAAAkAAAADQMgBxtLsGxQWEAyGRgDAwUEEwECBQIeAAEHAQQFAQQBACYABQUCAQAkAAICFR8GAQMDAAAAJAAAAA0DIAYbS7CNUFhAMBkYAwMFBBMBAgUCHgABBwEEBQEEAQAmAAUAAgMFAgEAJgYBAwMAAAAkAAAADQMgBRtAORkYAwMFBBMBAgUCHgAAAQMAAAAjAAEHAQQFAQQBACYABQACAwUCAQAmAAAAAwAAJAYBAwADAAAhBllZWVlZsDgrExEzET4BMzIeAhUUDgIjIiYnEQEiBgcRHgEzMjY1NC4CkrI%2FpGlXjmQ2PHCjZl%2BEMwERV4M3MXVIjZgjQmD%2BqQcY%2FaFKWUKDwX5wwY1RRT%2F%2BMwTOUEn%2BFkI2yrtjjlsq%2F%2F8ADv6pA%2FAFewImAFwAAAAHAGoA5AAAAAEApgAAAVgD9QADAFlACgAAAAMAAwIBAwcrS7BfUFhADQIBAQEOHwAAAAwAIAIbS7BsUFhADwIBAQEAAAAkAAAADwAgAhtAGQIBAQAAAQAAIwIBAQEAAAAkAAABAAAAIQNZWbA4KwERIxEBWLID9fwLA%2FUAAgBc%2F%2FIIJwWpABwAMAIyQBoAAC0rIyEAHAAcGRcPDQoJCAcGBQQDAgELBytLsB5QWEAzGwEBAAsBAwICHgABAAIDAQIAACYIAQAABgEAJAoHAgYGER8JAQMDBAEAJAUBBAQMBCAGG0uwIlBYQD8bAQEACwEDAgIeAAEAAgMBAgAAJggBAAAGAQAkAAYGER8IAQAABwAAJAoBBwcLHwkBAwMEAQAkBQEEBAwEIAgbS7AsUFhASxsBAQALAQMCAh4AAQACAwECAAAmCAEAAAYBACQABgYRHwgBAAAHAAAkCgEHBwsfCQEDAwQAACQABAQMHwkBAwMFAQAkAAUFFQUgChtLsDBQWEBJGwEBAAsBAwICHgABAAIDAQIAACYACAgGAQAkAAYGER8AAAAHAAAkCgEHBwsfCQEDAwQAACQABAQMHwkBAwMFAQAkAAUFFQUgChtLsF9QWEBHGwEBAAsBAwICHgABAAIDAQIAACYACAgGAQAkAAYGER8AAAAHAAAkCgEHBwsfAAMDBAAAJAAEBAwfAAkJBQEAJAAFBRUFIAobS7BsUFhAQxsBAQALAQMCAh4ABgAIAAYIAQAmCgEHAAABBwAAACYAAQACAwECAAAmAAMDBAAAJAAEBA8fAAkJBQEAJAAFBRUFIAgbQEobAQEACwEDAgIeAAYACAAGCAEAJgoBBwAAAQcAAAAmAAEAAgMBAgAAJgAJBAUJAQAjAAMABAUDBAAAJgAJCQUBACQABQkFAQAhCFlZWVlZWbA4KwEVIREhFSERIRUhNQ4BIyIuAQI1NBI%2BATMyFhc1AzQuAiMiDgIVFB4CMzI%2BAggn%2FVACLf3TArD8pFT%2BoY7qqFxcqOqOof5UF0B3qWhoqXhBQXipaGipd0AFmZ7%2BJJj%2BF57weIZrwQENoaEBDcNsh3nw%2FTOE05RPT5TThITTk05Ok9MAAwBI%2F%2FIGdQQFADAAQABLAmRAJEJBMjEBAEdGQUtCSzo4MUAyQCwqIiAcGhQSDw0JBwAwATAOBytLsAlQWEA%2BLgEKCB4WAgIDAh4AAwECAQMCMgAKAAEDCgEBACYNCQIICAABACQGCwIAABQfDAcCAgIEAQAkBQEEBBIEIAcbS7A2UFhAPi4BCggeFgICAwIeAAMBAgEDAjIACgABAwoBAQAmDQkCCAgAAQAkBgsCAAAUHwwHAgICBAEAJAUBBAQVBCAHG0uwX1BYQEsuAQoIHhYCAgMCHgADAQIBAwIyAAoAAQMKAQEAJg0BCQkAAQAkBgsCAAAUHwAICAABACQGCwIAABQfDAcCAgIEAQAkBQEEBBUEIAkbS7BsUFhAQy4BCggeFgICAwIeAAMBAgEDAjINAQkIAAkBACMGCwIAAAgKAAgBACYACgABAwoBAQAmDAcCAgIEAQAkBQEEBBUEIAcbS7BOUFhATi4BCggeFgICAwIeAAMBAgEDAjINAQkIAAkBACMGCwIAAAgKAAgBACYACgABAwoBAQAmDAcCAgQEAgEAIwwHAgICBAEAJAUBBAIEAQAhCBtLuAPoUFhAVC4BCggeFgICAwIeAAMBAgEDAjINAQkIAAkBACMGCwIAAAgKAAgBACYACgABAwoBAQAmAAIHBAIBACMMAQcEBAcBACMMAQcHBAEAJAUBBAcEAQAhCRtAVS4BCggeFgICAwIeAAMBAgEDAjILAQANAQkIAAkBACYABgAICgYIAQAmAAoAAQMKAQEAJgACBwQCAQAjDAEHAAUEBwUBACYAAgIEAQAkAAQCBAEAIQlZWVlZWVmwOCsBMh4CFRQGIyEeAzMyPgIzMh8BDgMjIiYnDgEjIi4CNTQ%2BAjMyFhc%2BAQEyNjU0LgIjIg4CFRQWASIOAgchNC4CBPRSjWc7EBn9jQQuTWlBPVlALRIVDDMhV2NqNHe%2FNzbBiWSkdUBAd6dmg741Mrv9p4uIIkRoRUdoRSKJA2U9YEUqBwH8HzxXBAVAeq9wKR1bh1osHyQfEUEoOyYTc3dwekmIwHh3wYhKeW5pfvx4ybRaj2I0NGKPWrTJAwUpTnBGQW9QLQAAAQAABJECZAWZAA0AW0AIDQwLCQIAAwcrS7BfUFhAEwUBAAIBHgEBAAIANQACAgsCIAMbS7DoUFhAEQUBAAIBHgACAAI0AQEAACsDG0AVBQEBAgEeAAIBAjQAAQABNAAAACsEWVmwOCsBIyIvAg8BDgErARMzAmR3FROAERCBBhYMe9%2BmBJEOfhERfgUJAQgAAgBqBGsB%2BwXeABMAHwBTQAoeHBgWEA4GBAQHK0uwHFBYQBcAAgABAgEBACUAAwMAAQAkAAAADQMgAxtAIQAAAAMCAAMBACYAAgEBAgEAIwACAgEBACQAAQIBAQAhBFmwOCsTND4CMzIeAhUUDgIjIi4CNxQWMzI2NTQmIyIGaiA3SCgpSTggIDhJKShINyBkNi8tNzctLzYFIypEMhsbMkQqKUQwGxswRCksODgsLTg4AAEAEgSuAlkFiQAaANNAEgEAFxUREA8NCggEAwAaARoHBytLsC5QWEAaBgEABAECAAIBACUAAwMBAQAkBQEBAQsDIAMbS7BNUFhAJQYBAAMCAAEAIwUBAQADAgEDAQAmBgEAAAIBACQEAQIAAgEAIQQbS7BwUFhALAABBQAFAQAyBgEAAwIAAQAjAAUAAwIFAwEAJgYBAAACAQAkBAECAAIBACEFG0AzAAEFAAUBADIABAMCAwQCMgYBAAMCAAEAIwAFAAMEBQMBACYGAQAAAgEAJAACAAIBACEGWVlZsDgrATI2NzMUDgIjIi4CIyIHIzQ%2BAjMyHgIBoSQnAWwZL0EoIz02MBdIAm8aMEInIz02LwUtKiwvTzgfHSIdWDBPOR8dIh0AAAEAnAINA7wCjwADACVABgMCAQACBytAFwAAAQEAAAAjAAAAAQAAJAABAAEAACEDsDgrEyEVIZwDIPzgAo%2BCAAABAJwCDQXOAo8AAwAlQAYDAgEAAgcrQBcAAAEBAAAAIwAAAAEAACQAAQABAAAhA7A4KxMhFSGcBTL6zgKPggAAAQA6A%2FQBJwX5ABgAB0AEBgABCysTLgE1NDY3Fx4BFRQHDgMVFBYXFhUUB3IdG1lQNwgFChAeGA4TFwcbA%2FQwYTBapUUiBQwGDgoULDE2HiBEJgsMGAoAAAEAWgPfAUYF5AAYAAdABAAGAQsrAR4BFRQGBycuATU0Nz4DNTQmJyY1NDcBDx0aWU83CAUKEB4YDhMXBxsF5DBgMFulRSIFDAYOChMtMTYeIEQmCwsYCwABAFr%2B7AFGAPEAGAAHQAQABgELKyUeARUUBgcnLgE1NDc%2BAzU0JicmNTQ3AQ8dGllPNwgFChAeGA4TFwcb8TBgMFulRSIFDAYOChMtMTYeIEQmCwsYCwAAAgA6A%2FQCVwX5ABgAMQAJQAYfGQYAAgsrEy4BNTQ2NxceARUUBw4DFRQWFxYVFAcXLgE1NDY3Fx4BFRQHDgMVFBYXFhUUB3IdG1lQNwgFChAeGA4TFwcbwx0bWVA3CAUKEB4YDhMXBxsD9DBhMFqlRSIFDAYOChQsMTYeIEQmCwwYCiwwYTBapUUiBQwGDgoULDE2HiBEJgsMGAoAAgBaA98CdgXkABgAMQAJQAYZHwAGAgsrAR4BFRQGBycuATU0Nz4DNTQmJyY1NDclHgEVFAYHJy4BNTQ3PgM1NCYnJjU0NwEPHRpZTzcIBQoQHhgOExcHGwGdHRpZTzcIBQoQHhgOExcHGwXkMGAwW6VFIgUMBg4KEy0xNh4gRCYLCxgLLDBgMFulRSIFDAYOChMtMTYeIEQmCwsYCwACAFr%2B7AJ2APEAGAAxAAlABhkfAAYCCyslHgEVFAYHJy4BNTQ3PgM1NCYnJjU0NyUeARUUBgcnLgE1NDc%2BAzU0JicmNTQ3AQ8dGllPNwgFChAeGA4TFwcbAZ0dGllPNwgFChAeGA4TFwcb8TBgMFulRSIFDAYOChMtMTYeIEQmCwsYCywwYDBbpUUiBQwGDgoTLTE2HiBEJgsLGAsAAAEA0ADgA7cDyAATADxABhAOBgQCBytLsBdQWEAOAAEBAAEAJAAAAA4BIAIbQBcAAAEBAAEAIwAAAAEBACQAAQABAQAhA1mwOCsTND4CMzIeAhUUDgIjIi4C0Dtkh0xNiGU7O2WITUyHZDsCU02IZTs7ZYhNTYdkOztkhwADAFj%2F8QVWAOwAEwAnADsAnUAOODYuLCQiGhgQDgYEBgcrS7BfUFhAEgQCAgAAAQEAJAUDAgEBEgEgAhtLsGxQWEASBAICAAABAQAkBQMCAQEVASACG0uw6FBYQB0EAgIAAQEAAQAjBAICAAABAQAkBQMCAQABAQAhAxtAKwAAAgEAAQAjAAQABQMEBQEAJgACAAMBAgMBACYAAAABAQAkAAEAAQEAIQVZWVmwOCs3ND4CMzIeAhUUDgIjIi4CJTQ%2BAjMyHgIVFA4CIyIuAiU0PgIzMh4CFRQOAiMiLgJYEyEuGhouIhMTIi4aGi4hEwQFEyEuGhouIhMTIi4aGi4hE%2F39EyEuGhouIhMTIi4aGi4hE24aLiIUFCIuGhstIhMTIi0bGi4iFBQiLhobLSITEyItGxouIhQUIi4aGy0iExMiLQABAIoAgQHZA6IAFAAHQAQCFAELKxM1ExceARUUBwMGBxYXEx4BFRQPAYr5Og4OCp8ODg8NnwUFHDoCBhcBhRwHFg0REP77GA0OFv77CBIIHA0cAAABAJYAgQHlA6IAEgAHQAQSAgELKwEVAycmNTQ3EzY3JicDJjU0PwEB5fk6HAqfDQ4MD58KHDoCHRf%2BexwNHBERAQUYDAsaAQURERwNHAAB%2F0QAAAMjBZkACQBCQAYJBwQCAgcrS7BfUFhADAABAQsfAAAADAAgAhtLsGxQWEAMAAEAATQAAAAPACACG0AKAAEAATQAAAArAllZsDgrJw4BKwEBPgE7ARQTLB1MAzISLiBNNR8WBVwdIAABACL%2F8QRyBacARwGNQB5HRkA%2FPj05NzIwKyknJSIhGxkWFRMRDgwHBQEADgcrS7BfUFhATAkBAgM1AQgJAh4AAgMAAwIAMgAJBwgHCQgyBAEADQEFBgAFAQAmDAEGCwEHCQYHAQAmAAMDAQEAJAABAREfAAgICgEAJAAKChIKIAkbS7BsUFhASgkBAgM1AQgJAh4AAgMAAwIAMgAJBwgHCQgyAAEAAwIBAwEAJgQBAA0BBQYABQEAJgwBBgsBBwkGBwEAJgAICAoBACQACgoVCiAIG0uw6FBYQFMJAQIDNQEICQIeAAIDAAMCADIACQcIBwkIMgABAAMCAQMBACYEAQANAQUGAAUBACYMAQYLAQcJBgcBACYACAoKCAEAIwAICAoBACQACggKAQAhCRtAYwkBAgM1AQgJAh4AAgMAAwIAMgAJBwgHCQgyAAEAAwIBAwEAJgAAAA0FAA0AACYABAAFBgQFAQAmAAwACwcMCwAAJgAGAAcJBgcBACYACAoKCAEAIwAICAoBACQACggKAQAhC1lZWbA4KxMzPgMzMhYXBw4BIyIuAiMiBgchFRQGIyEOARUcARchFRQGIyEeATMyPgQzMhYfAQ4BIyIuAicjNTMmNDU0NjcjIpMUX424bIa%2BRj0IEA4RJT5hS5LBIAIjGxj%2BBAEBAQHTHBj%2BahzAkjZSPCsgGQwIDAhLRtCPdLqIVxCOhgEBAYcDg37Lj0xkWEQJDSYuJsjANxIdFCgVEB4POBEdzs4VICUgFQcHRmZxT5PTg2YPHhAUKRQAAgBAA0kFKQWZAB4AJgDnQBgfHx8mHyYlJCMiISAcGhkYFBENDAsJCgcrS7BfUFhANRcWDw4DBQIFAR4AAgUBBQIBMgcBBQUAAQAkCQgEAwAACx8GAwIBAQABACQJCAQDAAALASAGG0uw6FBYQDQXFg8OAwUCBQEeAAIFAQUCATIJCAQDAAcBBQIABQAAJgkIBAMAAAEAACQGAwIBAAEAACEFG0BMFxYPDgMFAgUBHgAHCAUFByoAAgUGBQIGMgAGAwUGAzAAAAQBAAEAIwkBCAAFAggFAAAmAAQAAwEEAwAAJgAAAAEAACQAAQABAAAhCVlZsDgrAR4BFz4BNxM%2BATsBESMRNwMGKwEiJwMXESMRMzIWFycVIxEjESM1A8MGCwQFCAipCRAQam4Jtw0fEh8MuAhuahEOC%2FS0frQEVQ4ZDg4ZDgEvDQj9sAFtS%2F6wHBwBTUj%2BkwJQCA0Vaf4ZAedpAAABAJQCXAPwAuMAAwAlQAYDAgEAAgcrQBcAAAEBAAAAIwAAAAEAACQAAQABAAAhA7A4KxMhFSGUA1z8pALjhwAAAQAaAAADywW%2FACEBbUAUAAAAIQAhIB8eHRwbGBMODAcGCAcrS7AyUFhALREQAgIBAQEEBQIeAAICAQEAJAABAQ0fAAUFAAAAJAMBAAAOHwcGAgQEDAQgBhtLsF9QWEArERACAgEBAQQFAh4DAQAABQQABQAAJgACAgEBACQAAQENHwcGAgQEDAQgBRtLsGxQWEArERACAgEBAQQFAh4DAQAABQQABQAAJgACAgEBACQAAQENHwcGAgQEDwQgBRtLsMZQWEArERACAgEBAQQFAh4HBgIEBQQ1AwEAAAUEAAUAACYAAgIBAQAkAAEBDQIgBRtLsOhQWEA1ERACAgEBAQQFAh4HBgIEBQQ1AAEAAgABAgEAJgMBAAUFAAAAIwMBAAAFAAAkAAUABQAAIQYbQEEREAICAQEBBgUCHgAAAgMCAAMyBwEGBQQFBgQyAAQEMwABAAIAAQIBACYAAwUFAwAAIwADAwUAACQABQMFAAAhCFlZWVlZsDgrMxEnLgE9ATM1ND4CMzIWFwcOASMiJiMiBh0BIREjESERunAVG6A6dK1zJk8dBgIUEwsYD7GhAmSy%2FlQDXQ0FFRRJOF2bcD4KCl0NBwGTlDP8HwNg%2FKAAAAEAGgAAA%2FIFtAAfAaJAFgAAAB8AHx4dHBsYFBMSEQ8ODAcGCQcrS7AmUFhAKQEBAwYBHgAEBAEBACQCAQEBDR8ABgYAAAAkBQEAAA4fCAcCAwMMAyAGG0uwMlBYQC0BAQMGAR4AAgIRHwAEBAEBACQAAQENHwAGBgAAACQFAQAADh8IBwIDAwwDIAcbS7BfUFhAKwEBAwYBHgUBAAAGAwAGAAAmAAICER8ABAQBAQAkAAEBDR8IBwIDAwwDIAYbS7BsUFhALQEBAwYBHgUBAAAGAwAGAAAmAAQEAQEAJAABAQ0fAAICAwAAJAgHAgMDDwMgBhtLsKRQWEAqAQEDBgEeBQEAAAYDAAYAACYAAggHAgMCAwAAJQAEBAEBACQAAQENBCAFG0uw6FBYQDQBAQMGAR4AAgQDAgEAIwABAAQAAQQBACYFAQAABgMABgAAJgACAgMAACQIBwIDAgMAACEGG0BCAQEHBgEeAAAEBQQABTIIAQcGAwYHAzIAAgQDAgEAIwABAAQAAQQBACYABQAGBwUGAAAmAAICAwAAJAADAgMAACEIWVlZWVlZsDgrMxEnLgE9ATM1ND4CMzIWOwERIxEuASMiBh0BIRUhEbpwFRugNGicaFOZSGSyNm0ogowBCP7%2BA10NBRUUSTZUl3BCDfpZBSoCBpWGNoH8oAAAAf%2FUBgoBxAb2AAkAHUAKAQAGBAAJAQkDBytACwIBAAEANAABASsCsDgrEzIWHwEjIiYnJZ0gIBTTixUYEf7ZBvYNFMsHDNkAAv%2FwBhYCdgbyABMAJwBWQAokIhoYEA4GBAQHK0uw6FBYQBoDAQEAAAEBACMDAQEBAAEAJAIBAAEAAQAhAxtAIQABAwABAQAjAAMAAgADAgEAJgABAQABACQAAAEAAQAhBFmwOCsTFA4CIyIuAjU0PgIzMh4CBRQOAiMiLgI1ND4CMzIeAswSHikXFSceEhIeJxUXKR4SAaoSHigWFygeEREeKBcWKB4SBoIWJx4RER4nFhcpHhISHikXFiceEREeJxYXKR4SEh4pAAEAogYKApIG9gALAB1ACgAAAAsACgUDAwcrQAsCAQEAATQAAAArArA4KwEFDgErATc%2BAzMCkv7aERoVitMKERIWEQb22AwIywoMCAMAAAH%2F7AYKAngG3AAQAD9ACBAPDgwCAAMHK0uw6FBYQBEHAQACAR4AAgACNAEBAAArAxtAFQcBAQIBHgACAQI0AAEAATQAAAArBFmwOCsBIyImLwEmJwYPAQ4BKwE3MwJ4hwwcCYIIBAgEggkcDIfusAYKBwZfBAQGAl8GB9IAAAIAdgXNAfEHLQATAB8AM0AKHhwYFhAOBgQEBytAIQAAAAMCAAMBACYAAgEBAgEAIwACAgEBACQAAQIBAQAhBLA4KxM0PgIzMh4CFRQOAiMiLgI3FBYzMjY1NCYjIgZ2HzNEJidFNR4eNUUnJkQzH1k2Ly03Ny0vNgZ7J0IvGhovQicmQC4aGi5AJis5OSstODgAAQAaBggCVgbSABsAsEASAQAYFhIRDw0KCAQDABsBGwcHK0uwW1BYQCUGAQADAgABACMFAQEAAwIBAwEAJgYBAAACAQAkBAECAAIBACEEG0uwcFBYQCwAAQUABQEAMgYBAAMCAAEAIwAFAAMCBQMBACYGAQAAAgEAJAQBAgACAQAhBRtAMwABBQAFAQAyAAQDAgMEAjIGAQADAgABACMABQADBAUDAQAmBgEAAAIBACQAAgACAQAhBllZsDgrATI2NzMUDgIjIi4CIyIGByM0PgIzMh4CAasjJQFiFio%2BKCNAOzQYIiUBZBcrPycjQDo0Bn8pJStINR0aHxorJCtJNB4aHxoA%29%20format%28%27truetype%27%29%3B%0A%7D%0A%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Source%20Code%20Pro%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20400%3B%0Afont%2Ddisplay%3A%20swap%3B%0Asrc%3A%20url%28data%3Afont%2Fttf%3Bbase64%2CAAEAAAAQAQAABAAAR0RFRg33DYwAAAJgAAAAmEdQT1Omq6FhAAAQUAAABO5HU1VC1YXIDQAADSAAAAMuT1MvMlzqs6UAAAIAAAAAYFNUQVTn3ctFAAABuAAAAEhjbWFwcw5UEQAAAvgAAAJSZ2FzcAAAABAAAAEUAAAACGdseWYfrHNYAAAVQAAAQs5oZWFkGy7agQAAAYAAAAA2aGhlYQY%2FATUAAAFcAAAAJGhtdHhEej5eAAAFTAAAAlZsb2NhW1NLfAAAB6QAAAJWbWF4cAE5AMUAAAEcAAAAIG5hbWVlaol3AAAJ%2FAAAAyJwb3N0%2F7gAMwAAATwAAAAgcHJlcGgGjIUAAAEMAAAAB7gB%2F4WwBI0AAAEAAf%2F%2FAA8AAQAAASoAVAAFAG4ABgABAAAAAAAAAAAAAAAAAAMAAgADAAAAAAAA%2F7UAMgAAAAEAAAAAAAAAAAAAAAAAAAAAAAEAAAPY%2Fu8AAAJY%2F%2Fj%2F7AJsAAEAAAAAAAAAAAAAAAAAAAABAAEAAAABBJzB7oQHXw889QADA%2BgAAAAA3BxzpAAAAADdlx6g%2F%2Fj%2B9gJsA8gAAAAGAAIAAAAAAAAAAQABAAgAAgAAABQAAgAAACQAAndnaHQBJQAAaXRhbAFDAAEAFAAEAAMAAQACAUQAAAAAAAEAAAADAAAAAgACAZAAAAK8AAAABAJYAZAABQAAAooCWAAAAEsCigJYAAABXgAyAR4AAAILAwkDBAMCAgQAAABnAAAAAwAAAAAAAAAAQURCTwDAACD%2B%2FwPY%2Fu8AAAQkAcZgAAGfAAAAAAHeApQAAAAgAAMAAQAAAC4AAAAAABIAAAAAAAAAAgAEAQYBCwABAQ4BEQABARMBFgABAR0BJQABAAIAEQACADUAAQA3ADcAAQA6ADwAAQA%2FAD8AAQBMAE4AAQBUAFQAAQBYAFgAAQBbAF0AAQBgAGAAAQBoAGgAAQBuAHAAAQB4AHoAAQEGAQsAAwEOAREAAwETARYAAwEZARkAAwEcASUAAwAAAAIAAAADAAAAFAADAAEAAAAUAAQCPgAAAFAAQAAFABAALwA5AEAAWgBgAHoAfgC%2FAMsA3wDrAP8BMQFTArwCxgLaAtwDAQMEAwkDIwMpIBQgGiAeICIgJiAzIDogRCB0IKwhIiGRIZMiEiIV%2Fv%2F%2F%2FwAAACAAMAA6AEEAWwBhAHsAoADAAMwA4ADsATEBUgK7AsYC2gLcAwADAwMIAyMDKSATIBggHCAiICYgMiA5IEQgdCCsISIhkSGTIhIiFf7%2F%2F%2F8AAABOAAD%2FwQAA%2F7sAAAAA%2F3YAAP93AAD%2FNwAA%2FkH%2BOv4q%2FiUAAAAAAAD99v3z4IwAAAAA4IDgZuDF4GDgoOBF4Dbfkd9p32je2t7QAioAAQBQAAAAbAAAAHYAAAB%2BAIQAAADAAAAA5AAAAQgAAAAAAAAAAAECAQQBBgAAAAAAAAECAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAjQCSALUA3wDnAH0AkQCkAKUArgDrAIkAnQCIAKoAigCLAPAA7wDxAI8AtACmAKwApwDzAKMA%2FgCoAKsAqQD0ASYAjgDjAOAA3gDhAK0ArwECALEA2gCbAPUAngCyAQMA9gDyALcAuAD%2FAPkAsAChAQUAtgDbAJwA6ADpAOoAkABDAEQARQBGAFQARwBIAEkASgBLAEwA7QBNAE8AUABRAFIAUwBVAHEAZABlAGYAZwB4AGkAagBrAGwAbQBuAO4AbwByAHMAdAB1AHYAeQB3AE4AcAEGAQkBDgEQARMBFQCTAJQAlwCVAJYAmAAAAlgAPgAAACAAYwBBAFcAcgCFADUATwBfAFEAYgCGAEgAUgAwAGYAMABkAEMAKgBPACsACgA2ACYAQQBRAF0AUAA8AEQAZwBIAF0AWgA3AGoAUQA6AF0APABdADwAkgBHAEUATQAzAAgAQAAxAEcAIAAgACAAIAAgACD%2F%2FwBBAHIAcgByAHIANQBfAF8AXwBfAFIAMAAwADAAMAAwACQAIQBPAE8ATwBPACYADABlAEQAUQBRAFEAUQBRAFEAEQBQAEQARABEAEQASABaAFoAWgBaAFoAXQA8ADwAPAA8ADwAPAALAFgATQBNAE0ATQAxADEAPABdADf%2F%2BABUACoARwBhAEUAOQAnADgATQBGAEQAQwDbAMUA2wDFACAA4wDjAG0AeQD1AIIA0QDZAF8AZwDZAGcAxQDTAFIAYABVAFUAUAAAANsAlwA8ANAAegDhAGIAeABjAGMBBwBjAQcAVABbAEgAHgBw%2F%2FsAMQBXAK8AkgCOAJQArwCSAI4AlAChANAArQCsAKwArACwALcArwCtAOwA1QD7APQAoQDQAK0ArACsAKwAsAC3AK8ArQDsANUA%2BwD0AKMAjgCjAI4AOgBVAE0ANQA6AHEAHAAcABwAGwAcABwAHwBVAFUAZgBVAFUAeABrAFUAbwBMAFUArwEBAKgAVAAhACEA0QDZAKQA7ACRAH8AlACnAL4AzQCkALEA0QDsAOsBCQCRAJgAfwB7AKcApgDqAJQAngDoAOgAvgDLAOoAzQDNAQkAngCYAIsAngCYAJEAkwCeAJgAAAAAAAAAAAAAAAAAKgAqAEwAgQCxANQA6gD%2BATEBSAFdAX4BmgGpAdkB%2BwItAlAClwLBAwUDFgM8A1gDlQPCA%2BAD9gQ2BG4EnQTSBQoFLwWkBccF0gXdBfkGGAZMBm4GoAbYBw4HLgduB5YHuAfVCA0IOAhoCH4IiQiUCJ8Iqgi1CMAI5QjwCPsJBgkRCRwJJwkyCT0JSAlTCV4JaQl0CX8JigmVCc8J%2FAoHChIKHQooCjMKXwqDCqoKtQrACssK1grhCuwLUgtdC2gLcwt%2BC4kLlAufC6oLtQvAC88L2gvlC%2FAL%2BwwGDBEMSwylDPAM%2Bw0GDRENHA0nDTINeA2xDdQOGw5YDrIO8A8IDzQPeA%2BYD9AQFBAuEIUQyRDfEQMRDxEbEU8RcBGREcoSBBIVEiASRBJnEnISfRKGEpMSpRK2EsESzBLUEtwS6BL0Ev0TGRMlE0ATWhNrE3wTwBQEFBMUIBQvFEMUYBTCFN8VNhWFFbAWBRYnFjAWORZCFksWZBaLFscW3xcIFxsXQRd8F5IXwRf9GBQYXRiZGLQYzxjlGQgZERkaGSMZLBk1GT4ZRxlQGVkZYhlrGXQZfRmGGY4ZlhnPGfsaRRqOGska9Rs1G2kbfRuFG40bnRutG70bzRvhG%2B4cBxw0HD8cUxxmHIAclhzBHNEc%2FR0NHRgdIB04HVAdWB1gHWgdcB14HYAdiB2QHZgdoB2uHbwdyh3YHeYd9B4HHhoeRB5sHnkehh6dHsIe5x8FHyMfSR9vH3gflR%2ByH8Af7CAYIEUgcSCdIMohECE7IWchZyFnIWchZwAAAAAACwCKAAMAAQQJAAAAxgHSAAMAAQQJAAEANAGeAAMAAQQJAAIADgGQAAMAAQQJAAMAVAE8AAMAAQQJAAQARAD4AAMAAQQJAAUAZACUAAMAAQQJAAYAPgBWAAMAAQQJAA4ANAAiAAMAAQQJASUADAAWAAMAAQQJAUMADAAKAAMAAQQJAUQACgAAAFIAbwBtAGEAbgBJAHQAYQBsAGkAYwBXAGUAaQBnAGgAdABoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAUwBvAHUAcgBjAGUAQwBvAGQAZQBQAHIAbwBFAHgAdAByAGEATABpAGcAaAB0AC0AUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADAAMQA4ADsAaABvAHQAYwBvAG4AdgAgADEALgAwAC4AMQAxADYAOwBtAGEAawBlAG8AdABmAGUAeABlACAAMgAuADUALgA2ADUANgAwADEAUwBvAHUAcgBjAGUAIABDAG8AZABlACAAUAByAG8AIABFAHgAdAByAGEATABpAGcAaAB0ACAAUgBlAGcAdQBsAGEAcgAxAC4AMAAxADgAOwBBAEQAQgBPADsAUwBvAHUAcgBjAGUAQwBvAGQAZQBQAHIAbwBFAHgAdAByAGEATABpAGcAaAB0AC0AUgBlAGcAdQBsAGEAcgBSAGUAZwB1AGwAYQByAFMAbwB1AHIAYwBlACAAQwBvAGQAZQAgAFAAcgBvACAARQB4AHQAcgBhAEwAaQBnAGgAdACpACAAMgAwADEAMAAgAC0AIAAyADAAMgAwACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApACwAIAB3AGkAdABoACAAUgBlAHMAZQByAHYAZQBkACAARgBvAG4AdAAgAE4AYQBtAGUAICAYAFMAbwB1AHIAYwBlIBkALgAAAAEAAAAKAEoAlAAEREZMVAAuY3lybAAuZ3JlawAabGF0bgAuAAQAAAAA%2F%2F8ABQAAAAEAAgADAAQABAAAAAD%2F%2FwAEAAAAAQACAAQABWNjbXAAPmRub20AOGZyYWMALGxvY2wAJm51bXIAIAAAAAEACAAAAAEAAAAAAAQACAAKAAsADQAAAAEACQAAAAQAAQADAAQABQAQAoQCTAI6AfIBpAFQAUIBQgEIAN4AygCeAIwAMAAiACIAAQAAAAEACAABAEj%2F8gAGAAAAAgAwAAoAAwACAB4AFAABADgAAAABAAAADwACAAEAvgDHAAAAAQACAScBKAADAAEAHAABABIAAAABAAAADgACAAEAzADZAAAAAgACAL4AywAAAOQA5gAOAAEAAAABAAgAAgAkAAIBJwEoAAYAAAABAAgAAwABABoAAQASAAAAAQAAAAwAAQACAAEBJgACAAEAzADVAAAAAQAAAAEACAABAAYAPAABAAEAqgABAAAAAQAIAAIATAAOAL4AvwDAAMEAwgDDAMQAxQDGAMcAygDLAMgAyQABAAAAAQAIAAIAIgAOAMwAzQDOAM8A0ADRANIA0wDUANUA2ADZANYA1wACAAIAfgCJAAAApAClAAwAAQAAAAEACAABARwAAQAGAAAAAgAyAAoAAwABABIAAQEMAAAAAQAAAAcAAQAJAQcBCgEPAREBFAEWAR4BIQElAAMAAQASAAEA5AAAAAEAAAAGAAIAAgACABsAAAA2AFUAGgAEAAAAAQAIAAEAOgAEADAAJAAaAA4AAQAEAHsAAwChACcAAQAEAGMAAgEOAAEABABWAAMAoQANAAEABABCAAIBDgABAAQACAANACIAJwAEAAAAAQAIAAEAOgABAAgABgAsACYAIAAaABQADgEiAAIBCAEfAAIBCwEjAAIBDgEkAAIBEAEgAAIBBgEdAAIBCQABAAEBEwABAAAAAQAIAAIAOgACAGgAegAGAAAAAQAIAAMAAAABACgAAQASAAEAAAACAAEACQEGAQkBDgEQARMBFQEdASABJAABAAIAJAAlAAEAAAABAAgAAQAGAAIAAQACAQYBCQAAAAEAAAAKADQAXgAEREZMVAAaY3lybAAaZ3JlawAabGF0bgAaAAQAAAAA%2F%2F8AAwAAAAEAAgADZnJhYwAkbWFyawAabWttawAUAAAAAQAEAAAAAwABAAIAAwAAAAEAAAAFBHQEOgICAFwADAAGAQAAAQAIAAEECgA4AAEDoAAMAAYAJgAmACAAGgAUAA4AAQEsAlsAAQEsAmkAAQEsAj4AAQEsAkwAAQEsAmoAAQAGAQYBCQEOARABEwEVAAQAAAABAAgAAQGWAVIAAQGGAAwAPAGEAUABOgE0AS4BKAEiAYQBhAGEARwBFgGEAYQBhAEQAQoBBAGEAYQA%2FgD4AYQBhADyAYQA7ADmAOAA8gDaANQAzgDIAMIAvAC2ALABBAGEAKoApACeAJgAkgGEAYQBhAGEAIwAzgCGAIAAmADIAYQAmAB6AKoAwgABATL%2F7AABASL%2F7AABAVD%2F7AABAQv%2FJQABAXz%2F7AABATX%2F7AABAL%2F%2F7AABAc3%2FJQABAIn%2FJQABATT%2F7AABAYH%2F7AABAU%2F%2F7AABAO3%2FJQABAVz%2F7AABATr%2F7AABATT%2FJQABASP%2F7AABATD%2F7AABAVT%2F7AABATb%2F7AABATz%2F7AABAS%2F%2F7AABAS7%2F7AABATn%2F7AABAUD%2F7AABAIz%2F7AABAV3%2F7AABAVL%2F7AABAUr%2F7AABALX%2F7AABAU3%2F7AABASb%2F7AABAVj%2F7AABATP%2F7AACAAgAAgARAAAAEwA1ABAAPAA8ADMAVABUADQAXQBdADUAaABoADYAbwBwADcAeAB6ADkAAgAAAAoAAAAKAAEBLP%2FsAAEAAgEZARwABAAAAAEACAABAhQBdgABAaoADAA%2FAfwBZAFeAfwBWAFSAUwB%2FAH8AUYBQAE6AfwBNAH8AS4BKAEiARwB%2FAH8AfwB%2FAH8AfwBFgEQAQoBBAD%2BAPgA8gDsAOYA4ADgANoA1ADOAMgCAgDCALwAtgCwAKoApAICAgICAgC8AJ4AmAH8AJIAjAD4AIYCAgDIAIABCgCGAAEBSgLgAAEBXAH7AAEBKwKkAAEBfwKkAAEBpAKkAAEBQgH7AAEBJwH7AAEBAAKDAAEBLwH7AAEBZAH7AAEBMAH7AAEBQQH7AAEBPgH7AAEBOwH8AAEBHQLgAAEAsgLgAAEBXALiAAEAgwLgAAEBMwH7AAEBpALgAAEBPAH7AAEBywLgAAEBWgH7AAEAiQLgAAEBQAH7AAEBPQKkAAEBPAKkAAEBMAKkAAEBLgKtAAEBQAKkAAEBNgKkAAEAvQKkAAEBRgKkAAEBRAKkAAEBSgKkAAEBVgKkAAEBSwKkAAEBWgKkAAEBLQKkAAIACAACADUAAAA8ADwANABNAE4ANQBUAFQANwBdAF0AOABoAGgAOQBvAHAAOgB4AHoAPAAXAAAAZAAAAF4AAABkAAAAZAAAAF4AAABkAAAAZAAAAF4AAABkAAAAXgAAAGQAAABeAAAAZAAAAF4AAABkAAAAXgAAAGQAAABkAAAAXgAAAGQAAABkAAAAZAAAAF4AAQEsAqQAAQEsAfsAAgAEAQYBCwAAAQ4BEQAGARMBFgAKAR0BJQAOAAEAAAABAAgAAQAIAAT9qAABABMBBgEHAQgBCQEKAQsBDgEPARABEQETARQBFQEWARkBHAEfASIBKQABAAAAAQAIAAEACgAF%2FtT9qAABAAMA5ADlAOYAAAAFAD4AAAIaApQAAwAJAAwAEgAVAAAzESERJSEnJyMHBzcnFzM3NyMfAhE%2BAdz%2BkAEBSTQENnWAgKsEMULrQmF%2FApT9bDqEZ2dQ5ui5Xnd3jeYBzgACACAAAAI4ApAADQARAAAzEzMTIwMmJicjBgYHAzc1IRUg3V7dWHIRIQ8EECARcx8BLQKQ%2FXABbzdtOTltN%2F6RyENDAAMAYwAAAiMCkAARABoAIwAAMxEzMhYWFRQGBxUWFhUUBgYjAzMyNjU0JiMjETMyNjU0JiMjY7pDZTk4O0hQPm9KdllUSU1MXWpUXVtWagKQIEY6MU8PBAtOREBWKgF8Njc1LP38O0M9NQABAEH%2F9AIqApwAHgAABSIuAjU0NjYzMhYXByYmIyIGBhUUFhYzMjY3FwYGAV89aE4rTIRWO1wcLxlCKT9dNDRdPy1IHy8mZAwuV39QaZlSMR81HCBBdlJTeEImIzMtMgACAFcAAAIpApAACgAVAAAzETMyFhYVFAYGIyczMjY2NTQmJiMjV6Jjh0ZFhmFTSUtjMjJjS0kCkEuSaGmUTkQ%2FdVNSdDsAAQByAAACEgKQAAsAADMRIRUhFSEVIRUhFXIBlv6%2BARD%2B8AFMApBGzkfuRwABAIUAAAIYApAACQAAMxEhFSEVIRUhEYUBk%2F7BAQ7%2B8gKQRt5G%2FtoAAQA1%2F%2FQCFQKcACEAAAUiJiY1NDY2MzIWFwcmJiMiBgYVFBYWMzI2NzUjNTMRBgYBUVKASkuDVUFYHC8YPy89XDMwWkAiPhKD0B9lDFGYa2qZUTMdNRoiQXZSU3hCFRKrRf7sICwAAQBPAAACCQKQAAsAADMRMxEhETMRIxEhEU9UARJUVP7uApD%2B7QET%2FXABNf7LAAEAXwAAAfkCkAALAAAzNTMRIzUhFSMRMxVfo6MBmqOjRwIDRkb9%2FUcAAAEAUf%2F0Ae0CkQASAAAFIiYnNxYWMzI2NREhNSERFAYGARQ3aiI0HEsmRkL%2B7QFmKF8MNDkzLCtLUQFyRv5BPWU8AAIAYgAAAkQCkAAIAAwAADMRMxEzATMBFSEDNxNiVAMBFF%2F%2BigEwyzP2ApD%2BtwFJ%2FkHRAW5C%2FlAAAQCGAAACHQKQAAUAADMRMxEhFYZSAUUCkP23RwAAAQBIAAACEAKQAB0AADMRMxMXMzcTMxEjETQ%2BAjcjBwMjAycjHgMVEUhmXCAEH11mUAMFBQEDJV48XCYCAgUEAwKQ%2FuhqagEY%2FXABSBg%2BQjsVgP7%2BAQKAFTtCPhj%2BuAAAAQBSAAACBgKQABMAADMRMxMXMyYmNREzESMDJyMWFhURUlzSPwICCVBc0j8CAgkCkP5kiDFrNAFU%2FXABnIgyaDP%2BqQACADD%2F9AIoApwADwAfAAAFIiYmNTQ2NjMyFhYVFAYGJzI2NjU0JiYjIgYGFRQWFgEsSnJAQHJKSnJAQHJKMkspKUsyMkspKUsMUplsapdQUJdqbJlSSUF5VFN2Pz92U1R5QQAAAgBmAAACHwKQAAwAFQAAMxEzMhYWFRQGBiMjEREzMjY1NCYjI2bGSW09PW5Ic2lWU1RVaQKQJVRIRVkt%2FvwBSEJFRzcAAAMAMP9dAisCnAAPAB8ALgAABSImJjU0NjYzMhYWFRQGBicyNjY1NCYmIyIGBhUUFhYXIiYnNx4CMzI2NxcGBgEsSnJAQHJKSnJAQHJKMkoqKkoyMkoqKkrnWW8YVgopPCQPGggQECUMUplsapdQUJdqbJlSRUF6V1J3Pz93Uld6QdxdRQcgLBYGBEMGCAADAGQAAAIpApAADAAVABkAADMRMzIWFhUUBgYjIxERMzI2NTQmIyMTNxMjZMxDZzs7Z0N5bU1RUU1taELIXwKQI1FEQlYr%2FusBWT9AQDX%2B3yz%2BqAABAEP%2F9AIZApwALQAABSImJzcWFjMyNjU0JiYnJy4CNTQ2NjMyFhcHJiYjIgYVFBYWFxceAhUUBgYBMUh5LTIlYzhESx81Il4hQSw3Yj4%2BaCQsIE4zOUYjNhxcKUImOGgMNSw6JS06LiMqHA4pDipBMDJPLS0kNh0hMy0fKBoMKBAtQjA0VTIAAQAqAAACLgKQAAcAACERIzUhFSMRAQLYAgTYAkpGRv22AAEAT%2F%2F0AgkCkAAXAAAFIi4CNREzERQWFjMyNjY1ETMRFA4CAS0wUTwhVCQ%2FJyg%2FJFEhO1AMHT1kRgGY%2FmZEUSQkUUQBmv5oRmQ9HQABACsAAAItApAADQAAMwMzExYWFzM2NjcTMwP80VhqEhsSBBMbEWlV0AKQ%2Fp46ZTo6ZToBYv1wAAEACgAAAk4CkQAlAAAzAzMTHgIXMz4CNzczFx4CFzM%2BAjcTMwMjAyYmJyMGBgcDbmReMAMFBAEDBgoKBkBQPgcKCQYEAgMEAy5aYGhABwwFAwUKCEACkf5kGy0vISEvLBv09BssLyEhLywbAZ39bwEIHjoeHjoe%2FvgAAQA2AAACIgKQABkAADMTAzMXFhYXMzY2NzczAxMjJyYmJyMGBgcHNsS3XFwNGBAEDRYMWli3xFxjDR0QBA4aDWIBUwE9qBYsHR0sFqj%2Bv%2F6xsRgzHh4zGLEAAQAmAAACMgKQAA8AACE1AzMXFhYXMzY2NzczAxUBAtxYYxMkFAQUJhNfVtzqAabDJUwoKEwmwv5a6gAAAQBBAAACGwKRAAkAADM1ASE1IRUBIRVBAW7%2BsgG1%2FpEBdDICGUYy%2FehHAAACAFH%2F9AIDAfIAHgAqAAAXIiYmNTQ2Ny4CIyIGBgcnPgIzMhYWFREjJyMGBicyNjc1DgIVFBYW9i1MLKS8ARk4Lx89NxcgGEVQK0NXK0MHAyhkHipSKWh3MR4xDCE%2BK1JVDyE4IREbDjgQIRUyWT3%2B1kIgLkImIoAJIDEgGyMQAAIAXf%2F0AhwCyAAVACQAAAUiJicjByMRMxUHMzY2MzIWFhUUBgYnMjY2NTQmJiMiBgcVFhYBQCRRIgMHQlIDAyFXK0JaLj1kSCpDJxw8MSFJJSNHDCMfNgLIwl4iKD1vS1N2PkUuVzw1US0jJvIfGgABAFD%2F9AIbAfIAHQAABSImJjU0NjYzMhYXByYmIyIGBhUUFhYzMjY3FwYGAVpMeUVKe0o8Vx4pHkAnOFYvLlU4LUseJShjDDxyUFJyPCodNRoeL1U4N1QvJBk1JCgAAgA8%2F%2FQB%2BwLIABQAIgAABSImNTQ2NjMyFhczJzUzESMnIwYGJzI2NzUmJiMiBgYVFBYBD190P2U5K0cfAwRSRAcDHVMdJEQhIT8gKkUpTAyFeU9zPiEeWrv9OEAfLUUlJPIfGi9TOFdjAAEARP%2F0AhoB8gAkAAAFIiYmNTQ2NjMyFhYVFAYHITUhBzQmIyIGBhUUFhYzMjY3FwYGAUpJd0ZGcUFGYzUCAv5lAWoVT0MtTS4yVjYsRyEeJF0MPHNRT3I9OWZFDhoKQBdWVixUPT9UKxkVNhgiAAACAGcAAAJCAtQAEAAVAAAzETQ2NjMyFhcHJiYjIgYVEQM1NyEV8itWQyRFIxMeMyBBOtyOARoCDztZMQ0PPg4JRDv97gGjPgVDAAMASP8gAjYB8gAyAEIAUwAABSImJjU0Njc1JiY1NDY3NSYmNTQ2NjMyFzMVIxYWFRQGBiMiJicGBhUUFjMzMhYVFAYGAzI2NjU0JiYjIgYGFRQWFhMyNjY1NCYjIyImJwYGFRQWAShHZDUpJxMfHhwZIzVXMykfyX4RGDJVNRMrFBIUNTBtXltCeVgfMx4eMx8eMx8fMyk5Uiw3OF8VJRAiHFHgIDwrHTkWBAsmHxcxEwQTQCs1TisMQxE0HTRLKAkJCxwRHBw0Pi1OLwGxHDQjIjMdHTMiIzQc%2FoscLBkjGAQEEykVJi0AAAEAXQAAAgsCyAAVAAAzETMVBzM2NjMyFhURIxE0JiMiBgcRXVIFAyVYOVZSUjQ8K0QrAsjCcyg3ZGD%2B0gEjRUMsLP6tAP%2F%2FAFoAAAGeAswCJgBoAAAABgESMAD%2F%2FwA3%2FycBngLMAiYAegAAAAYBEjAAAAIAagAAAj4CyAAIAAwAADMRMxEzATMBFSEDNxNqUgQBBl7%2BmAEmvjLoAsj%2BHgEA%2Fp6EAQM1%2FsgAAQBR%2F%2FQCGQLIABEAAAUiJjURIzUzERQWMzI2NxcGBgGWTVKm%2BDQrFSwbFSE6DFlWAeJD%2FdU1MAsMPgwRAAABADoAAAIuAfIAIgAAMxEzFzM2NjMyFhc2NjMyFhURIxE0IyIGBxEjETQmIyIGBxE6QgcCEzIqJC4KFTMqMzlSNBkhFEwXGxklEgHmQCIqKionLU1J%2FqQBVlUlJv6gAVYqKyUm%2FqAAAAEAXQAAAgsB8gAUAAAzETMXMzY2MzIWFREjETQmIyIGBxFdRAcEJlg5VlJSNDwrRCsB5lMpNmRg%2FtIBI0VDLCz%2BrQAAAgA8%2F%2FQCHAHyAA8AHwAABSImJjU0NjYzMhYWFRQGBicyNjY1NCYmIyIGBhUUFhYBLEBtQ0NtQEBtQ0NtQC9GJiZGLy9FJydFDDxyUFJyPDxyUlByPEQvVDc4VS8vVTg3VC8AAAIAXf8zAhwB8gAVACQAABcRMxczNjYzMhYWFRQGBiMiJicjFxUTMjY2NTQmJiMiBgcVFhZdRAcDIlktQlkuPmQ7IU8hAwSCK0QnHDwxIUklI0fNArM%2BICo9b0xSdj4hHlykAQYuVzw1US0jJvIfGgACADz%2FMwH7AfIAFAAiAAAFNTcjBgYjIiY1NDY2MzIWFzM3MxEDMjY3NSYmIyIGBhUUFgGpBAMdUi1edD9lOSxIIgMHQtskRCEhPyAqRSlMzbFaHyuFeU9zPiEhNv1NAQYlJPIfGi9TOFdjAAABAJIAAAIZAfIAEgAAMxEzFzM2NjMyFhcHJiYjIgYHEZJEBwMmcEMbLxYTGSQdN2UsAeZzO0QJC0cJCD9M%2FuMAAQBH%2F%2FQCDgHyACoAAAUiJic3FhYzMjY1NC4CJyYmNTQ2MzIWFwcmJiMiBgYVFBYXHgIVFAYGATZHfCwmKmZDPj0LHzwyX19mZDhoJCghVC4qMRVDSlFXITJgDC4eNh4kLh4OGBYUChRENjtPJRk1GBsTIBMfIw8RKjYlKEEoAAABAEX%2F9AIiAoIAGQAABSImJjU1IzU3NzMVMxUjFRQWFjMyNjcXBgYBikdSI4mMC0Tv7xY2LyM4GhIhSQwzWjzmPgWcnEPnKzweDAo8DBEAAAEATf%2F0AfkB5gAUAAAXIiY1ETMRFBYzMjY3ETMRIycjBgb2V1JTMz0qRShSQwcEJVgMZGABLv7dRUMrLwFR%2FhpVKjcAAQAzAAACJQHmAA0AACEDMxMWFhczNjY3EzMDAQDNU3APGw0EDRoOcE%2FJAeb%2B7CRIIyNIJAEU%2FhoAAAEACAAAAlAB5gAhAAAzAzMTFhYXMzY2NzczFxYWFzM2NjcTMwMjJyYmJyMGBgcHcmpSOgcLBAQFDwg8UjoIEgQEBgkHOkxoajgGDAYEBgwGNgHm%2FuYiQSMjQSL8%2FCJBIyNBIgEa%2FhroGkguLkga6AABAEAAAAIXAeYAGQAAMzcnMxcWFhczNjY3NzMHFyMnJiYnIwYGBwdAuatbTQ0eDgQNHQ1JV626WlUPIRAEDx4PUPzqaxMqFRUrFGnx9XAVLhUVLBdwAAEAMf8vAicB5gAbAAAXIiYnNxYWMzI2NzcDMxMWFhczNjY3EzMDDgKDECMNEQoXCzNAEg%2FjU3cOHw8EDRsMak7WEjZP0QYEQQMEOy0kAef%2B8yBJJCNJIQEN%2FfIwTSwAAAEARwAAAhMB5gAJAAAzNQEhNSEVASEVRwFN%2FtgBnv6yAVcsAXdDLP6JQwD%2F%2FwAgAAACOANjAiYAAgAAAAYBBwAA%2F%2F8AIAAAAjgDYwImAAIAAAAGAQoAAP%2F%2FACAAAAI4A0YCJgACAAAABgENAAD%2F%2FwAgAAACOANJAiYAAgAAAAYBDwAA%2F%2F8AIAAAAjgDMAImAAIAAAAGARQAAP%2F%2FACAAAAI4A3ACJgACAAAABgEYAAAAAv%2F%2FAAACTwKQABIAFgAAIwEhFSMVMxUjFTMVIREjBgYHAzc1MxUBAQgBP72Tk8b%2B7gMUKhWRLeICkEbNR%2B9HAk41ajb%2Bh79DQ%2F%2F%2FAEH%2FHgIqApwCJgAEAAAABgEbMgD%2F%2FwByAAACEgNjAiYABgAAAAYBBx8A%2F%2F8AcgAAAhIDYwImAAYAAAAGAQofAP%2F%2FAHIAAAISA0YCJgAGAAAABgENHwD%2F%2FwByAAACEgMwAiYABgAAAAYBFB8A%2F%2F8ANf%2F0AhUDSQImAAgAAAAGAQ8eAP%2F%2FAF8AAAH5A2MCJgAKAAAABgEHAAD%2F%2FwBfAAAB%2BQNjAiYACgAAAAYBCgAA%2F%2F8AXwAAAfkDRgImAAoAAAAGAQ0AAP%2F%2FAF8AAAH5AzACJgAKAAAABgEUAAD%2F%2FwBSAAACBgNJAiYADwAAAAYBDwoA%2F%2F8AMP%2F0AigDYwImABAAAAAGAQcAAP%2F%2FADD%2F9AIoA2MCJgAQAAAABgEKAAD%2F%2FwAw%2F%2FQCKANGAiYAEAAAAAYBDQAA%2F%2F8AMP%2F0AigDSQImABAAAAAGAQ8AAP%2F%2FADD%2F9AIoAzACJgAQAAAABgEUAAAAAwAk%2F%2BACMAKwAAMAEwAjAAA3ARcBNyImJjU0NjYzMhYWFRQGBicyNjY1NCYmIyIGBhUUFhYkAdQ4%2FizQSnJAQHJKSnJAQHJKMkspKUsyMkspKUsEAqwk%2FVQUUplsapdQUJdqbJlSSUF5VFN2Pz92U1R5QQACACEAAAJPApEAEgAdAAAhIiYmNTQ2NjMhFSMVMxUjFTMVJTMRIyIGBhUUFhYBKFJ3PkB3UwEawpSUzP7SFhY5TCUlTE6UaWiSTEbPR%2B5HRAIIO3NTVHU%2BAP%2F%2FAE%2F%2F9AIJA2MCJgAWAAAABgEHAAD%2F%2FwBP%2F%2FQCCQNjAiYAFgAAAAYBCgAA%2F%2F8AT%2F%2F0AgkDRgImABYAAAAGAQ0AAP%2F%2FAE%2F%2F9AIJAzACJgAWAAAABgEUAAD%2F%2FwAmAAACMgNjAiYAGgAAAAYBCgAAAAIADAAAAikCkAAOAB0AADMRIzU3ETMyFhYVFAYGIyczMjY2NTQmJiMjFTMVI1dLS6Jjh0ZGhWFTSUtjMTFjS0mQkAE6OAYBGEyRaGmUTkQ%2BdlNTcjzUPgACAGUAAAIhApAADgAXAAAzETMVMzIWFhUUBgYjIxU1MzI2NTQmIyNlVHZIbT09bkd2a1ZUVVVrApBuJVRIRVosltpBRkc2AAADAEQAAAIqApAABQARABcAADMRMxEzFQMiJjU0NjMyFhUUBhMRMxEzFURMgx0hLS0hIS8vRUyCApD9t0cBEC0nJysrJyct%2FvACkP23R%2F%2F%2FAFH%2F9AIDAwkCJgAcAAAABgEGFAD%2F%2FwBR%2F%2FQCAwMJAiYAHAAAAAYBCRQA%2F%2F8AUf%2F0AgMC5AImABwAAAAGAQwUAP%2F%2FAFH%2F9AIDAtECJgAcAAAABgEOFAD%2F%2FwBR%2F%2FQCAwK8AiYAHAAAAAYBExQA%2F%2F8AUf%2F0AgMC%2BQImABwAAAAGARcUAAACABH%2F9AJVAfIAFQBIAAAXIiY1NDY2NxUOAhUUFjMyNjcXBgYhIiYmNTU0JiMiBgcnNjYzMhYXIzY2MzIWFhUUBgchNTMHNCYjIgYGFRQWFjMyNjcXBgaRN0k3dl9LVCEpIR9FGxwnWAEDPFQsMCgePRcfHk8rMkIQFRdTLjNCIAIC%2FuPtDyotHDMhHTgpHDATHhlBDEc9M0swCjUJIjEfIycsKSozOkFySzFOPRgQOBQgPUdHPT1lPA4dDUAUVVQlU0U6VS4TDTgSGf%2F%2FAFD%2FHgIbAfICJgAeAAAABgEaLgD%2F%2FwBE%2F%2FQCGgMJAiYAIAAAAAYBBhAA%2F%2F8ARP%2F0AhoDCQImACAAAAAGAQkQAP%2F%2FAET%2F9AIaAuQCJgAgAAAABgEMEAD%2F%2FwBE%2F%2FQCGgK8AiYAIAAAAAYBExAA%2F%2F8ASP8gAjYC0QImACIAAAAGAQ4HAP%2F%2FAFoAAAGcAwkCJgBoAAAABgEGMAD%2F%2FwBaAAAB4wMJAiYAaAAAAAYBCTAA%2F%2F8AWgAAAfcC5AImAGgAAAAGAQwwAP%2F%2FAFoAAAHzArwCJgBoAAAABgETMAAAAQBaAAABjgHmAAUAACERIzUhEQE84gE0AaND%2Fhr%2F%2FwBdAAACCwLRAiYAKQAAAAYBDhIA%2F%2F8APP%2F0AhwDCQImACoAAAAGAQYAAP%2F%2FADz%2F9AIcAwkCJgAqAAAABgEJAAD%2F%2FwA8%2F%2FQCHALkAiYAKgAAAAYBDAAA%2F%2F8APP%2F0AhwC0QImACoAAAAGAQ4AAP%2F%2FADz%2F9AIcArwCJgAqAAAABgETAAAAAwA8%2F%2BICHAIEAA8AHwAjAAAFIiYmNTQ2NjMyFhYVFAYGJzI2NjU0JiYjIgYGFRQWFgcnARcBLEBtQ0NtQEBtQ0NtQC9FJydFLy5GJydGki4Bri4MPHJQUnI8PHJSUHI8QjBVNzhWMDBWODdVMFQqAfgqAAACAAv%2F9AJVAfIADQA%2FAAA3MjY2NTQmJiMiBhUUFhciJiY1NDY2MzIWFyM2NjMyFhYVFAYHITUzBzQmIyIGFRQWMzI2NxcGBiMiJiYnMwYGvB0rGBgrHTEzMywxTi0uTjEzRhMREU00MEAgAgL%2B9dsPKSssOEQ0GikTHhc9IyQ%2FLgsSE0c4L1U3OFQvZ1VTZ0Q8clBScjxKTU1KPWU8Dh0NQBRVVF9eX14TDTgSGSBCM01IAAABAFj%2F9AI0AtQANgAABSImJzcWFjMyNjU0LgQ1ND4CNTQmIyIGFREjETQ2NjMyFhYVFA4CFRQeBBUUBgYBkSpGICEcNB0rLB0uNC4dGyQbLCo2QFIwWz41SSYbJBsdLjMuHShJDBgVOhQTLx8dJxsbHy8iIzEsMB8lMUxK%2FgUCBz1dMyhEKCU2KyoaGCEZGyQ0KCpDKP%2F%2FAE3%2F9AH5AwkCJgAwAAAABgEG%2BwD%2F%2FwBN%2F%2FQB%2BQMJAiYAMAAAAAYBCfsA%2F%2F8ATf%2F0AfkC5AImADAAAAAGAQz7AP%2F%2FAE3%2F9AH5ArwCJgAwAAAABgET%2BwD%2F%2FwAx%2Fy8CJwMJAiYANAAAAAYBCQQA%2F%2F8AMf8vAicCvAImADQAAAAGARMEAAACADz%2F9AIYAtoAKQAtAAAFIiYmNTQ2NjMyFhcXJiYjIgYGFRQWFjMyNjY1NC4CJzceAxUUBgYDJyUXASo%2FbUI7Z0I0XRoBI1QpNkglLEotNUYiKExsRCZFeFw0Omu%2FHgFOHgw5aUhEZTg1LjgyKSpJLjJLKTNZOliDYUshNCBTcJVhUHlEAfo0qjIAAAIAXf8zAhwCyAAWACUAABcRMxUHMzY2MzIWFhUUBgYjIiYnIxcVEzI2NjU0JiYjIgYHFRYWXVIDAyJVK0JaLz5lOiRMIAMDgipFJxw9MSBJJSJHzQOVyVciKD1vTFJ2PiIdXKQBBi5XPDVRLSMm8h8aAAEAN%2F8nAY4B5gAUAAAXIiYnNxYWMzI2NjURIzUhERQOAsImSB0bGjkcMTUV4gE0FC5P2RMOPQ0OHzwpAbVD%2Fg4tSzceAAAD%2F%2Fj%2F9AJsAsgAEQAdAC8AABciJjURIzUzERQWMzI2NxcGBhMiJjU0NjMyFhUUBhMiJjURIzUzERQWMzI2NxcGBuZAQ2u2JB4LFg8VFCMoIS0tISEvL9U%2FQ2y3JB4LFg8VFCMMWVYB4kP91TUwCAc%2BBw4BHC0nJysrJyct%2FuRZVgHiQ%2F3VNTAIBz4HDgAAAQBU%2F0UCJwHmACgAABcRMxEUFjMyNjY3ETMOAhUUFjMyNjcXBgYjIiYnIwYGIyImJxQWFhdUUjI1GTAyGVMBAwIRCwQHBwsIGA8mJgQCHk8tITcUAQMDuwKh%2Ft1DRRAtLAFCQomFOhMRAQE%2BAwUtOzQyFSAySkIoAAABACr%2F9AJBApwAQAAAFyImJjU0PgQ1NCYjIgYVFB4CFxYWFwcmJicuAzU0NjYzMhYVFA4EFRQWFjMyNjc2NjczBgYHBgbuOlkxKUBJQCkbISInLElaLiRDHRckUCo1Yk8tJEAsPUImPkY%2BJiI5IyZHHiU1EUwUPiwnZQwvUjUvSDoyMTgjHSs2KS5nZ10jHScKRAwtIiprdnQzK0cpSDooQjc0NTwlJTYeKyIrcUNJhjgtOgADAEf%2F9AIRAooADQAdACkAAAUiJiY1NDYzMhYVFAYGJzI2NjU0JiYjIgYGFRQWFjciJjU0NjMyFhUUBgEsR2Y4e2prejdnRy1EJydELSxFJydFLBklJRkaJCQMT5RqoaiooWqUT0I5d1tcdDc3dFxbdznPJB8fIyMfHyQAAQBhAAACEgJ%2BAA0AADM1MxEjNT4CNzMRMxVhuI8mOjAUPadEAdY1BQ4RC%2F3GRAAAAQBFAAACCgKKABwAADM1PgI1NCYjIgYHJzY2MzIWFhUUBgYHNjYzMxVJbJVOREctTR8vK2NEQF0zSoVXHjwd0jFfkXQ1N0YsIS8sNS9UOTx6h1ADA0cAAAEAOf%2F0AgYCigAuAAAFIiYmJzcWFjMyNjY1NCYmIzUyNjY1NCYjIgYHJzY2MzIWFhUUBgcVHgIVFAYGAR83VkEYKiBaPSxFKC5mVExcKUc7LVEfLChnPTxfOE07KkkrP2gMGigYNh4uHTUjJjkgPyA1Ii82JB00Iy0mSDQ6ShQECStCLDlRLAABACcAAAIhAn4AEAAAIRE2NjcjBgYHByEVITUBMxEBcAEDAQUPIhCtAZ%2F%2BBgE%2FWAG4Gj0aFy8X2kI3AZf9ggAAAQA4%2F%2FQCCgJ%2BACMAAAUiJiYnNx4CMzI2NjU0JiMiBgcnEyEVIQc2NjMyFhYVFAYGAR45Vj8YKRUzQiotSitWRyg4IiwVAWn%2B4BEbNyQ9ZDpDbAwZKBY2EyEVJEEtQkoUExwBM0e9DA4qWUVFYTIAAAEATf%2F0AhYCigAuAAAFIi4CNTQ%2BAjMyFhcHJiYjIgYGFRQWFjMyNjY1NCYjIgYHJzY2MzIWFhUUBgYBQTRZQiUsS2A0OlggLhhDJDRYNydLNSY9JEZCJlgpAyhfMjtaMjthDCZNc01gh1QoJx0zFxs2fWtPbDcjPypCRSkxQSgvLFhBPVw0AAABAEYAAAIUAn4ADgAAMz4DNyE1IRUOAwfiBBoyTjb%2BkAHOQFIwFwNbloV%2BQ0czSISImV4AAwBE%2F%2FQCEwKKAB4AKwA7AAAFIiYmNTQ2Njc1JiY1NDY2MzIWFRQGBxUeAhUUBgYDNjU0JiYjIgYVFBYWAzI2NTQuAicOAhUUFhYBLkhpOSg%2FIig5M1k5XWk5KCM5ITVmGFAeOSo0RC1NAUdNHzZJKh8yHCdJDC1QMixBLRAEGkkyMUopX0stTxwEEio8Li9NLgFoOkYfMx85LiYyI%2F7GPjIhLR8aDhEoMiAjNyAAAQBD%2F%2FQCDAKKAC4AAAUiJic3FhYzMjY2NTQmJiMiBgYVFBYzMjY3FwYGIyImJjU0NjYzMh4CFRQOAgEBO1gfLhhDJDRYNidKNSY9JEZCJlgpAydhMjtZMjthODVYQyUsS2EMJxw0Fxw3fWtPazgjPypBRikxQSgvLFhBPV0zJk1zTWCIVCcAAAEA2%2F%2F0AX0AnQALAAAFIiY1NDYzMhYVFAYBLCEwMCEiLy8MLyUmLy8mJS8AAQDF%2FysBjACbABUAABcnNjY1JxcGBiMiJiY1NDYzMhYVFAbcF0A%2BEzgMHQ8VJBUwICwuXtU0HFU%2BXE8OCREhGSUnRTtYeQD%2F%2FwDb%2F%2FQBfQIDAicAiAAAAWYABgCIAAD%2F%2FwDF%2FysBjAIDAicAiAAAAWYABgCJAAAAAwAg%2F%2FQCOACKAAsAFwAjAAAXIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAZmHSkpHR0oKKkdKSkdHSkpqRwpKRweKCgMKiEiKSkiISoqISIpKSIhKiohIikpIiEqAAACAOP%2F9AF1Ap4ABQARAAAlAyczBwMHIiY1NDYzMhYVFAYBEAoCUAIKHB4rKx4eKyvoAVheXv6o9CokIykpIyQqAAACAOP%2FSAF1AfIABQARAAAFNxMzExcDIiY1NDYzMhYVFAYBBAIKOAoCKB4rKx4eKyu4XgFY%2FqheAhApJCQpKSQkKQACAG3%2F9AHfAqoAGgAmAAA3Jj4DNTQmIyIGByc2NjMyFhYVFA4DFwciJjU0NjMyFhUUBvIHGzEzJDc3JkEbMSJcOjhTLyQ1Mh8GHR4rKx4eKyvoK0EyLzEfKTgfGy0jLidGLyk7Mi86J%2FQqJCMpKSMkKgACAHn%2FPAHrAfIAGgAmAAAFIiYmNTQ%2BAyczFg4DFRQWMzI2NxcGBgMiJjU0NjMyFhUUBgEzOFMvJDUyHwZJBxsxMyQ4NidAGzEhXTMeKyseHisrxCdGLyk8MS86JytAMy4yHyk3HxotIy4CHCkkJCkpJCQpAAEA9QFgAWMCrwAFAAABJyczBwcBEBkCbgIZAWDhbm7hAP%2F%2FAIIBYAHWAq8AJgCRjQAABgCRcwAAAQDRAV4BfAK7ABQAAAEiJjU0NjcXBgYVFyc2NjMyFhUUBgErJzNNQxsyNhM3DSERHycpAV5AOEx2IzAdVzlOQg4TKCAiKwAAAQDZAV4BhAK7ABQAABMnNjY1JxcGBiMiJjU0NjMyFhUUBvUcMjcUNw0gER8oKiAnM0wBXjAdVzlOQw4SKB8jK0A5S3cA%2F%2F8AXwFeAe8CuwAmAJONAAAGAJNzAP%2F%2FAGcBXgH3ArsAJgCUjQAABgCUcwD%2F%2FwDZ%2Fx4BhAB7AgcAlAAA%2FcD%2F%2FwBn%2Fx4B9wB7ACcAlP%2BN%2FcAABwCUAHP9wAABAMUANAGFAcQABgAAJSc1NxcHFwFemZknf380oFCgI6WmAAABANMANAGTAcQABgAANyc3JzcXFfonf38nmTQipqUjoFD%2F%2FwBSADQB%2BAHEACYAmY0AAAYAmXMA%2F%2F8AYAA0AgYBxAAmAJqNAAAGAJpzAP%2F%2FAFUBKwIDAWkCBgDsAAD%2F%2FwBVASsCAwFpAgYAnQAAAAEAUADYAggBIAADAAA3NSEVUAG42EhIAAEAAADYAlgBIAADAAA1NSEVAljYSEgA%2F%2F8A2wEHAX0BsAIHAIgAAAETAAEAlwBzAcEBmQAPAAAlIiYmNTQ2NjMyFhYVFAYGASwoQyoqQygoQyoqQ3MlQiwsQiUlQiwsQiUAAQA8%2F3QCHP%2B7AAMAABc1IRU8AeCMR0cAAQDQ%2F1AB3gLcAA0AAAUmJjU0NjcXBgYVFBYXAbFoeXloLWRgYGSwUuORkeRRKlTKfn7JVQAAAQB6%2F1ABiALcAA0AABcnNjY1NCYnNxYWFRQGpy1kYGBkLWl4eLAqVcl%2BfspUKlHkkZHjAAEA4f9oAfYCxAAHAAAXESEVIxEzFeEBFdPTmANcL%2F0CLwABAGL%2FaAF3AsQABwAAFzUzESM1IRFi09MBFZgvAv4v%2FKQAAQB4%2F2gB9gLEADEAAAUiJjU0NjY1NCYmIzUyNjY1NCYmNTQ2MzMVIyIGBhUUFhUUBgcVFhYVFAYVFBYWMzMVAbleWwQFFz87Oz8XBQRbXj00MzUUBic0NCcGFDUzNJg4TSU%2BPSEUIxc0FyQTHz9AI004LxMnIStbLzA0CQQJNDAyVS4gKBMvAAEAY%2F9oAeACxAAxAAAXNTMyNjY1NCY1NDY3NSYmNTQ2NTQmJiMjNTMyFhUUBgYVFBYWMxUiBgYVFBYWFRQGI2MzNDUUBiY0NCYGFDU0Mz1eWgQFFz87Oz8XBQRaXpgvEyggLlUyMDQJBAk0MC9bKyEnEy84TSNAPx8TJBc0FyMUIT0%2BJU04AAABAGP%2FYAH1AsYAAwAAFwEzAWMBSEr%2BuKADZvyaAAABAQf%2FBgFRAu4AAwAABREzEQEHSvoD6PwYAAEAY%2F9gAfUCxgADAAAFATMBAav%2BuEoBSKADZvyaAAIBB%2F8GAVEC7gADAAcAAAURMxEDETMRAQdKSkr6Abj%2BSAIwAbj%2BSAABAFQAbwIEAiwADgAANyc3JzcXNzMXNxcHFwcntCpsohCnCTAJpxCibCp4bx6lRi43vb03LkalHp8AAgBb%2F8AB%2FQKsACIARgAABSImJzcWFjMyNjU0LgQ1NDY3FwYGFRQeBBUUBgY3NjY1NC4ENTQ2NjMyFhcHJiYjIgYVFB4EFRQGBgcBHzZdIDIaPSooLilASUAoQjEnJi0qQUlBKSlIDSwuKkFKQSkiQzIxUh4oGTkjKyUpQUhBKB00I0AmIS0YHCgdHCYdHik%2BLjJHFCkRKyMhLCAeJjgqKD0k9xAoJyMtIB4lOCkiPCQiFzUUGiUaGyQdHys9LiQ1JhAAAAIASP%2BwAeUCkAAKAA4AACUiJiY1NDY2MzMRExEzEQE%2BR25BPmpDKzZR4i5gS05eKf5S%2Fs4C4P0gAAADAB7%2F9QI6Ao0ADwAfADsAAAUiJiY1NDY2MzIWFhUUBgYnMjY2NTQmJiMiBgYVFBYWNyImJjU0NjYzMhYXByYmIyIGFRQWMzI2NxcGBgEsTXlISHlNTXlISHlNQ2U4OGVDQ2U4OGVLLUksLkssJDETIhAeFS05NiwbJhAeFjULUpZmZ5RPT5RnZpZSKkmEV1iBSEiBWFeESV4vWT46VS4bFCcPEEs7Qk0UDioUGwAEAHABPwHoAskADwAfAC0ANgAAASImJjU0NjYzMhYWFRQGBicyNjY1NCYmIyIGBhUUFhYnNTMyFhUUBgcXIycjFTUzMjY1NCYjIwEsNFYyMlY0M1YzM1YzKkMnJ0MqKkQnJ0QfTCAvFREuLiMpGhQYExccAT8yWDs6WTIyWTo7WDIlKEkvL0kpKUkvL0koPcscJRIeB1NGRmYREQ8SAAL%2F%2BwFuAkQCpAAHABsAABMRIzUzFSMRMxEzFxczNzczESM1NyMHIycjFxVbYPxgjUctGwQaLEc3BwRHKkgEBwFuAQA2Nv8AATZyUFBy%2FsqJabu7aYkAAgAx%2F3ACIgJ7ADAAOgAABSIuAjU0NjYzMhYWFREjJyMGBiMiJiY1NDY2NzU0JiYjIg4CFRQWFjMyNjcXBgYDMjY3NQYGFRQWAVU7alAvT4VSRVosMgcEFkcnIzsjPXZVH0E1LVJAJD1pQS1DHRwnUxQcOBxoWCyQMmSUYICrVj5sRP7XOhwqIDsoM0QqCg4wUDAqU31Ta5dOFxYtGh0BIiEffg82LiMoAAAEAFcAAAIHAooAAwAHAAsADwAAIRMzAyMTMwMDNSEVBTUhFQFIUDVP8FA1T1kBnP5QAZwCiv12Aor9dgGZOjrNOTkA%2F%2F8ArwGLAdwDEQIHALoAAAI8%2F%2F8AkgGLAb4DHQIHALsAAAI8%2F%2F8AjgF%2FAb0DHQIHALwAAAI8%2F%2F8AlAGLAc4DHQIHAL0AAAI8AAIAr%2F9PAdwA1QAIAAwAAAURIzU2NjczESM1IRUBKmkpNRc0uwEtsQE0KQcREf56NjYAAQCS%2F08BvgDhABgAABcnPgI1NCYjIgYHJzY2MzIWFRQGBgczFaIEQ1wuLicbMhEmF0srPk4rSy%2B4sSU5UD4eJiwgGSMiKkA%2FJUNILTYAAQCO%2F0MBvQDhACgAAAUiJic3FhYzMjY1NCYjNTI2NTQmIyIGByc2NjMyFhYVFAYHFhYVFAYGASkzURcqEzkhJDRAQzw4LCQZLxImGUUrJT0lJygrMyhDvSoiIRweJCEjIygpHhwiGhYiHyIZMCAjLg8IMiYkNRwAAgCU%2F08BzgDhAAMACgAABREzESU1ExcHMxUBWjr%2FAJovhPWxAQr%2B9mghAQkZ4y4AAgCh%2F%2FQBtwE9AA0AGQAABSImJjU0NjMyFhUUBgYnMjY1NCYjIgYVFBYBLCg%2FJE88PU4kPyghLS0hIC4uDCdMM05VVU4zTCcyOTs8NjY8OzkAAAEA0AAAAWEBMQAIAAAhNSM1NjY3MxEBIlIhKRUy5ioFEAz%2BzwAAAQCtAAABpgE9ABgAADM1PgI1NCYjIgYHJzY2MzIWFRQGBgczFbc0SCUfHRQmDicWPCQ2PiE3IYgkKDwwFhwfFxMhGiM2MRszNR41AAEArP%2F0AaQBPQAnAAAFIiYnNxYWMzI2NTQmIzUyNjU0JiMiBgcnNjYzMhYVFAYHFhYVFAYGASsiRBkgDzEbGyMvMSkoGh0SKA8eEz4iLzsaHiEmIDcMHRknEhkWGRkaJhwXFBcSECYUGSwoHCQLBycfHSoWAAACAKwAAAG5AT0AAwAKAAAhNTMVJzU3FwczFQFOOdtxLmHP1dVKH9QUtSoAAAEArP%2F0AakBMQAeAAAFIiYnNxYWMzI2NTQmIyIGByc3MxUjBzYzMhYVFAYGAS0pPRsgESwfHSUkHxMeDx8RvYsKGR8yPiE4DB0ZJxIZHxocHgwLFJs2RgwzMCAvGwABALD%2F9AGtAT0AKAAABSImJjU0NjYzMhYXByYmIyIGBhUUFjMyNjU0JiMiBgcnNjYzMhYVFAYBOSc%2BJChFLR4tEhoNIBMeLBkxHRsfHB8VJRUCEzEcMzRBDCVELzlPKRIOKQsNHzssMy0eGBceEhUqEhU1Kis9AAABALcAAAGqATEADAAAMz4CNyM1MxUOAgf9AxYqIKnzKi0SAzRTTCk1JC5TVzUAAwCv%2F%2FQBqQE9ABkAJQAxAAAFIiY1NDY3NSYmNTQ2MzIWFRQGBxUWFhUUBic2NjU0JiMiBhUUFhcyNjU0JiYnBhUUFgEsOUQoGRYgRC4yQSITGiVHIhMRHRsZHi0KGikZJxcvJww1IyAlDAQOHxslLy8lHCELBAslISUzvQwaDxIYFxEWGJkZFBMVDwYVJhQbAAABAK3%2F9AGpAT0AKAAABSImJzcWFjMyNjY1NCYjIgYVFBYzMjY3FwYGIyImNTQ2MzIWFhUUBgYBDx4sExoOHxQeKxgvHhsfHB8VJhUCFDEcMzNBMic%2BJCdFDBMOKAoNHjssMy4eGRcdERUpExU1Kis9JUQvOU8pAAABAOz%2FtAGDAYsADQAABSYmNTQ2NxcGBhUUFhcBVTI3NzIuLSgoLUwxb0tLcDEhLWM7OmMuAAABANX%2FtAFsAYsADQAABSc2NjU0Jic3FhYVFAYBAy4tKCgtLjI3N0wgLmM6O2MtITFwS0tvAAABAPv%2F9QFdAFoACwAABSImNTQ2MzIWFRQGASwVHBwVFRwcCxsXFxwcFxcbAAEA9P%2BLAWcAWgAUAAAFJzY2JycXBgYjIiY1NDYzMhYVFAYBBhIeIwEFGwUQCBIeHhMbHjV1JwwlHTcuBgYWFhcaJyUsRv%2F%2FAKEBFAG3Al4CBwC%2BAAABIP%2F%2FANABIAFhAlICBwC%2FAAABIP%2F%2FAK0BIAGmAl4CBwDAAAABIP%2F%2FAKwBFAGkAl4CBwDBAAABIP%2F%2FAKwBIAG5Al4CBwDCAAABIP%2F%2FAKwBFAGpAlICBwDDAAABIP%2F%2FALABFAGtAl4CBwDEAAABIP%2F%2FALcBIAGqAlICBwDFAAABIP%2F%2FAK8BFAGpAl4CBwDGAAABIP%2F%2FAK0BFAGpAl4CBwDHAAABIP%2F%2FAOwA1AGDAqsCBwDIAAABIP%2F%2FANUA1AFsAqsCBwDJAAABIP%2F%2FAPsBFgFdAXoCBwDKAAABIP%2F%2FAPQAqwFnAXoCBwDLAAABIP%2F%2FAKMBgwG%2BAtQCBgDcAAD%2F%2FwCOAYMBygLUAgYA3QAAAAIAowGDAb4C1AAaACQAAAEiJjU0NjcuAiMiBgcnNjYzMhYVFSMnIwYGJzI2NzUGBhUUFgENLD5qcQEOIBwcNxcZGkwoQT81BAIZPBEaLxhVSCQBgzIqNDoJFSIUFA4rEBpHP8MmExsxFRNTCCUdGhcAAAIAjgGDAcoC1AAPABsAAAEiJiY1NDY2MzIWFhUUBgYnMjY1NCYjIgYVFBYBLCpILCxIKipILCxIKisxMSsrMTEBgydMNTZLKChLNjVMJzRANDVAQDU0QAACADoAUwIeAkEAIAAwAAA3JzcmJjU0NjcnNxc2MzIXNxcHFhYVFAYHFwcnBgYjIic3MjY2NTQmJiMiBgYVFBYWZixUEhISEVMsVzE%2BPTJXLFQRExMRVCxYFzkePzBvIDcfHzcgIDYgIDZTLVUXOyIjOxdWLVolJVotVhc7IyI7F1UtWRMTJhciPCgoPCIiPCgoPCIAAwBV%2F5ICAALsACoALgAyAAA3NxYWMzI2NTQuBDU0NjYzMhYXByYmIyIGFRQeBBUUBgYjIiYmEzUzFQMzFSNVJyVdODs%2BLkhRSC4yWTlCVSIsIj8yMzsuSFFJLjZfPyhQRaU8PDw8cTkbKTEmHyofHig7Ky9FJSwhMBseLSYbJhwfKT0uMEkoFiQB76Gh%2FfStAAACAE0AAAITAooAIgAnAAAzNTY2NTQuAjU0NjYzMhYXByYmIyIGFRQeAhUUBgcVIRUBNTchFU4%2BPhEYETRfPz5UHjAXOypBRg8VECQkAUj%2BOmcBBjIcYDgePDo7HTlSLSsgLxgdQTQeNzg8IjRHHwRHAR00BDgAAQA1AAACIwJ%2BAB0AACE1IzUzNSM1MwMzFxYWFzM2Njc3MwMzFSMVMxUjFQECtbW1oblVXBEiEgQSIhJcUrqit7e3njBBLwFAqyFDIyNDIav%2BwC9BMJ4AAAMAOv%2F0AjYCigAdACIAJwAABSImJjU0NjYzMhYXByYmIyIGBhUUFhYzMjY3FwYGATU3IRUFNTchFQF2THRCRHpSM1geMRk8JjtSKypQOCtCHTEmXP6GRQF2%2FkVEAU8MT5RnZ5VQLSEvGyBAd1BSeEEkIywrMgFrLAUxcywFMQAAAgBx%2F98B%2BgKNABwAIAAAJSImJjU0NjYzMhYXByYmIyIGBhUUFjMyNjcXBgYHETMRAVxFajxCbUIwRhgoFTAdMUopV0ojOhYkIVFOM0U5a01NbDciGDQUFitNNE5eHBM0HiJmAq79UgACABwAIAI8AnAAAwAHAAA3JzcXNyc3F00xtyGRIacxIC28Hpweyy3%2F%2FwAcACACPAJwAgYA5AAA%2F%2F8AHAAgAjwCcAIGAOQAAP%2F%2FABv%2F9AI9AooAJwC%2B%2F3oBTQImAOQAAAAHAL4AhgAA%2F%2F8AHAAAAj8CfgAnAL%2F%2FcwFNAiYA5AAAAAcAwgCGAAD%2F%2FwAcAAACPAJ%2BACcAv%2F9zAU0CJgDkAAAABwDAAI0AAP%2F%2FAB8AAAJVAooAJwDB%2F3MBTQAmAOQZAAAHAMIAhgAAAAEAVQBoAgMCLAALAAAlNSM1MzUzFTMVIxUBC7a2Qra2aMM%2Bw8M%2BwwABAFUBKwIDAWkAAwAAEzUhFVUBrgErPj4AAAEAZgB%2BAfICFQALAAA3JzcnNxc3FwcXByeSLJqaLJqaLJqaLJp%2BLZ%2BeLZ%2BfLZ6fLaAAAwBVAGACAwIzAAsAFwAbAAABIiY1NDYzMhYVFAYDIiY1NDYzMhYVFAYnNSEVASwXHx8XFx8fFxcfHxcXHx%2FuAa4ByB4YFx4eFxge%2FpgeGBceHhcYHss%2BPgD%2F%2FwBVAMACAwHUAiYA7ABrAAYA7ACVAAEAeAAwAe0CaAAHAAAlJTUlFQUVBQHt%2FosBdf7TAS0w%2FT79T8sEywABAGsAMAHgAmgABwAANzUlNSU1BRVrAS3%2B0wF1ME%2FLBMtP%2FT4AAAIAVQAAAgMCLAALAA8AACU1IzUzNTMVMxUjFQc1IRUBC7a2Qra2%2BAGuf7E%2Bvr4%2BsX8%2BPgABAG8BHAHpAp4ACQAAExMzEyMnJyMHB2%2BZSJlIQjEEMUIBHAGC%2Fn6whYWwAAEATAD%2FAgwBlQAZAAABIi4CIyIGBgcnNjYzMh4CMzI2NjcXBgYBhB0wKScVDxwbCzUaSSUeLyknFRAcGgs1GkgBARohGQ4lIxdHNhohGQ4lIxhGNgAAAQBVAGgCAwFpAAUAACU1ITUhEQHB%2FpQBrmjDPv7%2FAAACAK8BrQGqAq0ADwAbAAABIiYmNTQ2NjMyFhYVFAYGJzI2NTQmIyIGFRQWASwhOSMjOSEiOSMjOSIiKioiISoqAa0fOiYnOiAgOicmOh8uLiMlLi4lIy4AAQEBAbIBaAKyAAQAAAETMwcHAQEWUQ8iAbIBAGScAP%2F%2FAKgBsgHAArIAJgD3qAAABgD3WAD%2F%2FwBU%2F0UCJwHmAgYAfAAAAAEAIf%2FnAjcCDwAJAAAFEQcnATMBBycRAQq7LgEJBAEJLrsZAbfJKgEQ%2FvAqyf5JAAEAIf%2FnAjcCDwAJAAAFATcXETMRNxcBASr%2B9y67RLsu%2FvcZAREqyQG2%2FkrJKv7v%2F%2F8A0QFeAXwCuwIGAJMAAP%2F%2FANkBXgGEArsCBgCUAAD%2F%2FwCkAjgBbAMJAgYBBgAA%2F%2F8A7AI4AbQDCQIGAQkAAP%2F%2FAJECOAHHAuQCBgEMAAD%2F%2FwB%2FAkEB2QLRAgYBDgAA%2F%2F8AlAJMAcQCvAIGARMAAP%2F%2FAKcCWQGxApICBgEQAAD%2F%2FwC%2BAjkBmgL5AgYBFwAA%2F%2F8Azf8eAXoACAIGARoAAAABAKQCOAFsAwkAAwAAASc3FwFBnTqOAjiZOKgAAQCxArkBbQNjAAMAAAEnNxcBSZgvjQK5czeAAAEA0QIuAU0DAgADAAABJzcXARRDVScCLsUPyQABAOwCOAG0AwkAAwAAASc3FwEXK446AjgpqDgAAQDrArkBpwNjAAMAAAEnNxcBDySNLwK5KoA3AAEBCQIvAY0DHwADAAABJzcXAUI5L1UCLwrmDwABAJECOAHHAuQABwAAEyc3MxcHJyO0I3JSciN2BAI4IIyMIHEAAAEAmAK7AcADRgAHAAATJzczFwcnI7wkaVZpJG4EArsacXEaXQAAAQB%2FAkEB2QLRABkAAAEiLgIjIgYHJz4CMzIeAjMyNjcXDgIBdBonIB0RFhYDNwEWKyMbJiAdEhYWAjcBFisCQRkiGSskAyg9IxkiGSwjBCY9JAAAAQB7AsUB3QNJABcAAAEiLgIjIgYHJzY2MzIeAjMyNjcXBgYBdxwoIB4SExoDOAM2LRwpIB0SExoDOAI3AsUVHBYiIAQ6QRYbFiIgBDpBAAABAKcCWQGxApIAAwAAEzUhFacBCgJZOTkAAAEApgLfAbIDGAADAAATNSEVpgEMAt85OQAAAQDqAkwBbgLMAAsAAAEiJjU0NjMyFhUUBgEsHCYmHBwmJgJMIx0dIyMdHSMAAAIAlAJMAcQCvAALABcAABMiJjU0NjMyFhUUBjMiJjU0NjMyFhUUBssYHx8YGB8fqhgfHxgYHx8CTCEXFyEhFxchIRcXISEXFyEAAgCeAssBugMwAAsAFwAAEyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQG0RYdHRYWHBygFR0dFRccHALLHRYWHBwWFh0dFhYcHBYWHQABAOgCPAF8AvgADwAAASc2NjU0Jic3HgIVFAYGAQwJGR8pKgUtQCIgMwI8KAYWExYXAjYBFikeHSUXAAABAOgCugF7A2gADwAAASc2NjU0Jic3HgIVFAYGAQwJGR8pKgksPiAfMwK6JgcUExMWATACEiMaHSUWAAACAL4COQGaAvkACwAXAAABIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBLDM7OzM0Ojo0GCEhGBghIgI5OCgpNzcpKDglIhkaISEaGSIAAgDLArsBjQNwAAsAFwAAASImNTQ2MzIWFRQGJzI2NTQmIyIGFRQWASwqNzcqKTg4KRQfHxQWHh4CuzIoKTIyKSgyJBwaGR0dGRoc%2F%2F8A6v8pAW7%2FqAIHARIAAPzdAAEAzf8eAXoACAAPAAAXJzY2NTQmJzczBxYWFRQG1Qg%2FLiIrKDYaIyZV4igFFxYUFgZgSAggHyssAAABAM3%2FHgF6AAgADwAAFyc2NjU0Jic3MwcWFhUUBtUIPy4iKyg2GiMmVeIoBRcWFBYGYEgIIB8rLAAAAQEJ%2FvYBT%2F%2B5AAMAAAE3MxcBCQY6Bv72w8MAAAMAngJMAboDTAALABcAGwAAEyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQGJyc3F8wUGhoUFBkZrBMaGhMUGhp7I1IxAkwbEhQaGhQSGxsSFBoaFBIbdRhzIgADAJgCywHAA8gACwAXABsAABMiJjU0NjMyFhUUBjMiJjU0NjMyFhUUBicnNxfFExoaExQaGroUGhoUFBkZfCVfNQLLGhQUGRkUFBoaFBQZGRQUGmwadyQAAwCLAjQBzQMfAAsADwAbAAATIiY1NDYzMhYVFAYXNxcHNyImNTQ2MzIWFRQGuRMbGxMTGxs2MURLcxMbGxMTGxsCUxgTFRkZFRMYFuIN3h8YExUZGRUTGAAAAwCeAkwBugNMAAsAFwAbAAATIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAYnJzcXzBQaGhQUGRmsExoaExQaGm1gMVICTBsSFBoaFBIbGxIUGhoUEht1aSJzAAMAmALLAcADyAALABcAGwAAEyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQGJyc3F8UTGhoTFBoauhQaGhQUGRl6bzVfAssaFBQZGRQUGhoUFBkZFBQabG0kdwADAJECMwHHAwYACwAPABsAABMiJjU0NjMyFhUUBhcnNxc3IiY1NDYzMhYVFAa7EhgYEhIXF1xAQilJERgYERMXFwJTFxMTFxcTExcgxQ7JFhcTExcXExMXAAADAJMCTAHFAyYACwAXAC8AABMiJjU0NjMyFhUUBjMiJjU0NjMyFhUUBiciLgIjIgYHJzY2MzIeAjMyNjcXBgbMFBoaFBQZGawTGhoTFBoaLRolHRwSERgDKgMpJholHRwSERgDKgIqAkwbEhQaGhQSGxsSFBoaFBIbdw8TDxYYBCg0DhQPFxcEJjYAAAMAngJMAboDHQALABcAGwAAEyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQGJzUhFcwUGhoUExoarRMaGhMUGhr6AQsCTBsSFBoaFBIbGxIUGhoUEhuiLy8AAwCYAssBwAOLAAsAFwAbAAATIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAYlNSEVxRMaGhMUGhq6FBoaFBMaGv8AAQwCyxoUFBkZFBQaGhQUGRkUFBqSLi4AAAA%3D%29%20format%28%27truetype%27%29%3B%0A%7D%0A);*:where(:not(iframe, canvas, img, svg, video):not(svg *, symbol *)){all:unset;display:revert}*,*::before,*::after{box-sizing:border-box}ol,ul{list-style:none}img{max-width:100%}table{border-collapse:collapse}textarea{white-space:revert}html,body{font-family:'Lato', Arial, sans-serif}pre,code,kbd,samp{font-family:'Source Code Pro', monospace}:root{--background: whitesmoke;--pagedjs-width: 210mm;--pagedjs-height: 297mm;--color-paper: white;--color-mbox: rgba(0, 0, 0, 0.2);--running-title-width: 2.5in;--screen-pages-spacing: 5mm}body{color:#000;font-size:13.5px;line-height:1.5}h6,h5,h4,h3,h2,h1{line-height:1.2;margin-bottom:0.75em}h3,h2,h1{color:#0072BC}h4,h5,h6{font-weight:700}h1{font-size:2.5em}h2{font-size:2em;margin-bottom:0.65em}h3{font-size:1.75em}h4{display:table;color:#ffffff;font-size:1em;text-transform:uppercase;background-color:#0072BC;padding:0.25em}h5{font-size:1.25em}h6{font-size:0.9em;text-transform:uppercase}p{margin-bottom:1.2em}blockquote{margin-bottom:1em;quotes:"“" "”" "‘" "’"}blockquote>:first-child{font-size:1.2em;font-style:italic;margin-bottom:0;color:#0072BC;quotes:"“" "”" "‘" "’"}blockquote>:first-child::before{content:open-quote}blockquote>:first-child::after{content:close-quote}blockquote>:last-child{font-weight:700;text-align:end}blockquote>:last-child::before{content:"— "}blockquote>:only-child{font-weight:400;text-align:start}blockquote>:only-child::before,blockquote>:only-child::after{content:none}em{font-style:italic}b,strong{font-weight:700}small{font-size:0.875em}big,.lead{font-size:1.2em}mark{padding:0.2em;background-color:#FFF9CB}sub,sup{position:relative;font-size:0.75em;line-height:0;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}a{color:#0072BC;text-decoration:underline}u{text-decoration:underline}del{text-decoration:line-through}.footnote{font-size:0.75em !important;font-style:italic}.footnote-ref{text-decoration:none;color:#000}ol,ul{padding-left:1em;list-style:square}ol,ul,dl{margin-bottom:1em;line-height:1.25}ul li::marker,ol li::marker{color:#0072BC}ol ol,ul ul,ol ul,ul ol{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:0.5em;margin-left:0}pre{display:block;margin-bottom:1em;font-size:0.85em;padding:1em}pre[class]{background:rgba(0,0,0,0.05)}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:0.85em;word-wrap:break-word}figure{margin-bottom:1em}img,svg{vertical-align:middle;max-width:100%}img+em,caption,.caption{font-size:0.85em;font-style:italic}table{--unhcr-table-accent-bg: transparent;width:100%;margin-bottom:1em;vertical-align:top}table>:not(caption)>*>*{padding:0.25em 0.5em;background-color:transparent;border-bottom:1px solid #ccc;box-shadow:inset 0 0 0 9999px var(--unhcr-table-accent-bg)}table>caption{caption-side:bottom;margin-top:0.25em}table>tbody{vertical-align:inherit}table>thead{vertical-align:bottom}table>thead>*>*{border-bottom:1.5px solid #0072BC;font-weight:700}.table-noborder>tbody>*>*{border-bottom:0 solid transparent}.table-grey>tbody>tr:nth-of-type(odd)>*{--unhcr-table-accent-bg: rgba(0, 0, 0, 0.05)}.table-blue>tbody>tr:nth-of-type(odd)>*{--unhcr-table-accent-bg: rgba(0, 114, 188, 0.1)}.table-narrow{width:inherit;margin-right:auto;margin-left:auto}.img75,.img66,.img50,.img33,.img25{margin-left:auto;margin-right:auto}.img25{max-width:25%}.img33{max-width:33%}.img50{max-width:50%}.img66{max-width:66%}.img75{max-width:75%}.col2{columns:2}.float-start{float:left !important;margin-right:1em}.float-end{float:right !important;margin-left:1em}.clearfix::after{display:block;clear:both;content:""}.blue{color:#0072BC}.grey{color:#666}.bg-blue,.bg-grey{padding:1.2em;margin-bottom:1em}.bg-blue{background-color:#DCE9FF}.bg-grey{background-color:#E6E6E6}.bg-blue>*:last-child,.bg-grey>*:last-child{margin-bottom:0;padding-bottom:0}a[href^="http"]:not([class="uri"])::after{content:" (" attr(href) ")";font-size:90%;hyphens:none;word-break:break-all}.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after{content:" (page " target-counter(attr(href), page) ")"}.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after{content:unset}@media screen{body{background-color:var(--background);margin:var(--screen-pages-spacing) auto 0 auto}.pagedjs_pages{display:flex;max-width:calc(var(--pagedjs-width) * 2);flex:0;flex-wrap:wrap;margin:0 auto}.pagedjs_page{background-color:var(--color-paper);box-shadow:0 0 0 1px var(--color-mbox);flex-shrink:0;flex-grow:0;margin:auto auto var(--screen-pages-spacing) auto}}@media screen and (min-width: 12.32in){.pagedjs_page{margin:auto 0 var(--screen-pages-spacing) 0}.pagedjs_first_page{margin-left:var(--pagedjs-width)}}@media screen and (max-width: 1180px){body{width:calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing))}}@page{size:210mm 297mm;margin:45mm 25mm 25mm 25mm}@page :blank{}h1.title{string-set:h1-title content(text)}h1.subtitle{string-set:h1-subtitle content(text)}h2.date{string-set:h2-date content(text)}h2.author{string-set:h2-author content(text)}address.author-afil{string-set:address-author-afil content(text)}a.email{string-set:a-author-email content(text)}@page{background-image:url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMjUuOSIgaGVpZ2h0PSI1NC4zIiB2aWV3Qm94PSIwIDAgMjI1LjkgNTQuMyI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDcyYmM7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTMzLDM2LjdjLjYsMCwuNi0uNC42LTFWMzIuNGMwLS43LS4xLS45LjMtLjksMS40LDAsMS43LS4xLDEuNy0xLjNWMTcuOWMwLTMuMy0yLjQtMi44LTMtNC0xLTEuNiwxLjgtMS42LjgtNS4yYTIsMiwwLDAsMC0yLjEtMS4zLDIsMiwwLDAsMC0yLjEsMS4zYy0xLDMuNiwxLjcsMy42LjgsNS4yLS43LDEuMi0zLC43LTMsNFYzMC4yYzAsMS4yLjQsMS4zLDEuNywxLjMuNCwwLC4zLjIuMy45djMuM2MwLC43LS4xLDEsLjYsMUgzMyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIyLjMsMTAuMWMtMS4yLDEuMy0zLjEsNC4zLTEuOSw2LjgsMi41LDEsMi4zLTgsNS41LTcuOSwxLjYsMS40LS41LDUuNy0xLjEsNy41LS44LDIuMy0xLjQsNy4xLTIuOSw5LjUtMS4yLDItLjMsOC4xLS43LDEwLjItMSwxLTMuOS4zLTUuMS4xYTgxLjc2LDgxLjc2LDAsMCwwLS43LTguMmMwLS44LS45LTEyLjctLjItMTQuMUMxNi42LDExLDI0LDUuMywyNSw0LjJTMjksMCwzMC4zLDBjLjkuNi40LDIsLjIsMi41LTEuMiwzLTYuNSw2LTguMiw3LjYiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik00MC40LDEwLjFjMS4yLDEuMywzLjEsNC4zLDEuOSw2LjgtMi42LDEtMi40LTgtNS41LTcuOS0xLjUsMS40LjUsNS43LDEuMSw3LjUuOCwyLjMsMS40LDcuMSwyLjksOS41LDEuMiwyLC4zLDguMS43LDEwLjIsMS4xLDEsMy45LjMsNS4xLjFhNzUuNTgsNzUuNTgsMCwwLDEsLjctOC4yYy4xLS44LjktMTIuNy4yLTE0LjEtMS40LTMtOC44LTguNy05LjgtOS44UzMzLjYsMCwzMi40LDBjLS45LjYtLjMsMi0uMiwyLjUsMS4zLDMsNi41LDYsOC4yLDcuNiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTExLjUsNi4xYy0uNy42LTIuMSwxLjEtMy4yLDIuNC0uNC0uNy42LTIuNSwxLjgtMy42YTE3LjY4LDE3LjY4LDAsMCwxLDMuMi0yLjFjLjQuOS0xLDIuMy0xLjgsMy4zIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOS40LDExYy0xLjEsMS0yLjMsMS41LTMuOSwzLjRhMTIuMjIsMTIuMjIsMCwwLDEtLjItNS43Yy42LTEuOCwxLjUtMy44LDMtNC40YTE1LjY5LDE1LjY5LDAsMCwwLS45LDQuM2MtLjcsMi42LTEsMi43LS45LDMsLjIsMCwxLTEuNCwyLjEtMi40QzkuOCw4LDExLjQsNy43LDEyLjQsNi45YTE3LjMsMTcuMywwLDAsMS0zLDQuMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTMuOSwyMS44YTE0LjMxLDE0LjMxLDAsMCwxLTEuOC03Yy4xLTEuNi45LTUuMywyLTUuOS0uMywzLjQuNiwzLjcuMiw2LjQsMCwuMS0uNCwzLS40LDMuMi41LS4xLDAtMi42LDUuNC02LjQtMS4yLDItLjYsMi42LTIuNyw1LjNhMTAuNzQsMTAuNzQsMCwwLDAtMi43LDQuNCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTYuMSwyNC4zYTYuNjMsNi42MywwLDAsMC0xLjIsMy4yQzIuMiwyNi0uOSwxOS44LjIsMTYuN2MuNywyLjMsMS43LDIuOSwyLjQsNC44LDEuMiwyLjksMSwzLjgsMS44LDQuNWE5LDksMCwwLDEsLjktNC42LDMyLjA3LDMyLjA3LDAsMCwxLDEuOS0zLjFjLjUsMi4xLjEsMy44LTEuMSw2Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOC41LDI5LjZhNDYsNDYsMCwwLDEtLjYsNS4yQzMuMywzMy4zLjgsMjgsLjgsMjUuNGMxLjQsMy4yLDMuNSwzLjIsNi4yLDcuNy4yLTEuNy0uNS0uNC0uNi0zLjcuMS0zLjQuOC0zLjUuOS01LjYuOS45LDEuMiw0LjcsMS4yLDUuOCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEyLjMsMzYuNGMuNCwxLjguNSwzLjguOCw1LjMtMi43LTEtMy4zLS4yLTYuNS0yLjItMS40LS44LTQtNC4xLTMuOS02LjQsMy4xLDMuNSwzLjcsMy4xLDUuMiw0LjQsMS40LDEuMSwyLjUsMi44LDMuNiwyLjYuMS0uOS0yLjMtMy0yLTguOGExNC4xNSwxNC4xNSwwLDAsMSwyLjgsNS4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTcuNiw0MC44Yy44LDEuMi42LDEuNywyLjcsNC4xQTI1LjU0LDI1LjU0LDAsMCwxLDE0LjgsNDZjLTEuMywwLTYtMS4yLTcuNi00LjQsMi43LDEuNCwyLjcsMS4xLDYuMywxLjksMi42LjYsNC40LDEuNCw1LjEsMS4zLS4xLS4zLTIuMS0xLjItMy41LTIuOXMtMS0zLjktMi4zLTUuNGMuOS0uNCw0LjEsMy40LDQuOCw0LjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01MSw2LjFjLjYuNiwyLjIsMS4xLDMuMSwyLjQuNC0uNy0uNi0yLjUtMS44LTMuNmExNC43NywxNC43NywwLDAsMC0zLjItMi4xYy0uNC45LDEsMi4zLDEuOSwzLjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01My4xLDExYzEuMSwxLDIuMywxLjUsMy45LDMuNGExMi4yMiwxMi4yMiwwLDAsMCwuMi01LjdjLS41LTEuOC0xLjUtMy44LTMtNC40YTE1LjY5LDE1LjY5LDAsMCwxLC45LDQuM2MuNywyLjYsMSwyLjcuOSwzLS4yLDAtMS0xLjQtMi4xLTIuNEM1Mi43LDgsNTEuMiw3LjcsNTAuMSw2LjlhMTcuMywxNy4zLDAsMCwwLDMsNC4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTguNSwyMS44YTE0LDE0LDAsMCwwLDEuOC03Yy0uMS0xLjYtLjktNS4zLTItNS45LjMsMy40LS42LDMuNy0uMiw2LjQsMCwuMS4zLDMsLjMsMy4yLS40LS4xLDAtMi42LTUuMy02LjQsMS4xLDIsLjYsMi42LDIuNyw1LjNhOS4yOCw5LjI4LDAsMCwxLDIuNyw0LjQiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01Ni40LDI0LjNhOS41OCw5LjU4LDAsMCwxLDEuMiwzLjJjMi43LTEuNiw1LjgtNy44LDQuNi0xMC44LS43LDIuMy0xLjcsMi45LTIuMyw0LjgtMS4zLDIuOS0xLjEsMy44LTEuOCw0LjVhMTEuNzksMTEuNzksMCwwLDAtLjktNC42LDE5LjgyLDE5LjgyLDAsMCwwLTEuOS0zLjEsNy41MSw3LjUxLDAsMCwwLDEuMSw2Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTQsMjkuNmEzMC45MiwzMC45MiwwLDAsMCwuNyw1LjJjNC42LTEuNSw3LjEtNi44LDcuMS05LjQtMS41LDMuMi0zLjUsMy4yLTYuMiw3LjctLjItMS43LjUtLjQuNS0zLjdzLS44LTMuNS0uOS01LjZjLS45LjktMS4yLDQuNy0xLjIsNS44Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTAuMSwzNi40Yy0uNCwxLjgtLjUsMy44LS43LDUuMywyLjYtMSwzLjMtLjIsNi40LTIuMiwxLjQtLjgsNC4xLTQuMSwzLjktNi40LTMuMSwzLjUtMy43LDMuMS01LjIsNC40LTEuNCwxLjEtMi42LDIuOC0zLjYsMi42LS4xLS45LDIuMy0zLDItOC44YTE1Ljg0LDE1Ljg0LDAsMCwwLTIuOCw1LjEiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik00NC45LDQwLjhhMTYuMTksMTYuMTksMCwwLDEtMi43LDQuMUEyNi44MSwyNi44MSwwLDAsMCw0Ny43LDQ2YzEuMywwLDYtMS4yLDcuNS00LjQtMi43LDEuNC0yLjcsMS4xLTYuMywxLjktMi42LjYtNC40LDEuNC01LjEsMS4zLjItLjMsMi4yLTEuMiwzLjUtMi45czEtMy45LDIuMy01LjRjLS45LS40LTQsMy40LTQuNyw0LjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yNC42LDUxLjhsLS44LS40YTE3LjIsMTcuMiwwLDAsMSwxMy41LTUuNmM4LjUuNSw3LjksMi41LDEyLjUsMi4xLjUsMC0uNC42LS40LjZhMTUuNTYsMTUuNTYsMCwwLDEtMTAtLjJjLTUuNS0xLjgtOS4xLTIuOS0xNC44LDMuNSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTM4LDUxLjhsLjgtLjRhMTcsMTcsMCwwLDAtMTMuNC01LjZjLTguNS41LTcuOSwyLjUtMTIuNSwyLjEtLjUsMCwuNC42LjQuNmExNS41NiwxNS41NiwwLDAsMCwxMC0uMmM1LjUtMS44LDktMi45LDE0LjcsMy41Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOTguMywyNS41YzAsOC4xLTQuNCwxMi4xLTEzLjQsMTIuMVM3MS41LDMzLjcsNzEuNSwyNS41VjcuNWg5djE2YzAsMywwLDYuOCw0LjQsNi44czQuMy0zLjgsNC4zLTYuOFY3LjVoOS4xdjE4Ii8+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjEwMy43IDcuNCAxMTMgNy40IDEyMS42IDIzLjEgMTIxLjYgMjMuMSAxMjEuNiA3LjQgMTMwLjIgNy40IDEzMC4yIDM2LjggMTIxLjQgMzYuOCAxMTIuNCAyMC44IDExMi4zIDIwLjggMTEyLjMgMzYuOCAxMDMuNyAzNi44IDEwMy43IDcuNCIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSIxMzUuOCA3LjQgMTQ0LjggNy40IDE0NC44IDE3LjYgMTUzLjMgMTcuNiAxNTMuMyA3LjQgMTYyLjMgNy40IDE2Mi4zIDM2LjggMTUzLjMgMzYuOCAxNTMuMyAyNS4yIDE0NC44IDI1LjIgMTQ0LjggMzYuOCAxMzUuOCAzNi44IDEzNS44IDcuNCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTE4NS41LDE4LjRhNC42OSw0LjY5LDAsMCwwLTQuNy00LjNjLTQuMiwwLTUuNiw0LjEtNS42LDguMXMxLjQsOC4xLDUuNiw4LjFjMywwLDQuMi0yLjEsNC44LTQuOWg4LjljMCw1LjktNC44LDEyLjItMTMuNCwxMi4yLTkuNSwwLTE0LjktNi43LTE0LjktMTUuNCwwLTkuMyw1LjgtMTUuNCwxNC45LTE1LjQsOC4xLDAsMTIuNSw0LjMsMTMuMywxMS42aC04LjkiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMDcuMywxNC40aDQuMmMzLjUsMCw0LjUsMS4xLDQuNSwyLjksMCwyLjYtMi4zLDIuOS00LDIuOWgtNC43Wm0tOS4xLDIyLjRoOS4xVjI2LjZoNC44YzMuNiwwLDMuOCwyLjksNC4xLDUuN2EyMy4zOCwyMy4zOCwwLDAsMCwuNyw0LjVoOWMtLjgtMS40LS45LTQuOS0xLTYuMy0uMy0zLjctMS45LTYuNC00LjMtNy4zLDMtMS4xLDQuNC00LjMsNC40LTcuNCwwLTUuNi00LjQtOC40LTkuNi04LjRIMTk4LjJWMzYuOCIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSI3NC41IDQzLjYgNzEuNSA0My42IDcxLjUgNDEuNyA3OS42IDQxLjcgNzkuNiA0My42IDc2LjYgNDMuNiA3Ni42IDUxLjYgNzQuNSA1MS42IDc0LjUgNDMuNiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTgwLjMsNDEuN2gydjMuN2gwYTIuNDQsMi40NCwwLDAsMSwyLjEtMS4yYzIuMSwwLDIuNiwxLjIsMi42LDIuOXY0LjRIODV2LTRjMC0xLjItLjMtMS44LTEuMy0xLjhzLTEuNS42LTEuNSwydjMuN2gtMmwuMS05LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik04OS43LDQ4LjVxLjE1LDEuOCwxLjgsMS44YTEuNjUsMS42NSwwLDAsMCwxLjUtLjloMS43YTMuMjIsMy4yMiwwLDAsMS0zLjMsMi40LDMuNDYsMy40NiwwLDAsMS0zLjYtMy4zdi0uNGEzLjU5LDMuNTksMCwwLDEsMy40LTMuOGguM2MyLjQsMCwzLjYsMiwzLjUsNC4yWm0zLjItMS4yYy0uMi0xLS42LTEuNS0xLjYtMS41YTEuNTUsMS41NSwwLDAsMC0xLjYsMS40di4xaDMuMiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEwNy42LDQ3LjljMCwyLjctMS42LDQtNC4yLDRzLTQuMi0xLjMtNC4yLTRWNDEuOGgyLjJ2Ni4xYzAsMS4xLjMsMi4xLDIsMi4xLDEuNSwwLDItLjcsMi0yLjFWNDEuOGgyLjJ2Ni4xIi8+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjEwOSA0MS43IDExMS4yIDQxLjcgMTE1LjMgNDguMyAxMTUuMyA0OC4zIDExNS4zIDQxLjcgMTE3LjQgNDEuNyAxMTcuNCA1MS42IDExNS4yIDUxLjYgMTExLjEgNDUgMTExLjEgNDUgMTExLjEgNTEuNiAxMDkgNTEuNiAxMDkgNDEuNyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEyNC4yLDQzLjRoMi40YzEsMCwxLjUuNCwxLjUsMS40cy0uNSwxLjQtMS41LDEuNGgtMi40Wm0tMi4xLDguMmgyLjJWNDcuOGgyLjJjMS4xLDAsMS41LjUsMS42LDEuNWE2LjcyLDYuNzIsMCwwLDAsLjQsMi40aDIuMmE1Ljg3LDUuODcsMCwwLDEtLjQtMi4zYy0uMS0xLS40LTItMS40LTIuM2gwYTIuNSwyLjUsMCwwLDAsMS42LTIuNSwyLjY5LDIuNjksMCwwLDAtMi43LTIuN2gtNS41bC0uMiw5LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xMzMuMiw0Ny4zYTEuNTQsMS41NCwwLDAsMSwxLjUtMS41aC4xYy45LDAsMS40LjUsMS42LDEuNVptNS4xLDEuMmMuMS0yLjItMS00LjItMy41LTQuMmEzLjUsMy41LDAsMCwwLTMuNiwzLjVWNDhhMy40LDMuNCwwLDAsMCwzLjIsMy43aC40YTMuMjIsMy4yMiwwLDAsMCwzLjMtMi40aC0xLjdhMS40OSwxLjQ5LDAsMCwxLTEuNS45cS0xLjY1LDAtMS44LTEuOGw1LjIuMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEzOS42LDQ1LjhoLTEuMlY0NC41aDEuMlY0NGEyLjA1LDIuMDUsMCwwLDEsMi0yLjJoLjRhMy4wOCwzLjA4LDAsMCwxLDEsLjF2MS41aC0uN2MtLjUsMC0uNy4yLS43Ljh2LjRIMTQzdjEuM2gtMS40djUuOGgtMlY0NS44Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTUwLjIsNTEuNmgtMS45di0xaDBhMi43NSwyLjc1LDAsMCwxLTIuMiwxLjJjLTIuMSwwLTIuNi0xLjItMi42LTIuOVY0NC41aDJ2NGMwLDEuMi40LDEuOCwxLjMsMS44LDEuMSwwLDEuNS0uNiwxLjUtMlY0NC41aDJ2Ny4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTU0LjcsNDkuOWMtMS4yLDAtMS42LTEuMS0xLjYtMi4xcy41LTIsMS42LTJjMS4zLDAsMS43LDEsMS43LDIuMmExLjczLDEuNzMsMCwwLDEtMS41LDJjLS4xLDAtLjEsMC0uMi0uMW0zLjYtNS40aC0xLjl2MWgwYTIsMiwwLDAsMC0yLjEtMS4xLDMuMjEsMy4yMSwwLDAsMC0zLjEsMy41YzAsMS44LjksMy42LDMsMy42YTIuMzYsMi4zNiwwLDAsMCwyLjEtMS4xaDB2LjljMCwxLS41LDEuOC0xLjYsMS44YTEuMzMsMS4zMywwLDAsMS0xLjUtMWgtMS45Yy4xLDEuNiwxLjcsMi4zLDMuMSwyLjMsMy4zLDAsMy43LTIsMy43LTMuMmwuMi02LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xNjEuMiw0Ny4zYTEuNTQsMS41NCwwLDAsMSwxLjUtMS41aC4xYzEsMCwxLjQuNSwxLjYsMS41Wm01LjEsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNSwzLjUsMCwwLDAtMy42LDMuNVY0OGEzLjQsMy40LDAsMCwwLDMuMiwzLjdoLjRhMy4yMiwzLjIyLDAsMCwwLDMuMy0yLjRoLTEuN2ExLjQ5LDEuNDksMCwwLDEtMS41LjlxLTEuNjUsMC0xLjgtMS44bDUuMi4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTY4LjksNDcuM2ExLjUsMS41LDAsMCwxLDEuNi0xLjVoLjFjLjksMCwxLjQuNSwxLjYsMS41Wm01LjEsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNSwzLjUsMCwwLDAtMy42LDMuNVY0OGEzLjQsMy40LDAsMCwwLDMuMiwzLjdoLjRhMy4xNSwzLjE1LDAsMCwwLDMuMy0yLjRoLTEuN2ExLjU0LDEuNTQsMCwwLDEtMS42LjlxLTEuNjUsMC0xLjgtMS44bDUuMy4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTgzLDQ0LjJoMGwxLjIsMy42aC0yLjZabS00LjgsNy40aDIuMmwuOC0yLjJoMy43bC43LDIuMmgyLjNsLTMuNy05LjhIMTgyWiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTE5MS41LDQ5LjljLTEuMiwwLTEuNi0xLjEtMS42LTIuMXMuNS0yLDEuNi0yYzEuMywwLDEuNywxLDEuNywyLjJhMS44LDEuOCwwLDAsMS0xLjUsMmMtLjEsMC0uMiwwLS4yLS4xbTMuNS01LjRoLTEuOXYxaDBhMi4wOSwyLjA5LDAsMCwwLTIuMS0xLjEsMy4yMSwzLjIxLDAsMCwwLTMuMSwzLjVjMCwxLjguOSwzLjYsMy4xLDMuNmEyLjM2LDIuMzYsMCwwLDAsMi4xLTEuMWgwdi45YzAsMS0uNSwxLjgtMS42LDEuOGExLjMzLDEuMzMsMCwwLDEtMS41LTFoLTEuOWMuMSwxLjYsMS43LDIuMywzLjEsMi4zLDMuMywwLDMuNy0yLDMuNy0zLjJsLjEtNi43Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTk3LjksNDcuM2ExLjUsMS41LDAsMCwxLDEuNi0xLjVoLjFjLjksMCwxLjQuNSwxLjYsMS41Wm01LjIsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNTYsMy41NiwwLDAsMC0zLjYsMy41VjQ4YTMuNCwzLjQsMCwwLDAsMy4yLDMuN2guNGEzLjIyLDMuMjIsMCwwLDAsMy4zLTIuNGgtMS43YTEuNTQsMS41NCwwLDAsMS0xLjYuOXEtMS42NSwwLTEuOC0xLjhsNS4zLjEiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMDMuOSw0NC41aDEuOXYxaC4xYTIuNzUsMi43NSwwLDAsMSwyLjItMS4yYzIuMSwwLDIuNiwxLjIsMi42LDIuOXY0LjRoLTJ2LTRjMC0xLjItLjMtMS44LTEuMy0xLjhzLTEuNS42LTEuNSwydjMuN2gtMnYtNyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIxNi42LDQ3YTEuMzIsMS4zMiwwLDAsMC0xLjQtMS4yaDBjLTEuMywwLTEuNywxLjMtMS43LDIuM3MuNCwyLjIsMS42LDIuMmExLjYyLDEuNjIsMCwwLDAsMS42LTEuNGgxLjlhMy4wOCwzLjA4LDAsMCwxLTMuNCwyLjloMGEzLjQ2LDMuNDYsMCwwLDEtMy42LTMuM3YtLjNhMy40MywzLjQzLDAsMCwxLDMuMi0zLjhoLjVhMy4xMiwzLjEyLDAsMCwxLDMuNCwyLjdsLTIuMS0uMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIyMyw1Mi41YTIuMjEsMi4yMSwwLDAsMS0yLjUsMS42LDQuODcsNC44NywwLDAsMS0xLjItLjFWNTIuNGMuNCwwLC44LjEsMS4xLjFhMS4wOCwxLjA4LDAsMCwwLC44LTEuMS4zNy4zNywwLDAsMC0uMS0uM2wtMi41LTYuN2gyLjFsMS42LDQuOWgwbDEuNi00LjloMkwyMjMsNTIuNSIvPjwvc3ZnPg=="),url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxODBtbSIgaGVpZ2h0PSIzLjMxbW0iIHZpZXdCb3g9IjAgMCA1MTAuMjQgOS4zOSI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOm5vbmU7c3Ryb2tlOiMwMDcyYmM7c3Ryb2tlLXdpZHRoOjAuNXB4O308L3N0eWxlPjwvZGVmcz48cG9seWxpbmUgY2xhc3M9ImNscy0xIiBwb2ludHM9IjAgMC4yNSAzMC4wNSAwLjI1IDM4LjgzIDkuMDQgNDcuMzEgMC4yNSA1MTAuMjQgMC4yNSIvPjwvc3ZnPg==);background-repeat:no-repeat, no-repeat;background-position:15mm 10mm, 15mm 22mm;background-size:36mm, 180mm;@top-right{content:string(h1-title) " > " string(h1-subtitle);margin-right:-10mm;margin-top:14mm;color:#666;font-size:1em;text-transform:uppercase;vertical-align:top}@bottom-right{content:counter(page);margin-right:-10mm;margin-top:10mm;padding-top:1.5mm;color:#0072BC;font-size:0.8em;vertical-align:top;border-top:0.5px solid #0072BC}@bottom-left{content:"UNHCR / " string(h2-date);margin-left:-10mm;margin-top:10mm;padding-top:1.5mm;color:#0072BC;font-size:0.8em;vertical-align:top;border-top:0.5px solid #0072BC}}@page :first{background-image:url("data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMjUuOSIgaGVpZ2h0PSI1NC4zIiB2aWV3Qm94PSIwIDAgMjI1LjkgNTQuMyI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDcyYmM7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTMzLDM2LjdjLjYsMCwuNi0uNC42LTFWMzIuNGMwLS43LS4xLS45LjMtLjksMS40LDAsMS43LS4xLDEuNy0xLjNWMTcuOWMwLTMuMy0yLjQtMi44LTMtNC0xLTEuNiwxLjgtMS42LjgtNS4yYTIsMiwwLDAsMC0yLjEtMS4zLDIsMiwwLDAsMC0yLjEsMS4zYy0xLDMuNiwxLjcsMy42LjgsNS4yLS43LDEuMi0zLC43LTMsNFYzMC4yYzAsMS4yLjQsMS4zLDEuNywxLjMuNCwwLC4zLjIuMy45djMuM2MwLC43LS4xLDEsLjYsMUgzMyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIyLjMsMTAuMWMtMS4yLDEuMy0zLjEsNC4zLTEuOSw2LjgsMi41LDEsMi4zLTgsNS41LTcuOSwxLjYsMS40LS41LDUuNy0xLjEsNy41LS44LDIuMy0xLjQsNy4xLTIuOSw5LjUtMS4yLDItLjMsOC4xLS43LDEwLjItMSwxLTMuOS4zLTUuMS4xYTgxLjc2LDgxLjc2LDAsMCwwLS43LTguMmMwLS44LS45LTEyLjctLjItMTQuMUMxNi42LDExLDI0LDUuMywyNSw0LjJTMjksMCwzMC4zLDBjLjkuNi40LDIsLjIsMi41LTEuMiwzLTYuNSw2LTguMiw3LjYiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik00MC40LDEwLjFjMS4yLDEuMywzLjEsNC4zLDEuOSw2LjgtMi42LDEtMi40LTgtNS41LTcuOS0xLjUsMS40LjUsNS43LDEuMSw3LjUuOCwyLjMsMS40LDcuMSwyLjksOS41LDEuMiwyLC4zLDguMS43LDEwLjIsMS4xLDEsMy45LjMsNS4xLjFhNzUuNTgsNzUuNTgsMCwwLDEsLjctOC4yYy4xLS44LjktMTIuNy4yLTE0LjEtMS40LTMtOC44LTguNy05LjgtOS44UzMzLjYsMCwzMi40LDBjLS45LjYtLjMsMi0uMiwyLjUsMS4zLDMsNi41LDYsOC4yLDcuNiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTExLjUsNi4xYy0uNy42LTIuMSwxLjEtMy4yLDIuNC0uNC0uNy42LTIuNSwxLjgtMy42YTE3LjY4LDE3LjY4LDAsMCwxLDMuMi0yLjFjLjQuOS0xLDIuMy0xLjgsMy4zIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOS40LDExYy0xLjEsMS0yLjMsMS41LTMuOSwzLjRhMTIuMjIsMTIuMjIsMCwwLDEtLjItNS43Yy42LTEuOCwxLjUtMy44LDMtNC40YTE1LjY5LDE1LjY5LDAsMCwwLS45LDQuM2MtLjcsMi42LTEsMi43LS45LDMsLjIsMCwxLTEuNCwyLjEtMi40QzkuOCw4LDExLjQsNy43LDEyLjQsNi45YTE3LjMsMTcuMywwLDAsMS0zLDQuMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTMuOSwyMS44YTE0LjMxLDE0LjMxLDAsMCwxLTEuOC03Yy4xLTEuNi45LTUuMywyLTUuOS0uMywzLjQuNiwzLjcuMiw2LjQsMCwuMS0uNCwzLS40LDMuMi41LS4xLDAtMi42LDUuNC02LjQtMS4yLDItLjYsMi42LTIuNyw1LjNhMTAuNzQsMTAuNzQsMCwwLDAtMi43LDQuNCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTYuMSwyNC4zYTYuNjMsNi42MywwLDAsMC0xLjIsMy4yQzIuMiwyNi0uOSwxOS44LjIsMTYuN2MuNywyLjMsMS43LDIuOSwyLjQsNC44LDEuMiwyLjksMSwzLjgsMS44LDQuNWE5LDksMCwwLDEsLjktNC42LDMyLjA3LDMyLjA3LDAsMCwxLDEuOS0zLjFjLjUsMi4xLjEsMy44LTEuMSw2Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOC41LDI5LjZhNDYsNDYsMCwwLDEtLjYsNS4yQzMuMywzMy4zLjgsMjgsLjgsMjUuNGMxLjQsMy4yLDMuNSwzLjIsNi4yLDcuNy4yLTEuNy0uNS0uNC0uNi0zLjcuMS0zLjQuOC0zLjUuOS01LjYuOS45LDEuMiw0LjcsMS4yLDUuOCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEyLjMsMzYuNGMuNCwxLjguNSwzLjguOCw1LjMtMi43LTEtMy4zLS4yLTYuNS0yLjItMS40LS44LTQtNC4xLTMuOS02LjQsMy4xLDMuNSwzLjcsMy4xLDUuMiw0LjQsMS40LDEuMSwyLjUsMi44LDMuNiwyLjYuMS0uOS0yLjMtMy0yLTguOGExNC4xNSwxNC4xNSwwLDAsMSwyLjgsNS4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTcuNiw0MC44Yy44LDEuMi42LDEuNywyLjcsNC4xQTI1LjU0LDI1LjU0LDAsMCwxLDE0LjgsNDZjLTEuMywwLTYtMS4yLTcuNi00LjQsMi43LDEuNCwyLjcsMS4xLDYuMywxLjksMi42LjYsNC40LDEuNCw1LjEsMS4zLS4xLS4zLTIuMS0xLjItMy41LTIuOXMtMS0zLjktMi4zLTUuNGMuOS0uNCw0LjEsMy40LDQuOCw0LjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01MSw2LjFjLjYuNiwyLjIsMS4xLDMuMSwyLjQuNC0uNy0uNi0yLjUtMS44LTMuNmExNC43NywxNC43NywwLDAsMC0zLjItMi4xYy0uNC45LDEsMi4zLDEuOSwzLjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01My4xLDExYzEuMSwxLDIuMywxLjUsMy45LDMuNGExMi4yMiwxMi4yMiwwLDAsMCwuMi01LjdjLS41LTEuOC0xLjUtMy44LTMtNC40YTE1LjY5LDE1LjY5LDAsMCwxLC45LDQuM2MuNywyLjYsMSwyLjcuOSwzLS4yLDAtMS0xLjQtMi4xLTIuNEM1Mi43LDgsNTEuMiw3LjcsNTAuMSw2LjlhMTcuMywxNy4zLDAsMCwwLDMsNC4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTguNSwyMS44YTE0LDE0LDAsMCwwLDEuOC03Yy0uMS0xLjYtLjktNS4zLTItNS45LjMsMy40LS42LDMuNy0uMiw2LjQsMCwuMS4zLDMsLjMsMy4yLS40LS4xLDAtMi42LTUuMy02LjQsMS4xLDIsLjYsMi42LDIuNyw1LjNhOS4yOCw5LjI4LDAsMCwxLDIuNyw0LjQiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01Ni40LDI0LjNhOS41OCw5LjU4LDAsMCwxLDEuMiwzLjJjMi43LTEuNiw1LjgtNy44LDQuNi0xMC44LS43LDIuMy0xLjcsMi45LTIuMyw0LjgtMS4zLDIuOS0xLjEsMy44LTEuOCw0LjVhMTEuNzksMTEuNzksMCwwLDAtLjktNC42LDE5LjgyLDE5LjgyLDAsMCwwLTEuOS0zLjEsNy41MSw3LjUxLDAsMCwwLDEuMSw2Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTQsMjkuNmEzMC45MiwzMC45MiwwLDAsMCwuNyw1LjJjNC42LTEuNSw3LjEtNi44LDcuMS05LjQtMS41LDMuMi0zLjUsMy4yLTYuMiw3LjctLjItMS43LjUtLjQuNS0zLjdzLS44LTMuNS0uOS01LjZjLS45LjktMS4yLDQuNy0xLjIsNS44Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTAuMSwzNi40Yy0uNCwxLjgtLjUsMy44LS43LDUuMywyLjYtMSwzLjMtLjIsNi40LTIuMiwxLjQtLjgsNC4xLTQuMSwzLjktNi40LTMuMSwzLjUtMy43LDMuMS01LjIsNC40LTEuNCwxLjEtMi42LDIuOC0zLjYsMi42LS4xLS45LDIuMy0zLDItOC44YTE1Ljg0LDE1Ljg0LDAsMCwwLTIuOCw1LjEiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik00NC45LDQwLjhhMTYuMTksMTYuMTksMCwwLDEtMi43LDQuMUEyNi44MSwyNi44MSwwLDAsMCw0Ny43LDQ2YzEuMywwLDYtMS4yLDcuNS00LjQtMi43LDEuNC0yLjcsMS4xLTYuMywxLjktMi42LjYtNC40LDEuNC01LjEsMS4zLjItLjMsMi4yLTEuMiwzLjUtMi45czEtMy45LDIuMy01LjRjLS45LS40LTQsMy40LTQuNyw0LjMiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yNC42LDUxLjhsLS44LS40YTE3LjIsMTcuMiwwLDAsMSwxMy41LTUuNmM4LjUuNSw3LjksMi41LDEyLjUsMi4xLjUsMC0uNC42LS40LjZhMTUuNTYsMTUuNTYsMCwwLDEtMTAtLjJjLTUuNS0xLjgtOS4xLTIuOS0xNC44LDMuNSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTM4LDUxLjhsLjgtLjRhMTcsMTcsMCwwLDAtMTMuNC01LjZjLTguNS41LTcuOSwyLjUtMTIuNSwyLjEtLjUsMCwuNC42LjQuNmExNS41NiwxNS41NiwwLDAsMCwxMC0uMmM1LjUtMS44LDktMi45LDE0LjcsMy41Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNOTguMywyNS41YzAsOC4xLTQuNCwxMi4xLTEzLjQsMTIuMVM3MS41LDMzLjcsNzEuNSwyNS41VjcuNWg5djE2YzAsMywwLDYuOCw0LjQsNi44czQuMy0zLjgsNC4zLTYuOFY3LjVoOS4xdjE4Ii8+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjEwMy43IDcuNCAxMTMgNy40IDEyMS42IDIzLjEgMTIxLjYgMjMuMSAxMjEuNiA3LjQgMTMwLjIgNy40IDEzMC4yIDM2LjggMTIxLjQgMzYuOCAxMTIuNCAyMC44IDExMi4zIDIwLjggMTEyLjMgMzYuOCAxMDMuNyAzNi44IDEwMy43IDcuNCIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSIxMzUuOCA3LjQgMTQ0LjggNy40IDE0NC44IDE3LjYgMTUzLjMgMTcuNiAxNTMuMyA3LjQgMTYyLjMgNy40IDE2Mi4zIDM2LjggMTUzLjMgMzYuOCAxNTMuMyAyNS4yIDE0NC44IDI1LjIgMTQ0LjggMzYuOCAxMzUuOCAzNi44IDEzNS44IDcuNCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTE4NS41LDE4LjRhNC42OSw0LjY5LDAsMCwwLTQuNy00LjNjLTQuMiwwLTUuNiw0LjEtNS42LDguMXMxLjQsOC4xLDUuNiw4LjFjMywwLDQuMi0yLjEsNC44LTQuOWg4LjljMCw1LjktNC44LDEyLjItMTMuNCwxMi4yLTkuNSwwLTE0LjktNi43LTE0LjktMTUuNCwwLTkuMyw1LjgtMTUuNCwxNC45LTE1LjQsOC4xLDAsMTIuNSw0LjMsMTMuMywxMS42aC04LjkiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMDcuMywxNC40aDQuMmMzLjUsMCw0LjUsMS4xLDQuNSwyLjksMCwyLjYtMi4zLDIuOS00LDIuOWgtNC43Wm0tOS4xLDIyLjRoOS4xVjI2LjZoNC44YzMuNiwwLDMuOCwyLjksNC4xLDUuN2EyMy4zOCwyMy4zOCwwLDAsMCwuNyw0LjVoOWMtLjgtMS40LS45LTQuOS0xLTYuMy0uMy0zLjctMS45LTYuNC00LjMtNy4zLDMtMS4xLDQuNC00LjMsNC40LTcuNCwwLTUuNi00LjQtOC40LTkuNi04LjRIMTk4LjJWMzYuOCIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSI3NC41IDQzLjYgNzEuNSA0My42IDcxLjUgNDEuNyA3OS42IDQxLjcgNzkuNiA0My42IDc2LjYgNDMuNiA3Ni42IDUxLjYgNzQuNSA1MS42IDc0LjUgNDMuNiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTgwLjMsNDEuN2gydjMuN2gwYTIuNDQsMi40NCwwLDAsMSwyLjEtMS4yYzIuMSwwLDIuNiwxLjIsMi42LDIuOXY0LjRIODV2LTRjMC0xLjItLjMtMS44LTEuMy0xLjhzLTEuNS42LTEuNSwydjMuN2gtMmwuMS05LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik04OS43LDQ4LjVxLjE1LDEuOCwxLjgsMS44YTEuNjUsMS42NSwwLDAsMCwxLjUtLjloMS43YTMuMjIsMy4yMiwwLDAsMS0zLjMsMi40LDMuNDYsMy40NiwwLDAsMS0zLjYtMy4zdi0uNGEzLjU5LDMuNTksMCwwLDEsMy40LTMuOGguM2MyLjQsMCwzLjYsMiwzLjUsNC4yWm0zLjItMS4yYy0uMi0xLS42LTEuNS0xLjYtMS41YTEuNTUsMS41NSwwLDAsMC0xLjYsMS40di4xaDMuMiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEwNy42LDQ3LjljMCwyLjctMS42LDQtNC4yLDRzLTQuMi0xLjMtNC4yLTRWNDEuOGgyLjJ2Ni4xYzAsMS4xLjMsMi4xLDIsMi4xLDEuNSwwLDItLjcsMi0yLjFWNDEuOGgyLjJ2Ni4xIi8+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjEwOSA0MS43IDExMS4yIDQxLjcgMTE1LjMgNDguMyAxMTUuMyA0OC4zIDExNS4zIDQxLjcgMTE3LjQgNDEuNyAxMTcuNCA1MS42IDExNS4yIDUxLjYgMTExLjEgNDUgMTExLjEgNDUgMTExLjEgNTEuNiAxMDkgNTEuNiAxMDkgNDEuNyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEyNC4yLDQzLjRoMi40YzEsMCwxLjUuNCwxLjUsMS40cy0uNSwxLjQtMS41LDEuNGgtMi40Wm0tMi4xLDguMmgyLjJWNDcuOGgyLjJjMS4xLDAsMS41LjUsMS42LDEuNWE2LjcyLDYuNzIsMCwwLDAsLjQsMi40aDIuMmE1Ljg3LDUuODcsMCwwLDEtLjQtMi4zYy0uMS0xLS40LTItMS40LTIuM2gwYTIuNSwyLjUsMCwwLDAsMS42LTIuNSwyLjY5LDIuNjksMCwwLDAtMi43LTIuN2gtNS41bC0uMiw5LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xMzMuMiw0Ny4zYTEuNTQsMS41NCwwLDAsMSwxLjUtMS41aC4xYy45LDAsMS40LjUsMS42LDEuNVptNS4xLDEuMmMuMS0yLjItMS00LjItMy41LTQuMmEzLjUsMy41LDAsMCwwLTMuNiwzLjVWNDhhMy40LDMuNCwwLDAsMCwzLjIsMy43aC40YTMuMjIsMy4yMiwwLDAsMCwzLjMtMi40aC0xLjdhMS40OSwxLjQ5LDAsMCwxLTEuNS45cS0xLjY1LDAtMS44LTEuOGw1LjIuMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTEzOS42LDQ1LjhoLTEuMlY0NC41aDEuMlY0NGEyLjA1LDIuMDUsMCwwLDEsMi0yLjJoLjRhMy4wOCwzLjA4LDAsMCwxLDEsLjF2MS41aC0uN2MtLjUsMC0uNy4yLS43Ljh2LjRIMTQzdjEuM2gtMS40djUuOGgtMlY0NS44Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTUwLjIsNTEuNmgtMS45di0xaDBhMi43NSwyLjc1LDAsMCwxLTIuMiwxLjJjLTIuMSwwLTIuNi0xLjItMi42LTIuOVY0NC41aDJ2NGMwLDEuMi40LDEuOCwxLjMsMS44LDEuMSwwLDEuNS0uNiwxLjUtMlY0NC41aDJ2Ny4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTU0LjcsNDkuOWMtMS4yLDAtMS42LTEuMS0xLjYtMi4xcy41LTIsMS42LTJjMS4zLDAsMS43LDEsMS43LDIuMmExLjczLDEuNzMsMCwwLDEtMS41LDJjLS4xLDAtLjEsMC0uMi0uMW0zLjYtNS40aC0xLjl2MWgwYTIsMiwwLDAsMC0yLjEtMS4xLDMuMjEsMy4yMSwwLDAsMC0zLjEsMy41YzAsMS44LjksMy42LDMsMy42YTIuMzYsMi4zNiwwLDAsMCwyLjEtMS4xaDB2LjljMCwxLS41LDEuOC0xLjYsMS44YTEuMzMsMS4zMywwLDAsMS0xLjUtMWgtMS45Yy4xLDEuNiwxLjcsMi4zLDMuMSwyLjMsMy4zLDAsMy43LTIsMy43LTMuMmwuMi02LjciLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0xNjEuMiw0Ny4zYTEuNTQsMS41NCwwLDAsMSwxLjUtMS41aC4xYzEsMCwxLjQuNSwxLjYsMS41Wm01LjEsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNSwzLjUsMCwwLDAtMy42LDMuNVY0OGEzLjQsMy40LDAsMCwwLDMuMiwzLjdoLjRhMy4yMiwzLjIyLDAsMCwwLDMuMy0yLjRoLTEuN2ExLjQ5LDEuNDksMCwwLDEtMS41LjlxLTEuNjUsMC0xLjgtMS44bDUuMi4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTY4LjksNDcuM2ExLjUsMS41LDAsMCwxLDEuNi0xLjVoLjFjLjksMCwxLjQuNSwxLjYsMS41Wm01LjEsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNSwzLjUsMCwwLDAtMy42LDMuNVY0OGEzLjQsMy40LDAsMCwwLDMuMiwzLjdoLjRhMy4xNSwzLjE1LDAsMCwwLDMuMy0yLjRoLTEuN2ExLjU0LDEuNTQsMCwwLDEtMS42LjlxLTEuNjUsMC0xLjgtMS44bDUuMy4xIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTgzLDQ0LjJoMGwxLjIsMy42aC0yLjZabS00LjgsNy40aDIuMmwuOC0yLjJoMy43bC43LDIuMmgyLjNsLTMuNy05LjhIMTgyWiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTE5MS41LDQ5LjljLTEuMiwwLTEuNi0xLjEtMS42LTIuMXMuNS0yLDEuNi0yYzEuMywwLDEuNywxLDEuNywyLjJhMS44LDEuOCwwLDAsMS0xLjUsMmMtLjEsMC0uMiwwLS4yLS4xbTMuNS01LjRoLTEuOXYxaDBhMi4wOSwyLjA5LDAsMCwwLTIuMS0xLjEsMy4yMSwzLjIxLDAsMCwwLTMuMSwzLjVjMCwxLjguOSwzLjYsMy4xLDMuNmEyLjM2LDIuMzYsMCwwLDAsMi4xLTEuMWgwdi45YzAsMS0uNSwxLjgtMS42LDEuOGExLjMzLDEuMzMsMCwwLDEtMS41LTFoLTEuOWMuMSwxLjYsMS43LDIuMywzLjEsMi4zLDMuMywwLDMuNy0yLDMuNy0zLjJsLjEtNi43Ii8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMTk3LjksNDcuM2ExLjUsMS41LDAsMCwxLDEuNi0xLjVoLjFjLjksMCwxLjQuNSwxLjYsMS41Wm01LjIsMS4yYy4xLTIuMi0xLTQuMi0zLjUtNC4yYTMuNTYsMy41NiwwLDAsMC0zLjYsMy41VjQ4YTMuNCwzLjQsMCwwLDAsMy4yLDMuN2guNGEzLjIyLDMuMjIsMCwwLDAsMy4zLTIuNGgtMS43YTEuNTQsMS41NCwwLDAsMS0xLjYuOXEtMS42NSwwLTEuOC0xLjhsNS4zLjEiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMDMuOSw0NC41aDEuOXYxaC4xYTIuNzUsMi43NSwwLDAsMSwyLjItMS4yYzIuMSwwLDIuNiwxLjIsMi42LDIuOXY0LjRoLTJ2LTRjMC0xLjItLjMtMS44LTEuMy0xLjhzLTEuNS42LTEuNSwydjMuN2gtMnYtNyIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIxNi42LDQ3YTEuMzIsMS4zMiwwLDAsMC0xLjQtMS4yaDBjLTEuMywwLTEuNywxLjMtMS43LDIuM3MuNCwyLjIsMS42LDIuMmExLjYyLDEuNjIsMCwwLDAsMS42LTEuNGgxLjlhMy4wOCwzLjA4LDAsMCwxLTMuNCwyLjloMGEzLjQ2LDMuNDYsMCwwLDEtMy42LTMuM3YtLjNhMy40MywzLjQzLDAsMCwxLDMuMi0zLjhoLjVhMy4xMiwzLjEyLDAsMCwxLDMuNCwyLjdsLTIuMS0uMSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTIyMyw1Mi41YTIuMjEsMi4yMSwwLDAsMS0yLjUsMS42LDQuODcsNC44NywwLDAsMS0xLjItLjFWNTIuNGMuNCwwLC44LjEsMS4xLjFhMS4wOCwxLjA4LDAsMCwwLC44LTEuMS4zNy4zNywwLDAsMC0uMS0uM2wtMi41LTYuN2gyLjFsMS42LDQuOWgwbDEuNi00LjloMkwyMjMsNTIuNSIvPjwvc3ZnPg=="),url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxODBtbSIgaGVpZ2h0PSIzLjMxbW0iIHZpZXdCb3g9IjAgMCA1MTAuMjQgOS4zOSI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOm5vbmU7c3Ryb2tlOiMwMDcyYmM7c3Ryb2tlLXdpZHRoOjAuNXB4O308L3N0eWxlPjwvZGVmcz48cG9seWxpbmUgY2xhc3M9ImNscy0xIiBwb2ludHM9IjAgMC4yNSA0OS42MSAwLjI1IDU4LjM5IDkuMDQgNjYuODcgMC4yNSA1MTAuMjQgMC4yNSIvPjwvc3ZnPg==);background-repeat:no-repeat, no-repeat;background-position:15mm 10mm, 15mm 28mm;background-size:55mm, 180mm;@top-right{content:string(h1-subtitle);margin-right:-10mm;margin-top:16.5mm;color:#0072BC;font-size:1.5em;text-transform:uppercase;vertical-align:top}@bottom-right{content:counter(page);margin-right:-10mm;margin-top:10mm;padding-top:1.5mm;color:#0072BC;font-size:0.9em;vertical-align:top;border-top:0.5px solid #0072BC}@bottom-left{content:"www.unhcr.org";margin-left:-10mm;margin-top:10mm;padding-top:1.5mm;color:#0072BC;font-size:0.9em;vertical-align:top;border-top:0.5px solid #0072BC}}@page back-cover{}.back-cover{page:back-cover}.back-name:after{content:string(h2-author)}.title-page{margin:0mm -10mm 22mm -10mm}.title,.date{color:#000}.title{font-size:3em;line-height:1.1;font-weight:700;margin-bottom:0}.date{font-size:1.2em}.front-page .author,.front-page .author-afil,.front-page .author-email,.front-page .email,.front-page .subtitle,.front-page .abstract{display:none}.toc,.lot,.lof,.loa{display:none}.back-cover{position:absolute;bottom:0;margin:10mm 20mm 5mm 20mm}.footnote sup,.footnote-ref{color:#0072BC;font-weight:700}.front-page{counter-reset:page 1}.section>h1,.section>h2,.section>h3,.section>h4,.section>h5,.section>h6{break-after:avoid}.footenotes{break-before:always;break-after:always}.bg-blue,.bg-grey,.figure{break-inside:avoid}caption{break-inside:avoid;break-after:avoid}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Sudan Situation</h1>
<h1 class="subtitle"><span>R Workflow Demo</span></h1>
<h2 class="author">Cédric Vidonne</h2>
<address class="author-afil">
Information Management Officer<br /><a class="author-email" href="mailto:#"><a href="mailto:vidonne@unhcr.org" class="email">vidonne@unhcr.org</a></a>
</address>
<h2 class="date">10 February 2025</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
<p><img role="img" src="data:image/jpeg;base64,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" /></p>
<div class="col2">
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
<p>Lorem ipsum dolor sit amet, <strong>consectetur</strong> adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
<p>In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
</div>
<blockquote>
<p>It is further proof that refugee movements and the broader issue of migration of populations … is a global challenge that cannot be confined to a few countries.</p>
<p>Filippo Grandi</p>
</blockquote>
<p>Lorem ipsum dolor sit amet, <strong>consectetur</strong> adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel.</p>
<div id="section-title" class="section level1">
<h1>Section title</h1>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
<p><img role="img" src="data:image/png;base64,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" width="100%" style="display: block; margin: auto;" /></p>
</div>
<div id="section-title-1" class="section level1">
<h1>Section title</h1>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper. Nunc pretium aliquet metus, ac pellentesque dui pellentesque vel. In et arcu aliquet, dapibus nunc vel, consequat metus. Quisque vel volutpat mauris, ut hendrerit quam.</p>
<p><img role="img" src="data:image/png;base64,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RUdH63S67du3Z2RktOuqAAAAAOBuRpa+033yySdTp051dHTUaDTdu3dft26dh4dHbW3trl27rB2mT58uIhEREdeuXbONslgsa9euFZHQ0FBbo7e395EjR2JjY00mk16v1+l0jz322Pz580UkPj6+XVcFAAAAAHczsvSdbtiwYXU/arVaa3jev3+/tcVgMIwbN05+3Ii2OnnyZHFx8TPPPNOtW7e6w/v27avRaOq2+Pv7i0jdZ7ABAAAAAE0jS999vLy8RCQrK8vW8pvf/EZE/vSnP9XW1lpb1q9fLyILFy685dU6d+4sItXV1W1RKgAAAADck/RqFwDFHBwcROSHH36wtXh7e/fr1+/ixYtpaWm+vr4lJSUJCQmenp6enp4Nh1+9enX//v3JyclZWVn5+fkVFRXtVzoAAAAA3BPI0nefkpISETEajbYWjUazYsWK2bNnr1279h//+Ed0dLSIrFixot7A6urqpUuXxsTEtGe1AAAAAHDvIUvffb755htp8Bz1hAkTOnfunJycnJub+9577zk5OdlehWUzbdq0gwcPDh8+/JVXXjGZTF27drWzs0tPT3/66afbrXgAAAAAuAfwvPSdrqampu7HysrKDRs2iEi9AKzX6xctWiQis2fPLisrW7x4se1VWFbXrl07ePCgXq/fsWOHv7+/wWBwcHDQarX1rg8AAAAAuCWy9J0uJCTk0qVLFovFYrHk5OQ8/fTTN27cGDJkyNChQ+v1/MUvfiEiZ86cEZGf//zn9b61s7MTEbPZnJaWZrFYRKS8vDw2Ntb6emoAAAAAQPNxj3c72bx589///veG7Z988knDm7FtfHx8hg0b5uvrW7fxgQceiIqKqvdqKxFxcXEJCgr67LPPpk6d2rVr13rf2tvbh4SEREVFBQUF2RpNJtPu3bvrXR8AAAAA0DSydPsxm80NG61bxDfz8MMPL1u2bODAgRs2bMjMzPTw8HjmmWdmzZrVqVOnRvs7OjqKyPz58xv99p133hkwYMDHH398+fJlDw+PmTNnBgcH6/X6eo9eAwAAAACapmk6y+EuUlJSMmTIEC8vr8TExDadaM2aNevXr7do9Zef39ymE+GeMjpb7Qpw7whznKN2CbibZA9KU7sEAGhly6oMffr0UbuKjo7npe8dGzdulMZehQUAAAAAaF1k6XvEtWvXwsPDnZ2d/f391a4F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" width="100%" style="display: block; margin: auto;" /></p>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pulvinar porta tincidunt. Etiam tincidunt mi eget pretium ullamcorper.</p>
<p><img role="img" src="data:image/png;base64,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l19+edCgQXfeeadGo6l9QvPmzUeOHPnll18GBwf3798/NDTU+yEBoInSMKsHAADgyrN79+633377L3/5y6233trAabIs33XXXUKI6Ojo1157LSgoyFsBAaBpo5YGAAC40vz444+ffPLJQw891Lt378uenJGRYbFY5s6dO3LkyDvvvNML8QDgCsAcbwAAgKYhKyvr6NGj6enpiYmJ9Z0jy/LKlSvXrFkzefLkjlzVphwAACAASURBVB07OtKtbWXv5OTkr7/+Oj09PS0tzW2JAeDKxbg0AABA0zB79uzCwsLCwsKEhISuXbt27dq1bdu2Wu3vS8lardZ//etfu3fvnjp1asuWLZ3qfNasWRkZGUKIpUuXujc2AFyRGJcGAABoArKzs0+cOPH222/rdLr9+/fv3r17wYIFAQEBnTt37tq1a6dOnYQQb7311tmzZ2fPnh0fH+9s/4888siTTz4phLBarTqdzv1fAABcWRiXBgAAaAKWLFkihBg/fnxNS3V19dGjR3ft2rVnz56SkpLIyMjIyMjJkydHRES4donS0tLx48c/+OCD/fv3tx/uBgDURi0NAADg64qLiydNmvTiiy+mpKTUflSW5dOnT2dmZvbq1auRC3Hv3r37nXfead68+aRJk1wY3AYA/0EtDQAA4OuWL19+/PjxGTNmeOFaRqPx//7v/3bt2jVu3Lh+/fp54YoA0BRRSwMAAPg0s9k8ceLECRMmpKene+2iX3311fLly4UQ991336BBgzQajdcuDQBNArU0AACAT/vxxx/XrFnzyiuveLmgffLJJ/Pz82sODQbD2LFju3TpotfrQ0ND8/Pzk5OTvZkHAHwKtTQAAIDvkmV58uTJt9xyy6BBg7x8aavVKoQoLS09ceLEsWPHdu/eHRYWdvLkSSFEYGCgxWK5+eab7733XoasAfgnamkAAADftW/fvsWLF7/11luNXFTMXUpLS4UQR48e3bp1686dO7t27frUU09RTgPwQ9TSAAAAvmvevHlt27YdM2aM2kHqkJ+fP3369OTk5NmzZ6udBQC8jZ0DAQAAfNTp06ePHj06ePBgtYPULSEhYfbs2SdOnFi7dq3aWQDA26ilAQAAfNTatWt79eoVFRWldpB6JScnjx8/nloagB+ilgYAAPBFxcXFW7duveWWW9QOchmtWrW6ePGixWJROwgAeBW1NAAA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pMuf6ktuvvnmnJwco9GodhB/J8uyLMsBAcy1BOBt1NIA/AVzvH0BEwRQ2xNPPJGbm/viiy+qHcQ5w4YN02g0K1euVDuIv4uJidFoNLZdpgHAm6ilAQCAmrp06TJp0qSMjIz58+erncUJAQEBqampv/zyi9pB/F1ERMR999336aef7tu3T+0sAPwLtTQAwEua3CReeE2PHj0eeuihgwcPvv7662pnccIdd9xRVlaWkZGhdhB/N2jQoJ49e7799tvcNQ3Am6ilAQDew0x71Kd///733nvvr7/++s4776idxVHt2rULCwtjo2lfMHHixOjo6H//+99qBwHgR6ilAfgFbtMFfN/gwYPvuuuuLVu2fPjhh2pncVTv3r2PHDnCnAvVaTSaBx54YMOGDYobp61Wa3l5uVqpAFzZWPMQgL9gRBTwfbfeeqvJZFqxYoXBYPj73/+udpzLGzNmzPfff//NN9+MHDlS7Sz+rl27do8//vibb76Zn59/7bXXVlVVrV27NisrS5blBQsW6HS6pP/P3p3HN1WlfQB/zrk3S9s06b5T6MKOgFRA8UVAEKaoo47jggOCG6CIioCCiIIsoqLIoKA4OKKiDqigrLINCEKVrbKvpVu6L2mSZr33nPePIINQoJSkN22e7+ejpjc39/wIts1zzxYfr3RGhFCzgrU0QiggYL+0P8C+O1Qff/vb35xO5+rVqzUazQMPPKB0nKsIDg5OTk7evHkz1tL+oGfPnq+88spnn322adOmmJgYSZIGDhy4d+/el156CQBGjRrVp08fpTMihJoPrKURQggh5F+GDBnicDhWrlyp0Wj8v0a99957PX2hsbGxSmdB0KlTp7lz5154ZPjw4TabbdGiRZ988slNN90UEhKiVDaEUDOD86URQoECx3gj1IQ89thjffr0+c9//rNx40als1xFz549tVrtV199pXQQdFnBwcFjx44VBGHDhg1KZ0EINR/YL40QQgghL7Hb5ZIyoAJERgq6oOu82KhRo5xO59KlS9Vqdd++fb2Rz1cyMjJ+++03xhil2Evhp9Rq9Ysvvjhv3jxBEPr27RsWFqZ0IoRQk4e1NEIIoUaCs9abMbmwyLU1SzKWgNVOCCEhWrFFgnj7LULCdQ17fu655955553Fixer1epevXp5K63XPfzww7/88suOHTtwOq4/69Kly9ixY1etWrV8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y8I9wWTg/0wY//gTT/zpzdei764uqB//f7761erq6t13l1IuXbr0xRdfjEajiBgMBhsaGjwez8qVK2+++eYvfvGL//Zv/5b/hvTMM8/8wx/+sHDhQhzuMniKoiij6+j7cKYoyijST56FLpfx4Rbo6z+udvzmjzdHmbbNMpo/jt1863VDO+amTZtyudxZZ501vKEeDtkXFduaZHs3K/BSoU8SYaAIDVMOxJklRDJFhiH748zjBklYVMCryiCRtFo6SFga56z4kCtXW+s/yix5CTq6yWHnoSDoGghJyYQI99DaD8iuu6684Ehc6RHFGEPETGYofXSUMcvj8RCRlPLAE0mkYQHn6LCRaaJl7fFlEOUMhggM0bmfVSGIH368WRrGjf/3/x4kIAReXwtCyu4e0daJnANjZJrocOS7amOBd48jc7fHZBwkoNcDQJRKgWEgQ83npgyndJYhAGrM6QAA4ByISEimc7IECIlElDXQYYNEGl0OVlKIdpthGNu3bz/ttNMOegPHNEReGYKKEKUzYFlfn3Nf50DfC//85/r16//zP/9zzpw5F198scPheP755zds2BCJRKSU48aNu+aaa2bPnr3r9+Gqq6767W9/++KLL/7rX/8KBAKFhYUDAwOhUEgl0oqiHHtULq0oyqFgTJs5hU0cJ1vb9YHEnPPOxMKCDjKfvvunvf39JSVDKcSVTqcBYP369ZMm7aNI7yggkq0dojOCwRLgGsgIcg6IYLdhSZEM91DPAHJkpQGwaZDOgpCAiEV+ZreJzgjLl/g+pPnqlpV7frnoDDOv59PqPpxhQYHmsIvufvHOJuukBm38fudYjmVcVTs/trhcLgDIZrOuAxYaZDYNHHZm09HtkskUOhxg1xEZSUm5HORM0nX0uCTst9R449ZtVbU1xaWlBw0JbTZtWr0o8mOkl9IZkAA2nRX6eGVon1219fFVYlsjRRPotIMlKJkh0wRkyBgCEgIBkF37pMM0IWeAKC2BlkDOgOvUHwW/jwoLWFmA11RIKf/7v/8bAI6RSnsI+MlkgQp35de//nUA+POf/7x06dK33noLADjnVVVVF1xwwXnnnbf3rwFj7Otf//qVV175r3/966OPPurr6+vp6TnjjDNG+CIURVFGgMqlFUU5ZMzlYJPrdj2sJiotLV21atXFF188hKM1NDScddZZL7zwgtfrdTqd/f39l1122fAFe8hkLCGjcdA15naBZQFjJER+PAU5A67JvigWFYBNy49WAWPIGQAwtwtiSdk7QH1RDBQN/ozWR1tkpB8Y4t5lcu0O7rHL/qix5m1t/EW7vcayOiOaZUFpUb7j95ilBqOOMV6vFwASicSBc2lgjBUXSY8bbTrjXspmKZYjksAY2nT0OKUQPFTCdJ2yub0LDVA6KxmmSAz2aynOeWWIVwTBtEhKtOkHeCFfcDK8v0k2t7HeGDAkwwRA1Li0TCAJnAEBGhbYNQAASxDnqDEwBQhBdpuQJpLg5UGtrpZPHLelpfm+++5LJpN33HGH49A7Ah4trrzyyiuvvLKnpyeVSlVXVx+0vIXP57v88ssBIBwO33bbbRdeeOGIhKkoijKiVC6tKMrh6u/v7+rqOvnkk4d8hOuuu66pqenJJ5/MPzznnHN8Pt8wRXfoMjnI5Fi+WJGmgcMBFAVzZ29t4giGAZwBAOUM1Dk6HYAIQogdbdbW7RRPGK+vBb9fH1dhP+VEGETTLLm9nTIZvr8S6C4X9cWou2/nw3Bv5vmXrW0tkM4AgLQ7bFUh/bxTtbrxw3L1w26slZRTDlMgEEDEDz744KClpPiUcaK1TbZ1Y1UZM91kmCAlMEYao95+XhXix01BkDLcy0pLIJcD0yLcWZdbhHvqTzrx8TWrXn/99fnz5w82OESw6Qf98oYX+10XnJn5+4uyvVsaFpdCMg7CIsNiuk4eN6YNKSzMGsA5cICsSWCBRHDYsMTPioq0KRNtpzaw0uIPN2362c9+VlJS8r3vfW+P5cTHpEAgEAgEDukla9asmTZt2qG+SlEU5aigcmlFUYaOiHp7e5csWTJ9+vTy8sOagbx48WIAeOaZZ55++mnPqA60EkkC2jWayosKIJGUAzFWUgiMoQSQhAQkhIwleKGPFRaAYVir37E6wjKaQMukaBK6eozmduvjRv2cebYTZhz4jJZpIgExbZ85AGmcpADLAgDr4+3pPzxHnWFK58DGGYC0+o1wr9HS6Tj/TPsZJw3zvThsRLT7HO94PH7//fen0+l8T18AyPfwze+Zf3jVVVfNmLHnHXviiSdWr1596aWXLly4cKRiV/aNMVZQUPD2228fNJfWaqtoSr1pWKKlgxcVgsfJECmdleF+XuTX62r1U08U25plV6/x9vvIGSDL180mkrYJtcefd87Sga7HHnvsEHLpQdNmz3Q57Nm/LzObW2XGIJCAqLscYLNToRfiSYwlyTBBCpAoOTC7DV0O27gaCBWDv0CfdyILBQDg7bffRsT77rtPfWe0P+vWrTv99NNHOwpFUZQjQv3pVxRl6P74xz/eeuutGzZsGNrs7r1t2rTJ4XCM7qdS5nCg3UaZXP4hFvhYsZ+5nTLSB4mUNAzgTGYy0NPPfR5WXIRet/nW+1Zzu4zFyO3EYDEfV43jqlHXRFN77l+vi+1NBz4jLy4mnZNh7nOrzGS4TSOfD6LR3J/+IVvaQAqsCvHyEJaHtOpy0jXoCmeff8X6+CAnGhX/+7//e80111x77bXXXHPNjTfeuHXrVgBARMZYvjgZ51zTNF3XdV0fGBi49957w+FwOp1+7bXX1q1bJ6UEgBUrVmSz2d///vd//vOfR/uCFJg4cWJzc/Ng9tTnnajN/gKfOI6koHCv6OqhXI6Pq9BPnKafORcYAyGICEmCEGiZlMtBJoNSSinR573ua1/L5XIvvvjikbgKPmOK/bJztFnTtEm1PFAEJcVYWsrqq0G3ScuSDMGmAYDUWFiYb+USf8vG2PwTwOPWKkOsaGd9wfw05j/+8Y9HIsJjQF9fX1NT01hr06AoijJc1Li0oiiHLD+E+Prrr7/66qv33nvvYY5I7+7yyy//0Y9+tHXr1okTh9iq+vBhgRd8XuoZoJyBdhsgsIoQcY3Zo5RMQzIJXCNLYKCIFReyQLFs7RLtHTKVZsEAZbJgs4FNZ4xBsAR1Rm2dxstvOevGHeCM9hOnGMtelfFOMg3UPzvTmwBjafR79akT00tfE53dyDkL7d5iCnlJIfRJ0dube3GlNvlAJxp5d9xxR1tbm2VZuVzuueeec7lct9xyy97DzrtYlnXjjTf+13/9Vy6Xy/+aFRUV3X9h9ZHjAAAgAElEQVT//W632+PxTJs27fnnn08mkzfccMMIXoSyp1NPPXXt2rX9/f27egjvF2O2k2Zq9bWyuUNE4yAlL/Cy2goWKAYA2d4tOiNo17STZkI6C6bJAdBmA4YiGheNrZWzpgUCgeeff/6LX/zi4YctpXzyySdXr15tGMY3vvGNhoYGdDj12kpZVYEfbYNIHxR6REeE4knIZDDfK4sxYUlGVH/c1KbNG575ze9CUyfPPmGabt/5PvX5fCeccMLy5cuvuOIKm20/yzQ+x9atW1dfXz+YbuSKoihHI/7DH/5wtGNQFOVo0tPT8z//8z+PP/74u++++61vfWt4k96SkpIXX3wxEonMmzdvGA97aBgiQ8rmRFcE7HbUNUBkXjc4nJBOs+JCXhbQAiVgt7FgADmzNmyR7d3gdoEgtOvocuEnn7PR6aSBKADx8bXM793vGR0O0dsvu3phIIZ2O2ifTIoW0oqEkWm8vtr5lfMyzy4TXT1YWox8r69BnS7ZH0MG9tmzYH/rrkdDMBicOHHi5MmTp02btn79eiL66le/eoD9GWMnn3zyihUrHA6HYRgAkMlknn322Uwmc8opp1xzzTX/+Mc/WltbL7roogMcRDnSgsHgP//5z9bW1kG+T9HpYGWl2rgqbXw1qwjurK0tpbW1SbR388oy5rCjy4leN3rd6HKg04FCUjqLbueEWV9YtmxZZWVlZWXlEEK9//77lyxZ8vLLL69cufLpp5/etGlTXV2druvLli1jjE0aN0H2xyCZpFSaAcnOiIzGwDBA14FzYGgJYUrhZMwnoG5cXadGq5u3/2nVinXvvOPxePIhfeELX3jhhRe2bdt2JOaiH+3+9Kc/zZ49u76+frQDURRFOSLUuLSiKIM1MDDw0ksvrVy5ctasWd/61rccDsfBR6UOXUNDw5tvvjnshz0kLBTgWQMYykifIACbjkJI0+KVZaw8yCdUi61NsqtHtHSg0yEjvZTOocOGNg2cjl29ZHZy2imVFV1hXlN2gDO6Lj8vFe6zPt4hwz2oc2IcJIFpaE4Hqyy3X3sJWBYm0oyQ6XtWPAYAQOA6l+mc1d2t+ev2scMYcPbZZz/66KPJZPLA6+EDgcDvfve7XQ/j8XhjY2NZWVkwGFy9erVpmntk462trT/84Q81TTv99NMvv/xyTVP/v3bEMca++MUvLlmyZFBD0/tBqTQlU+iwo76PHxn6vbKti6KJSTMme73el19++aSThlIOYO3atSUlJU6n0zAMn89366235nvvPfLII3/729/8bs8phaWiuQ10Teo6mSZICU4nApAUAJDJZlC3OTWdCeF12L588TUXTJ/0z6VLX3755QceeOA3v/nN9OnTg8HgvHnzXnvttaHdh2NYf3//1q1bb7rpptEORFEU5UhRnzkURRkUInrggQcQ8dprr50zZ86Ra3Q0bty41157TUo5mqumEfm4SvS5ZWdYxhJgCuBMd7tZsJiVlwJj2nGThN+H3b2UTkvOiANze5nbAU47wGfuDGMagTz4GTXNffO1xvOvWO9+aPbH0LKIMeYt1upr9Yu/pJX4wbIkgMT9V7lAYEj7b9Y7+ubPn//oo4+uXbt2wYIFg3+Vz+ebOXNm/n9HIhFE3L2OUUdHx1133eXz+UKh0D//+c/ly5fX1NTMmjXr/PPPV7WgjqhLL730pZdeuu2222677bZdP6BDQoYJlmA2fd+bNY0sQZYFAKlUqqqqasihXnXVVXvn4V//+tdjsdjv/t/v5979c9YZsDZslgNxsCx0OQERTAuEBM5I16VlMreLpIRoHITUdP2CCy644IILwuHwU089tX79+vyECwC47bbbbr755vHjx2hF/ZG3evXqurq64uLi0Q5EURTlSFG5tKIoB9HR0bF9+/aWlpaOjo7777//IE1lD4OU8u9///uSJUtqamrGQiLEigtZcSEZBhgmcI4OO+z6BoEzXlPBKkOQzpg7mrEvSjYOzn20lqVsFgr9vGSvxtF70zTbRefYzj/T+mg7RGPgcGoTx4Pfs2sr+n2sI4y5HNn3GpomIQ0THXatcuw2nmGM2Wy2lpaWIR/hpJNOeuaZZ6677rpJkyaVlpY2NTV1dHR4vd5f/vKXNputp6fn0Ucf7enp+etf//rMM8/Mnz//2muvVUtYjxDG2AMPPLB48eJ77rnntNNOu+GGGw75PatpwBlZ1r7L1wsBnAHnAFBQULBhw4Yhh2pZ1j6fv/XWW7/61a+u2rzxjCkTrM4ItndLSwJYAACSwGFDu82m8cTAgNA4tywZT8uuCAiRjyoYDN58880AYBjGs88+i4gvvfTSj3/848cee2zIoR5j3n777TPOOGO0o1AURTmC1HppRVEOZOPGjYsXLx4YGCCiyy+//HBGhw7qZz/72apVq0488cQ777zzyI17HyrkHG22/KrpPTcxhnYbGEK0tkNflBX4YY9dkikrlrSNq7Sdc8Zg2yYwxoIlrKaSVQT3WPksunuovdtKJpjHBfiZw4neAeTcNn2ifkrDIV/hCHr66adnzJgxderUob3c5/MtWrTINM0NGza0tra6XK5Zs2bdfvvtDocDANxu96mnnnruueeeeeaZ3d3da9asWbJkyebNm4mourp67PxGHTN0XT/rrLOklMuWLVu1atXs2bMP6Ys21HXZ0yd6B9Dnwb3z8HgSGeNVZaywoKKiYtmyZa+//noqlZo8efIh/SifffbZSZMm7XO9Luf87bff3rhx43lXXckyObG1CYwcMgaI6HIyh6OntzedSukAnqIiQATLZIEifeZU+Gy0nPPjjjtu2rRp+VZhs2bNKiwsHHyEx7CmpqZkMjm0aQuKoihHBZVLK4qyX52dnXffffcVV1xx/fXXz5kzJxQKHblzvfjii8uXL//GN75xxRVXHF1pDy8LyaY26o1SLE5uF/Kdn7NFPCG7I1p5SD9jDq8ehlun15ZbH26R/QlMpsBhw3zfZmHK3gEwDF5ZYb/qAlaw/wpnY8DTTz99yimnjBs39GLjnPPp06eff/75F1544cKFC0844QRd33OSsMPhmDNnzqJFi5LJ5KZNm9588818Uh0KhdR002E3bdq0WbNmrVy58vnnny8qKqqtrR3sKxmCaUEqLaMJ5nXv/l0VZXMi0sdCAW1CDdr0UChUVlb26quvfvTRR8uWLduyZUsgEBjkj3LJkiWVlZXTp0/f3w5r1qw5bvr0QE2lta1ZdPcBEDqdqOsAIE1TGoavqMjmdVHWBJ3z6jI+rhr3NQMFAKqrq5cvX75ixYovf/nLR9cfsSPENM1XXnnlnHPOUXdDUZRjlcqlFUXZt76+vp/85Cdz5sy56KKLRuCT0E9+8pNp06ZdddVVR/pEw48Bq6mgrrBMpmRXr0wk5P/P3p0GRlGkDwN/qrqn555MJvcJgRyEIyAIG0BAQFDAC0HX21URL8BlBWVVPJY/Koeri8cqHut67rqKKMohgoAQ8OU0nAkQciczk5nMfXV31fthEDGEJAyZJEj9Pg0z01XVyWTop6vqeTxu2mADX5BLTVIOHSCMLmylBQogSYDgzKnv3xAE3C2NVtbIfj/YndTlpk43cXmRoOAzkhU3ThJ6dd5GTUoBUNNp+d8ihKxYseKKK66I6k2ZUziOC2+cHjduXCAQOHDgwHfffVdZWTl06NAO6P2iEhsbO3HixNLS0jVr1hw/frzt+RSwXkf9AerxkQY7QggAgSiCwyU3NHIpiXzPTBx3spZSRkbG5MmTDx8+XFdXZzabLRbLyJEj29LF119/nZaWdskllzT7alZW1saNG9etW7fyu3UDMrMMLi8NBBElQClIsqBUuv1+EWOdSkVDIWwy4sw0Pi0J6ZtPnocQGjFixNdff63ValnmagAwmUz//e9/hw0bptd36Xt8DMMwEWOxNMMwzXC5XAsWLMjLy7vnnns6IJAuLi7evHnzY489doFecmGNWlGQB4RijgOMOUEJsUac01195WX8ZS0tuqYen1xeJZdVkspaUmumTjcghDSqswXVODZGGHwJEWWMgfAK0GtwYrxwSb72jhv4nG7RObkWSZJcYybl1dKJKrm6njpcIBOkVTc7/sbGxtWrV1977bUxMW3YPd5+lEplOKjW6/WrV6/etGnTF198UVpa2r17d4PBYDab33vvvaKiop07dyYkJLDVuZHBGI8YMUKv169bt+4cqkNhjONiw7dgqNdP3R4aCCJB4FIT+Z6ZOPX0OuqAEBo1atTkyZO3b98uSdIVV1zRlh5WrVqVmpo6aNCgZl9FCE2aNCkuLm7Xrl05hZdmIIFa7cBhpOCpoOBUSqvbKQDSShTF6Pjc7nyiCScnIsNZE9GrVKrvvvvO4XCwfcIAoFAo9u/fLwhCz549O3ssDMMwUcFyjzEM01QoFFq6dGlaWtr999/fMWvzVq5caTAYUlJaqhrV1anVymuvAFmWqy0ghsCk51qrFUTqLHJZFWmwE58fKXgqEcRhbLXhlEQup/vJJdxn0qk0t1wNAOAJAEjQYn2pqKIer1x6glhsssONAChQGWMuNgY32Lm8HqeKbJ9itVoBICkpqbnGOsL48eMRQqtXr1ar1Xv37t27d++oUaP27t3r9/vVarXL5RJF8dFHH+2s4f0OjB8/vqKiYuvWredwjILne/WkqUmk0UmDQYQx0mpxnBHOkt8bY0wIqaqqCoVCbUkshxCqq6tr+T3hOmpHLPUOS10+lpM4TvYHXC4nUDAi0KoEZDJwuT24lERQKlut396/f/+dO3e2OrCLRG5u7sGDB8ePH9/ZA2EYhokKFkszDPMblNI33niDEDJjxowOS6ZdWVk5cODAjukrujiu5TrSp5CSo95nXpO8Xg4QJRRxVIhLwHdPJvU2CImI57js7q00oWt+02bHoKGQdKSMVNSAgucyUxDPh5+kVrvsCwAA1yenye2A+vp6AOjcxNrjxo0bN24cAJSWln744YebN29GCC1evDgtLe3BBx8MVzZizse11177ww8/HDx4sE+fPm0/Chl03Nkne8/sYvny5dXV1W2pPlVQULBjx45//etfd99999neE97Av2PH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YcOGhb35+fHjx00m0w033NDoqwKBYO7cuWfPnl2zZs327dsJIQUFBfHx8fXL1xRFUVRHQPd4UxQValqt1uFwnDx58tprrw13LIFBjDX4fBnwcig2CqK/92xDyETriMcNHC5gd+FaK66pBR4P0kawacni64cBSevKFDMMU1hYuH///htuuCEEy3ftlJqaumnTJqlUmpaWFu5YwqN79+7Jyck7duzYv3//mDFjrrxDDe3ndruXLFmi0+lmz55dv5k5qAgh7733HkIIYxwRESGRSEIwaaNhvPPOO2PGjOnTp8kHamKxuFu3bp9++umJEycyMzNLS0vvvfdevV4fyjgpiqKo5tFcmqKoMNDr9R9//HFubm5aWppcLg93OO3FF5fzpRUoUgvZC/MlhmEM0YTnkFLJpMShuGgmNVGQ0Ud4zSAgassSXEZGRmZm5qFDh2644QYYkorcbcay7MGDBwsLC8eNGxfuWMImJiZmwIABmZmZP/3008iRI4PX5KmTOnz48B9//DF//vzQrEgDACCEgwcP5nn+0KFDn3/++fHjxy0Wi1QqValUofwLdfjw4cOHD8+cObP5Jwg6na6wsLCiouLhhx9++OGHY2NjQxYhRVEU1RI0l6YoKgzkcvm1115bUlLyySefxMTEGAyGDp4ZNo8vqcDGGkavbeQ1CCFiULROOHywIKMPm5qIdBGgre+VZdlevXpt27YtJydn+PDh7Yk5BDiOO3To0IQJE0KWKXVAERERQ4cO/eWXX37++WeaTl9EIBBs2bLlpptuCuX/IUqlsmfPnmPGjBk7dqxYLM7Ozv7666937dplNBoZhtFqtcHui+71et95552bbrqpR48el71Yq9UOHTp06NChdF8DRVFUB0RzaYqiwkOhUAwaNCg6OnrNmjVZWVlXX311aDZ5BgMxVuMaM4pQN5okE7sTClkUq4fiAORRWq1Wr9dv3brV5XL169ev/QMGT0pKyubNm8vLy7t4/x6lUnnttdfu3Llz+/btV1999RWwESNQ5HL5vn37oqKi4uLiQj+7WCxOTk4eNmzYjTfeGBsbW1paunnz5u3btw8Z8v/t3Xdc1XX///H353MOQ/YSUECWAg7c5sDFpQ1LL82stDS1rK68WpZ1+cs9szLT7LLl+FammViiX0txYpoLFQcuXAgKLkDGgcMZn98f5/ry5SuoHIQz6HH/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" width="100%" style="display: block; margin: auto;" /></p>
</div>
</div>

<div class="back-cover">
  <h4><strong>Contact us</strong></h4>
  <p>
    <strong><span class="back-name blue"></span></strong>
    <br>
    <span class="back-afil"></span>
    <br>
    <span class="back-email"></span>
  </p>
  <p><a class="uri" href="https://www.unhcr.org/" style="text-decoration: none;">www.unhcr.org</a></p>
</div>
<script>
  let userAfil = document.querySelector('.front-page .author-afil')?.childNodes[0].nodeValue;
  if (userAfil == undefined) {
    null
  } else {
    document.querySelector('.back-afil').innerHTML = document.querySelector('.front-page .author-afil')?.childNodes[0].nodeValue;
  }
  let userEmail = document.querySelector('.front-page .email')?.childNodes[0].nodeValue;
  if (userEmail == undefined) {
    null
  } else {
    document.querySelector('.back-email').innerHTML = '<a href=mailto:"'+userEmail+'" style="color: var(--unhcr-black); text-decoration: none;">'+userEmail+'</a>';
  }
</script>


<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
